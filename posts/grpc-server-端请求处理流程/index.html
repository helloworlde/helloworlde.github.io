<!doctype html><html lang=en><head><meta name=viewport content="width=device-width,initial-scale=1"><title>gRPC Server 端请求处理流程</title><meta charset=utf-8><meta name=description content="Ladder@gRPC Server 端请求处理流程 [TOC]
初始化 创建并启动 ServerTransport 在 Server 启动的时候，最终调用 NettyServer 的 start() 方法，为 ServerBootstrap 添加了 ChannelInitializer，最终，当有新的连接建立时，会由 NettyServerHandler 调用该类的 initChannel 方法，初始化一个 NettyServerTransport
io.grpc.netty.NettyServer#start 在初始化 Netty Channel 时，会先创建 NettyServerTransport，然后调用监听器的 Transport 创建事件，添加一个超时取消任务； 然后会调用 Transport 的 start 方法启动 Transport
b.childHandler(new ChannelInitializer<Channel>() { @Override public void initChannel(Channel ch) { // 构建基于 Netty 的 ServerTransport NettyServerTransport transport = new NettyServerTransport(/*...*/); ServerTransportListener transportListener; synchronized (NettyServer.this) { // 调用监听器回调，Transport 创建事件 transportListener = listener.transportCreated(transport); } // 启动监听器 transport.start(transportListener); ChannelFutureListener loopReleaser = new LoopReleaser(); channelDone."><meta name=author content="HelloWood"><link rel=canonical href=https://blog.hellowood.dev/posts/grpc-server-%E7%AB%AF%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B/><meta name=google-site-verification content="G-3MSGPYTHPZ"><link rel=alternate type=application/rss+xml href=https://blog.hellowood.dev/index.xml title=HelloWood><script async src="https://www.googletagmanager.com/gtag/js?id=G-3MSGPYTHPZ"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-3MSGPYTHPZ",{anonymize_ip:!1})}</script><script async defer data-website-id=7a9034de-0ce7-4756-942a-829e6cd22301 src=https://statistics.lab.hellowood.dev/umami.js></script><meta property="og:title" content="gRPC Server 端请求处理流程"><meta property="og:description" content="gRPC Server 端请求处理流程 [TOC]
初始化 创建并启动 ServerTransport 在 Server 启动的时候，最终调用 NettyServer 的 start() 方法，为 ServerBootstrap 添加了 ChannelInitializer，最终，当有新的连接建立时，会由 NettyServerHandler 调用该类的 initChannel 方法，初始化一个 NettyServerTransport
io.grpc.netty.NettyServer#start 在初始化 Netty Channel 时，会先创建 NettyServerTransport，然后调用监听器的 Transport 创建事件，添加一个超时取消任务； 然后会调用 Transport 的 start 方法启动 Transport
b.childHandler(new ChannelInitializer<Channel>() { @Override public void initChannel(Channel ch) { // 构建基于 Netty 的 ServerTransport NettyServerTransport transport = new NettyServerTransport(/*...*/); ServerTransportListener transportListener; synchronized (NettyServer.this) { // 调用监听器回调，Transport 创建事件 transportListener = listener.transportCreated(transport); } // 启动监听器 transport.start(transportListener); ChannelFutureListener loopReleaser = new LoopReleaser(); channelDone."><meta property="og:type" content="article"><meta property="og:url" content="https://blog.hellowood.dev/posts/grpc-server-%E7%AB%AF%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-12-15T22:34:46+00:00"><meta property="article:modified_time" content="2020-12-15T22:34:46+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="gRPC Server 端请求处理流程"><meta name=twitter:description content="gRPC Server 端请求处理流程 [TOC]
初始化 创建并启动 ServerTransport 在 Server 启动的时候，最终调用 NettyServer 的 start() 方法，为 ServerBootstrap 添加了 ChannelInitializer，最终，当有新的连接建立时，会由 NettyServerHandler 调用该类的 initChannel 方法，初始化一个 NettyServerTransport
io.grpc.netty.NettyServer#start 在初始化 Netty Channel 时，会先创建 NettyServerTransport，然后调用监听器的 Transport 创建事件，添加一个超时取消任务； 然后会调用 Transport 的 start 方法启动 Transport
b.childHandler(new ChannelInitializer<Channel>() { @Override public void initChannel(Channel ch) { // 构建基于 Netty 的 ServerTransport NettyServerTransport transport = new NettyServerTransport(/*...*/); ServerTransportListener transportListener; synchronized (NettyServer.this) { // 调用监听器回调，Transport 创建事件 transportListener = listener.transportCreated(transport); } // 启动监听器 transport.start(transportListener); ChannelFutureListener loopReleaser = new LoopReleaser(); channelDone."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://blog.hellowood.dev/posts/"},{"@type":"ListItem","position":3,"name":"gRPC Server 端请求处理流程","item":"https://blog.hellowood.dev/posts/grpc-server-%E7%AB%AF%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"gRPC Server 端请求处理流程","name":"gRPC Server 端请求处理流程","description":"gRPC Server 端请求处理流程 [TOC]\n初始化 创建并启动 ServerTransport 在 Server 启动的时候，最终调用 NettyServer 的 start() 方法，为 ServerBootstrap 添加了 ChannelInitializer，最终，当有新的连接建立时，会由 NettyServerHandler 调用该类的 initChannel 方法，初始化一个 NettyServerTransport\nio.grpc.netty.NettyServer#start 在初始化 Netty Channel 时，会先创建 NettyServerTransport，然后调用监听器的 Transport 创建事件，添加一个超时取消任务； 然后会调用 Transport 的 start 方法启动 Transport\nb.childHandler(new ChannelInitializer\u0026lt;Channel\u0026gt;() { @Override public void initChannel(Channel ch) { // 构建基于 Netty 的 ServerTransport NettyServerTransport transport = new NettyServerTransport(/*...*/); ServerTransportListener transportListener; synchronized (NettyServer.this) { // 调用监听器回调，Transport 创建事件 transportListener = listener.transportCreated(transport); } // 启动监听器 transport.start(transportListener); ChannelFutureListener loopReleaser = new LoopReleaser(); channelDone.","keywords":["gRPC"],"articleBody":"gRPC Server 端请求处理流程 [TOC]\n初始化 创建并启动 ServerTransport 在 Server 启动的时候，最终调用 NettyServer 的 start() 方法，为 ServerBootstrap 添加了 ChannelInitializer，最终，当有新的连接建立时，会由 NettyServerHandler 调用该类的 initChannel 方法，初始化一个 NettyServerTransport\nio.grpc.netty.NettyServer#start 在初始化 Netty Channel 时，会先创建 NettyServerTransport，然后调用监听器的 Transport 创建事件，添加一个超时取消任务； 然后会调用 Transport 的 start 方法启动 Transport\nb.childHandler(new ChannelInitializer\u003cChannel\u003e() { @Override public void initChannel(Channel ch) { // 构建基于 Netty 的 ServerTransport NettyServerTransport transport = new NettyServerTransport(/*...*/); ServerTransportListener transportListener; synchronized (NettyServer.this) { // 调用监听器回调，Transport 创建事件 transportListener = listener.transportCreated(transport); } // 启动监听器 transport.start(transportListener); ChannelFutureListener loopReleaser = new LoopReleaser(); channelDone.addListener(loopReleaser); ch.closeFuture().addListener(loopReleaser); } }); io.grpc.netty.NettyServerTransport#start 在启动 Transport 时，会为当前的 Transport 创建一个处理器，并绑定到 Netty 的 Channel 中\npublic void start(ServerTransportListener listener) { this.listener = listener; // 为 pipeline 创建 Netty Handler grpcHandler = createHandler(listener, channelUnused); // 创建 Handler ChannelHandler negotiationHandler = protocolNegotiator.newHandler(grpcHandler); ChannelHandler bufferingHandler = new WriteBufferingAndExceptionHandler(negotiationHandler); // 添加监听器 ChannelFutureListener terminationNotifier = new TerminationNotifier(); channelUnused.addListener(terminationNotifier); channel.closeFuture().addListener(terminationNotifier); channel.pipeline().addLast(bufferingHandler); } 处理请求 当 Server 与 Client 的连接建立成功之后，可以开始处理请求\n请求整体处理流程 读取 Settings 帧，触发 Transport ready 事件 读取 Header 帧，触发 FrameListener#onHeadersRead 事件 3. 由 NettyServerHandler 处理 4. 根据 Header 里面的信息，获取相应的方法 4. 将 HTTP 流转换为 NettyServerStream 5. 触发 Transport#streamCreated 事件 6. 检查编解码、解压缩等信息，创建可取消的上下文 11. 初始化流监听器 6. 提交 StreamCreated 任务 7. 触发 NettyServerStream.TransportState#onStreamAllocated 事件 8. 提交 OnReady 任务 执行 StreamCreated 任务 10. 根据方法名查找方法定义 11. 调用 startCall 开始处理 12. 遍历拦截器，使用拦截器包装方法处理器 13. 调用 startWrappedCall 处理 14. 创建 ServerCallImpl 实例 15. 通过方法定义的请求处理器 startCall 方法处理 16. 创建响应观察器 ServerCallStreamObserverImpl 实例 17. 调用 call.request() 获取指定数量的消息 18. 提交 RequestRunnable 任务获取指定数量的消息 18. 创建调用监听器 UnaryServerCallListener 19. 创建 ServerStreamListenerImpl 流监听器实例 执行 OnReady 任务 21. 调用 UnaryServerCallListener#onReady 处理 Ready 事件 22. 修改 ready 状态 23. 如果有 onReadyHandler 任务，则执行 执行 RequestRunnable 任务 25. 要求指定数量的消息 25. 修改等待投递的消息数量 26. 调用 deliver 方法投递 27. 如果有待投递的消息，根据类型进行投递 28. 当消息类型是消息体时，处理消息体 29. 读取消息体的流 30. 调用 MessageFramer.Listener#messagesAvailable 事件，通知新的消息 31. 提交 MessagesAvailable 任务 调用 MessageDeframer#close 方法关闭帧 33. 调用流监听器半关闭事件 34. 提交 HalfClosed 任务 执行 MessagesAvailable 任务 32. 从 MessageProducer 中获取消息，解析为请求对象 33. 调用 SeverCall.Listener#onMessage 方法处理消息 34. 将 request 对象赋值给相应的对象，该对象会在 halfClose 时处理 执行 HalfClosed 任务 36. 调用 invoke 方法，处理业务逻辑 37. 根据方法 ID，使用相应的实现调用业务逻辑 38. 调用 StreamObserver#onNext 发送响应 39. 发送响应 Header 40. 设置编码和压缩的请求头 41. 写入 Header 40. 发送响应 body 41. 将响应对象序列化为流 42. 写入响应 43. 清空缓存 44. 调用 StreamObserver#onComplete 完成请求 45. 使用 OK 状态关闭调用 46. 修改关闭状态 47. 调用流关闭事件 48. 关闭帧 49. 将响应状态加入响应元数据中 50. 修改 TransportState 的状态 51. 写入响应元数据，发送给客户端 37. 冻结响应 38. 如果 ready 状态，再次执行 onReady 事件 39. 当流关闭时，调用 TransportState#complete 事件 40. 关闭监听器 41. 提交 Closed 任务 42. 执行 Closed 任务 43. 调用 stream#complete 事件 44. 取消上下文 1. 读取 Settings 帧 io.grpc.netty.NettyServerHandler.FrameListener#onSettingsRead 当读取到 Settings 帧时，会调用 onSettingsRead 方法，同时会同时 Transport 监听器 ready 事件\npublic void onSettingsRead(ChannelHandlerContext ctx, Http2Settings settings) { if (firstSettings) { firstSettings = false; // 通知 Transport ready attributes = transportListener.transportReady(negotiationAttributes); } } io.grpc.internal.ServerImpl.ServerTransportListenerImpl#transportReady 会通知 Transport Ready 事件，会遍历 ServerTransportFilter 通知，默认没有 ServerTransportFilter 的实现\npublic Attributes transportReady(Attributes attributes) { // 如果有握手超时回调，则取消 handshakeTimeoutFuture.cancel(false); handshakeTimeoutFuture = null; // 遍历 TransportFilter，通知 ready 事件并获取 attributes for (ServerTransportFilter filter : transportFilters) { attributes = Preconditions.checkNotNull(filter.transportReady(attributes), \"Filter %s returned null\", filter); } this.attributes = attributes; return attributes; } 2. 接收 header 当 Server 接收到 Client 发送的 header 后，经过 Netty 处理，最终调用 onHeadersRead 开始处理流\nio.grpc.netty.shaded.io.grpc.netty.NettyServerHandler.FrameListener#onHeadersRead 接收 header 帧\npublic void onHeadersRead(ChannelHandlerContext ctx, int streamId, Http2Headers headers, int streamDependency, short weight, boolean exclusive, int padding, boolean endStream) throws Http2Exception { if (NettyServerHandler.this.keepAliveManager != null) { NettyServerHandler.this.keepAliveManager.onDataReceived(); } NettyServerHandler.this.onHeadersRead(ctx, streamId, headers); } io.grpc.netty.NettyServerHandler.FrameListener#onHeadersRead 开始处理 header\npublic void onHeadersRead(ChannelHandlerContext ctx, int streamId, Http2Headers headers, int streamDependency, short weight, boolean exclusive, int padding, boolean endStream) throws Http2Exception { if (keepAliveManager != null) { keepAliveManager.onDataReceived(); } // 最终会创建流并出发流创建事件 NettyServerHandler.this.onHeadersRead(ctx, streamId, headers); } io.grpc.netty.NettyServerHandler#onHeadersRead 会根据请求的 Header 信息，查找服务和方法，校验请求类型，请求方法，传输编码等内容；然后根据 HTTP2 流 Id，获取对应的流，将其转换为 NettyServerStream；调用 Transport 的 onStreamCreated 事件 向线程池中提交 StreamCreated，然后调用 onStreamAllocated 方法通知流 StreamListener的onReady事件提交OnReady任务\nprivate void onHeadersRead(ChannelHandlerContext ctx, int streamId, Http2Headers headers) throws Http2Exception { try { // 删除斜杠获取方法限定名称 CharSequence path = headers.path(); // 方法限定名，即包含服务名和方法名 String method = path.subSequence(1, path.length()).toString(); // 获取 HTTP 流 Http2Stream http2Stream = requireHttp2Stream(streamId); // 将 header 转为 metadata Metadata metadata = Utils.convertHeaders(headers); // 创建支持统计的上下文 StatsTraceContext statsTraceCtx = StatsTraceContext.newServerContext(streamTracerFactories, method, metadata); // 创建流的声明 NettyServerStream.TransportState state = new NettyServerStream.TransportState( this, ctx.channel().eventLoop(), http2Stream, maxMessageSize, statsTraceCtx, transportTracer, method); try { // 获取请求的 authority String authority = getOrUpdateAuthority((AsciiString) headers.authority()); // 创建 Server 端的流 NettyServerStream stream = new NettyServerStream(ctx.channel(), state, attributes, authority, statsTraceCtx, transportTracer); // 触发监听器，通知流创建事件，查找相应处理器，开始处理流，会提交 StreamCreated 任务到线程池中 transportListener.streamCreated(stream, method, metadata); // 会提交 OnReady 任务到线程池中，通知 Stream Ready state.onStreamAllocated(); http2Stream.setProperty(streamKey, state); } } catch (Exception e) { logger.log(Level.WARNING, \"Exception in onHeadersRead()\", e); throw newStreamException(streamId, e); } } 3. 流创建事件 transportListener.streamCreated(stream, method, metadata); io.grpc.internal.ServerImpl.ServerTransportListenerImpl#streamCreated 检查并初始化流的编解码，解压缩等信息；创建可需取消的上下文，选择要执行的线程池，初始化流监听器，最终提交流创建任务\nprivate void streamCreatedInternal(final ServerStream stream, final String methodName, final Metadata headers, final Tag tag) { final Executor wrappedExecutor; if (executor == directExecutor()) { wrappedExecutor = new SerializeReentrantCallsDirectExecutor(); stream.optimizeForDirectExecutor(); } else { // 否则使用指定的 Executor 执行 wrappedExecutor = new SerializingExecutor(executor); } // 创建可以取消的上下文 final Context.CancellableContext context = createContext(headers, statsTraceCtx); // 流事件监听器，处理流的所有生命周期事件 final JumpToApplicationThreadServerStreamListener jumpListener = new JumpToApplicationThreadServerStreamListener(wrappedExecutor, executor, stream, context, tag); stream.setListener(jumpListener); // 提交流创建任务 wrappedExecutor.execute(new StreamCreated()); } 接下来会执行流 ready 的任务\n4. 流 ready 事件 state.onStreamAllocated(); io.grpc.internal.AbstractStream.TransportState#onStreamAllocated 流分配，会调用流 ready 事件\nprotected void onStreamAllocated() { checkState(listener() != null); synchronized (onReadyLock) { checkState(!allocated, \"Already allocated\"); allocated = true; } notifyIfReady(); } io.grpc.internal.ServerImpl.JumpToApplicationThreadServerStreamListener#onReady 最终会调用 onReady 提交流的 OnReady 任务\npublic void onReady() { try { callExecutor.execute(new OnReady()); } } 5. 执行流创建任务 执行 StreamCreated任务\nio.grpc.internal.ServerImpl.ServerTransportListenerImpl#streamCreated 执行 StreamCreated任务时，会先根据方法名称从注册器中查找对应的方法处理器，然后调用 startCall 方法进行处理\n// 流创建任务处理 final class StreamCreated extends ContextRunnable { private void runInternal() { ServerStreamListener listener = NOOP_LISTENER; try { // 根据方法名称获取方法定义 ServerMethodDefinition\u003c?, ?\u003e method = registry.lookupMethod(methodName); // 如果没有则从回退的方法注册器中查找 if (method == null) { method = fallbackRegistry.lookupMethod(methodName, stream.getAuthority()); } // 如果没有则方法不存在，返回 UNIMPLEMENTED，关闭流，取消上下文 if (method == null) { Status status = Status.UNIMPLEMENTED.withDescription(\"Method not found: \" + methodName); stream.close(status, new Metadata()); context.cancel(null); return; } // 如果方法存在，则开始调用 listener = startCall(stream, methodName, method, headers, context, statsTraceCtx, tag); } catch (Throwable t) { stream.close(Status.fromThrowable(t), new Metadata()); context.cancel(null); throw t; } finally { jumpListener.setListener(listener); } final class ServerStreamCancellationListener implements Context.CancellationListener { @Override public void cancelled(Context context) { Status status = statusFromCancelled(context); if (DEADLINE_EXCEEDED.getCode().equals(status.getCode())) { stream.cancel(status); } } } context.addListener(new ServerStreamCancellationListener(), directExecutor()); } } io.grpc.internal.ServerImpl.ServerTransportListenerImpl#startCall 会获取方法的处理器，然后遍历拦截器，封装处理器，调用 startWrappedCall 处理\nprivate \u003cReqT, RespT\u003e ServerStreamListener startCall(ServerStream stream, String fullMethodName, ServerMethodDefinition\u003cReqT, RespT\u003e methodDef, Metadata headers, Context.CancellableContext context, StatsTraceContext statsTraceCtx, Tag tag) { // 从方法描述获取调用处理器 ServerCallHandler\u003cReqT, RespT\u003e handler = methodDef.getServerCallHandler(); // 遍历拦截器，为处理器添加拦截器 for (ServerInterceptor interceptor : interceptors) { handler = InternalServerInterceptors.interceptCallHandler(interceptor, handler); } // 使用添加了拦截器后的处理器创建新的方法定义 ServerMethodDefinition\u003cReqT, RespT\u003e interceptedDef = methodDef.withServerCallHandler(handler); // 处理封装后的调用 return startWrappedCall(fullMethodName, wMethodDef, stream, headers, context, tag); } io.grpc.internal.ServerImpl.ServerTransportListenerImpl#startWrappedCall 创建请求处理器实例，然后调用方法处理器，开始处理请求，同时创建流监听器\nprivate \u003cWReqT, WRespT\u003e ServerStreamListener startWrappedCall(String fullMethodName, ServerMethodDefinition\u003cWReqT, WRespT\u003e methodDef, ServerStream stream, Metadata headers, Context.CancellableContext context, Tag tag) { // 创建请求处理器 ServerCallImpl\u003cWReqT, WRespT\u003e call = new ServerCallImpl\u003c\u003e(stream, methodDef.getMethodDescriptor(), headers, context, decompressorRegistry, compressorRegistry, serverCallTracer, tag); // 调用方法处理器，真正调用实现逻辑的方法 ServerCall.Listener\u003cWReqT\u003e listener = methodDef.getServerCallHandler().startCall(call, headers); if (listener == null) { throw new NullPointerException(\"startCall() returned a null listener for method \" + fullMethodName); } // 根据调用监听器创建新的流监听器 return call.newServerStreamListener(listener); } io.grpc.stub.ServerCalls.UnaryServerCallHandler#startCall 会创建响应观察器，要求指定数量的消息，并创建监听器\npublic ServerCall.Listener\u003cReqT\u003e startCall(ServerCall\u003cReqT, RespT\u003e call, Metadata headers) { // 创建响应处理器 ServerCallStreamObserverImpl\u003cReqT, RespT\u003e responseObserver = new ServerCallStreamObserverImpl\u003c\u003e(call); // 会调用 io.grpc.internal.AbstractStream#request 方法获取消息 call.request(2); // 返回监听器 return new UnaryServerCallListener(responseObserver, call); } 6. 提交要求指定数量的消息任务 在执行 StreamCreated 任务时，会调用 startCall 方法，提交 RequestRunnable任务，要求指定数量的消息\nio.grpc.internal.AbstractStream#request 在执行 StreamCreated 任务时指定接收的帧的数量\npublic final void request(int numMessages) { transportState().requestMessagesFromDeframer(numMessages); } io.grpc.internal.AbstractStream.TransportState#requestMessagesFromDeframer 提交获取指定数量的帧的任务\nprivate void requestMessagesFromDeframer(final int numMessages) { // 如果不是线程安全的解帧器，则由 Transport 的线程执行 class RequestRunnable implements Runnable { @Override public void run() { try { deframer.request(numMessages); } catch (Throwable t) { deframeFailed(t); } } } runOnTransportThread(new RequestRunnable()); } 7. 执行流 ready 任务 执行 OnReady 任务\nio.grpc.internal.ServerImpl.JumpToApplicationThreadServerStreamListener#onReady 执行 onReady 时提交的 OnReady 任务\nfinal class OnReady extends ContextRunnable { OnReady() { super(context); } @Override public void runInContext() { try { // 调用监听器的 ready 事件 getListener().onReady(); } catch (Throwable t) { internalClose(t); throw t; } } } io.grpc.stub.ServerCalls.UnaryServerCallHandler.UnaryServerCallListener#onReady 处理流 ready 事件，如果有 onReadyHandler 则会执行\npublic void onReady() { // 将 ready 状态变为 true wasReady = true; // 如果响应有 readyHandler，则执行 if (responseObserver.onReadyHandler != null) { responseObserver.onReadyHandler.run(); } } 8. 执行读取指定数量的消息任务并提交有可用消息任务 执行 RequestRunnable任务\nRequestRunnable class RequestRunnable implements Runnable { @Override public void run() { try { deframer.request(numMessages); } catch (Throwable t) { deframeFailed(t); } } } io.grpc.internal.MessageDeframer#request 读取指定数量的帧\npublic void request(int numMessages) { if (isClosed()) { return; } pendingDeliveries += numMessages; deliver(); } io.grpc.internal.MessageDeframer#deliver 读取消息并投递给监听器\nprivate void deliver() { // 检查投递的状态 if (inDelivery) { return; } inDelivery = true; try { // 如果没有停止投递，且有等待投递的消息，且读取成功，则根据相应状态进行处理 while (!stopDelivery \u0026\u0026 pendingDeliveries \u003e 0 \u0026\u0026 readRequiredBytes()) { switch (state) { case HEADER: // 处理 header processHeader(); break; case BODY: // 处理body processBody(); pendingDeliveries--; break; default: throw new AssertionError(\"Invalid state: \" + state); } } // 如果已经停止投递，则关闭 if (stopDelivery) { close(); return; } if (closeWhenComplete \u0026\u0026 isStalled()) { close(); } } finally { inDelivery = false; } } io.grpc.internal.MessageDeframer#processBody 读取请求体并通知监听器有新的消息\nprivate void processBody() { // 读取请求体的流 InputStream stream = compressedFlag ? getCompressedBody() : getUncompressedBody(); nextFrame = null; // 通知监听器有新的消息 listener.messagesAvailable(new SingleMessageProducer(stream)); // 将状态改为处理 header state = State.HEADER; requiredLength = HEADER_LENGTH; } io.grpc.internal.ServerImpl.JumpToApplicationThreadServerStreamListener#messagesAvailable 通知有新的消息可用，会提交 MessageAvailable 任务\npublic void messagesAvailable(final MessageProducer producer) { try { // 执行任务 callExecutor.execute(new MessagesAvailable()); } } 9. 执行有新的可用消息任务 io.grpc.internal.ServerImpl.JumpToApplicationThreadServerStreamListener#messagesAvailable 通知有新的消息可用，会提交 MessageAvailable 任务\nfinal class MessagesAvailable extends ContextRunnable { MessagesAvailable() { super(context); } @Override public void runInContext() { try { // 获取监听器，通知有新的消息 getListener().messagesAvailable(producer); } catch (Throwable t) { internalClose(t); throw t; } } } io.grpc.internal.ServerCallImpl.ServerStreamListenerImpl#messagesAvailableInternal 执行时，会先将流解析为请求对象，然后调用监听器的 onMessage方法，处理消息\nprivate void messagesAvailableInternal(final MessageProducer producer) { // 如果调用已经取消了，则关闭生产者 if (call.cancelled) { GrpcUtil.closeQuietly(producer); return; } InputStream message; try { // 从生产者中获取消息， while ((message = producer.next()) != null) { try { // 将流解析为请求对象，发送给监听器 listener.onMessage(call.method.parseRequest(message)); } catch (Throwable t) { GrpcUtil.closeQuietly(message); throw t; } message.close(); } } catch (Throwable t) { GrpcUtil.closeQuietly(producer); Throwables.throwIfUnchecked(t); throw new RuntimeException(t); } } io.grpc.stub.ServerCalls.UnaryServerCallHandler.UnaryServerCallListener#onMessage 由监听器接收消息，并赋值给相应的对象，在 halfClose 事件时处理该请求\npublic void onMessage(ReqT request) { // 如果已经接收到了一个请求，则返回错误 if (this.request != null) { call.close(Status.INTERNAL.withDescription(TOO_MANY_REQUESTS), new Metadata()); canInvoke = false; return; } // 延迟执行调用 method.invoke() 直到 onHalfClose() 以确保客户端执行了半关闭 this.request = request; } 10. 提交半关闭请求任务 当执行完 RequestRunnable 任务完成时，会调用 MessageDeframer#close 方法关闭帧\nio.grpc.internal.MessageDeframer#close public void close() { if (isClosed()) { return; } boolean hasPartialMessage = nextFrame != null \u0026\u0026 nextFrame.readableBytes() \u003e 0; try { if (fullStreamDecompressor != null) { hasPartialMessage = hasPartialMessage || fullStreamDecompressor.hasPartialData(); fullStreamDecompressor.close(); } if (unprocessed != null) { unprocessed.close(); } if (nextFrame != null) { nextFrame.close(); } } finally { fullStreamDecompressor = null; unprocessed = null; nextFrame = null; } listener.deframerClosed(hasPartialMessage); } io.grpc.internal.AbstractServerStream.TransportState#deframerClosed 会执行关闭帧，然后调用 Stream 的监听器，通知半关闭\npublic void deframerClosed(boolean hasPartialMessage) { deframerClosed = true; // 是否到达流结尾 if (endOfStream) { // 如果不需要立即关闭，且有未完成的消息，返回错误并抛出异常 if (!immediateCloseRequested \u0026\u0026 hasPartialMessage) { deframeFailed(Status.INTERNAL.withDescription(\"Encountered end-of-stream mid-frame\") .asRuntimeException()); deframerClosedTask = null; return; } // 通知半关闭 listener.halfClosed(); } // 如果有解帧器关闭的任务，则执行 if (deframerClosedTask != null) { deframerClosedTask.run(); deframerClosedTask = null; } } io.grpc.internal.ServerImpl.JumpToApplicationThreadServerStreamListener#halfClosed 提交半关闭任务\npublic void halfClosed() { try { callExecutor.execute(new HalfClosed()); } } 11. 执行半关闭任务 io.grpc.internal.ServerImpl.JumpToApplicationThreadServerStreamListener#halfClosed 执行半关闭任务\nfinal class HalfClosed extends ContextRunnable { HalfClosed() { super(context); } @Override public void runInContext() { try { // 调用监听器的半关闭事件 getListener().halfClosed(); } catch (Throwable t) { internalClose(t); throw t; } } } io.grpc.stub.ServerCalls.UnaryServerCallHandler.UnaryServerCallListener#onHalfClose 最终在监听器中调用相应的方法处理器，处理请求，并冻结响应；还会再次调用 onReady 事件，如果有 onReadyHandler 会执行\npublic void onHalfClose() { // 如果不能调用则直接返回 if (!canInvoke) { return; } // 如果请求是 null，则返回错我 if (request == null) { call.close(Status.INTERNAL.withDescription(MISSING_REQUEST), new Metadata()); return; } // 执行方法调用 method.invoke(request, responseObserver); // 处理了请求之后将请求置为 null request = null; // 冻结响应 responseObserver.freeze(); // 判断是否 ready if (wasReady) { // 因为在 halfClose 中调用，错过了来自 Transport 的 onReady 事件，从这里恢复 // 即在 ready 之后用于执行 onReadyHandler onReady(); } } io.github.helloworlde.HelloServiceGrpc.MethodHandlers#invoke(Req, io.grpc.stub.StreamObserver) 处理请求，这部分是生成的代码，会调用相应的实例，处理请求，并将响应内容通过 StreamObserver 发送出去\npublic void invoke(Req request, io.grpc.stub.StreamObserver\u003cResp\u003e responseObserver) { switch (methodId) { case METHODID_HOW_ARE_YOU: serviceImpl.howAreYou((io.github.helloworlde.HelloMessage) request, (io.grpc.stub.StreamObserver\u003cio.github.helloworlde.HelloResponse\u003e) responseObserver); break; default: throw new AssertionError(); } } 处理响应 1. 执行业务逻辑处理 io.github.helloworlde.service.HelloServiceImpl#howAreYou 需要实现生成的接口，在方法中实现逻辑，并将响应通过 StreamObserver 发送出去\npublic void howAreYou(HelloMessage request, StreamObserver\u003cHelloResponse\u003e responseObserver) { responseObserver.onNext(HelloResponse.newBuilder().setResult(\"Hello : \" + request.getMessage()).build()); responseObserver.onCompleted(); } 2. 发送响应内容 io.grpc.stub.ServerCalls.ServerCallStreamObserverImpl#onNext 发送单个响应时，会先检查请求是否取消了，如果已经取消了，则会抛出错误；接着检查请求的状态，如果是已经丢弃或者完成，也会抛出异常\n然后会检查是否发送了 header，如果没有发送，则会先发送 header；发送 header 完成后会发送消息\npublic void onNext(RespT response) { // 如果已经被取消调用了，则判断是否有取消回调，如果没有则返回取消状态 if (cancelled) { if (onCancelHandler == null) { throw Status.CANCELLED.withDescription(\"call already cancelled\").asRuntimeException(); } return; } // 检查是否已经丢弃或者完成 checkState(!aborted, \"Stream was terminated by error, no further calls are allowed\"); checkState(!completed, \"Stream is already completed, no further calls are allowed\"); // 如果还没有发送 header，则发送 header if (!sentHeaders) { call.sendHeaders(new Metadata()); // 将发送 header 设置为 true sentHeaders = true; } // 然后发送响应 call.sendMessage(response); } 1. 发送响应 header io.grpc.internal.ServerCallImpl#sendHeadersInternal 设置 header 内容，发送 header\nprivate void sendHeadersInternal(Metadata headers) { // 丢弃编码的 key headers.discardAll(MESSAGE_ENCODING_KEY); // 设置压缩器类型 headers.put(MESSAGE_ENCODING_KEY, compressor.getMessageEncoding()); // 为流设置压缩器 stream.setCompressor(compressor); // 丢弃消息编码的 key headers.discardAll(MESSAGE_ACCEPT_ENCODING_KEY); if (advertisedEncodings.length != 0) { headers.put(MESSAGE_ACCEPT_ENCODING_KEY, advertisedEncodings); } // 将调用 header 状态改为 true sendHeadersCalled = true; stream.writeHeaders(headers); } io.grpc.internal.AbstractServerStream#writeHeaders 将 header 内容写入帧中，会调用 Netty 相关的方法发送内容\npublic final void writeHeaders(Metadata headers) { Preconditions.checkNotNull(headers, \"headers\"); headersSent = true; abstractServerStreamSink().writeHeaders(headers); } 2. 发送响应内容 io.grpc.internal.ServerCallImpl#sendMessageInternal 发送响应内容，会先检查是否已经发送了 header，且请求没有关闭，且响应的状态正确 如果都没有问题，则将响应内容序列化为流，然后发送并清空缓冲区\nprivate void sendMessageInternal(RespT message) { // 检查是否已经发送了 header，和调用是否已经被关闭 checkState(sendHeadersCalled, \"sendHeaders has not been called\"); checkState(!closeCalled, \"call is closed\"); // 如果是 UNARY 或者 CLIENT_STREAMING 类型的消息，且已经发送过消息了，则不允许再发送，返回错误状态 if (method.getType().serverSendsOneMessage() \u0026\u0026 messageSent) { internalClose(Status.INTERNAL.withDescription(TOO_MANY_RESPONSES)); return; } // 将发送消息状态改为 true messageSent = true; try { // 将消息序列化为流，写入消息，清空流 InputStream resp = method.streamResponse(message); stream.writeMessage(resp); stream.flush(); } catch (RuntimeException e) { close(Status.fromThrowable(e), new Metadata()); } catch (Error e) { close(Status.CANCELLED.withDescription(\"Server sendMessage() failed with Error\"), new Metadata()); throw e; } } io.grpc.internal.AbstractStream#writeMessage 检查帧的状态，如果帧没有关闭，则将流的内容写入帧中，并关闭流 最终消息内容通过 Netty 的相关方法发送给客户端\npublic final void writeMessage(InputStream message) { checkNotNull(message, \"message\"); try { if (!framer().isClosed()) { // 写入消息体 framer().writePayload(message); } } finally { GrpcUtil.closeQuietly(message); } } io.grpc.internal.AbstractStream#flush 清空帧的缓冲，将所有内容都发送给客户端\npublic final void flush() { // 如果帧还没有关闭，则清空帧 if (!framer().isClosed()) { framer().flush(); } } 3. 完成请求 当调用 responseObserver.onCompleted 后，会开始处理请求完成的逻辑\nio.grpc.stub.ServerCalls.ServerCallStreamObserverImpl#onCompleted 会先检查请求的状态，如果已经被取消了，且没有取消处理任务，则直接抛出取消状态的异常 如果请求正常完成，会使用 OK 状态关闭情趣，修改请求状态为完成\npublic void onCompleted() { // 如果已经被取消，则返回取消的状态 if (cancelled) { if (onCancelHandler == null) { throw Status.CANCELLED.withDescription(\"call already cancelled\").asRuntimeException(); } } else { // 通知请求完成 call.close(Status.OK, new Metadata()); // 将完成状态改为 true completed = true; } } io.grpc.internal.ServerCallImpl#closeInternal 使用指定的状态和响应元数据关闭请求 如果没有发送响应，则会取消请求，并返回 INTERNAL 状态的错误；如果请求正常完成，则调用流关闭的接口，完成请求\nprivate void closeInternal(Status status, Metadata trailers) { // 检查是否已经关闭 checkState(!closeCalled, \"call already closed\"); try { // 将关闭状态改为 true closeCalled = true; // 检查状态如果是 OK，且方法类型是 Server 端只能发送一次，且没有发送消息，则返回错误 if (status.isOk() \u0026\u0026 method.getType().serverSendsOneMessage() \u0026\u0026 !messageSent) { internalClose(Status.INTERNAL.withDescription(MISSING_RESPONSE)); return; } // 关闭流 stream.close(status, trailers); } finally { // 统计结果 serverCallTracer.reportCallEnded(status.isOk()); } } io.grpc.internal.AbstractServerStream#close 关闭流，将响应的 header 写入到帧中；最终通过 Netty 的方法将响应发送给客户端\npublic final void close(Status status, Metadata trailers) { // 如果出站的流还未关闭，则将状态改为关闭 if (!outboundClosed) { outboundClosed = true; // 从服务端关闭 framer endOfMessages(); // 将响应状态加入到 header 中 addStatusToTrailers(trailers, status); // 安全设置，无需同步，因为访问被严格控制，只有这里设置关闭状态，保证在这里之后读取 // 给 Transport 设置响应状态 transportState().setClosedStatus(status); // 将响应的 header 信息写入帧中 abstractServerStreamSink().writeTrailers(trailers, headersSent, status); } } io.grpc.internal.AbstractStream#endOfMessages 关闭帧\nprotected final void endOfMessages() { framer().close(); } 1. 发送响应结尾 header 在关闭流时，会将相应的状态和其他 header 发送给客户端\nio.grpc.internal.AbstractServerStream#close abstractServerStreamSink().writeTrailers(trailers, headersSent, status); io.grpc.netty.NettyServerStream.Sink#writeTrailers public void writeTrailers(Metadata trailers, boolean headersSent, Status status) { try { Http2Headers http2Trailers = Utils.convertTrailers(trailers, headersSent); // 将发送 header 的指令写入到队列中 writeQueue.enqueue(SendResponseHeadersCommand.createTrailers(transportState(), http2Trailers, status), true); } } 2. 提交关闭任务 当发送完响应 Header 和 body 时，会因为已经到达帧末尾，调用closeStreamWhenDone 方法进行关闭\nio.grpc.netty.shaded.io.grpc.netty.NettyServerHandler#closeStreamWhenDone private void closeStreamWhenDone(ChannelPromise promise, int streamId) throws Http2Exception { final TransportState stream = this.serverStream(this.requireHttp2Stream(streamId)); promise.addListener(new ChannelFutureListener() { public void operationComplete(ChannelFuture future) { stream.complete(); } }); } io.grpc.internal.AbstractServerStream.TransportState#complete 然后调用流的完成事件，关闭监听器\npublic void complete() { // 如果解帧器已经关闭了，则关闭监听器 if (deframerClosed) { deframerClosedTask = null; closeListener(Status.OK); } else { // 如果还未关闭，则创建关闭监听器任务，并立即关闭解帧器 deframerClosedTask = new Runnable() { @Override public void run() { closeListener(Status.OK); } }; immediateCloseRequested = true; closeDeframer(true); } } io.grpc.internal.ServerImpl.JumpToApplicationThreadServerStreamListener#closedInternal 提交流关闭任务Closed private void closedInternal(final Status status) { // 如果状态不是 OK，则直接提交关闭 Context 任务 if (!status.isOk()) { cancelExecutor.execute(new ContextCloser(context, status.getCause())); } final class Closed extends ContextRunnable { Closed() { super(context); } @Override public void runInContext() { PerfMark.startTask(\"ServerCallListener(app).closed\", tag); PerfMark.linkIn(link); try { // 调用监听器的关闭事件 getListener().closed(status); } finally { PerfMark.stopTask(\"ServerCallListener(app).closed\", tag); } } } callExecutor.execute(new Closed()); } 3. 执行关闭任务 执行 Closed 任务\nio.grpc.internal.ServerImpl.JumpToApplicationThreadServerStreamListener#closed$Closed\nfinal class Closed extends ContextRunnable { @Override public void runInContext() { try { // 调用监听器的关闭事件 getListener().closed(status); } } } io.grpc.internal.ServerCallImpl.ServerStreamListenerImpl#closedInternal 根据状态通知流监听器完成或者取消，最终取消上下文\nprivate void closedInternal(Status status) { try { // 如果状态是 OK，通知监听器完成 if (status.isOk()) { listener.onComplete(); } else { // 否则将状态改为取消，通知监听器取消 call.cancelled = true; listener.onCancel(); } } finally { // 取消上下文 context.cancel(null); } } io.grpc.Context.CancellableContext#cancel 取消上下文，取消所有的超时时间任务 public boolean cancel(Throwable cause) { boolean triggeredCancel = false; synchronized (this) { // 如果没有取消，则取消，并修改状态 if (!cancelled) { cancelled = true; // 如果有等待取消的任务，则取消 if (pendingDeadline != null) { pendingDeadline.cancel(false); pendingDeadline = null; } this.cancellationCause = cause; triggeredCancel = true; } } // 如果取消成功了，则通知监听器 if (triggeredCancel) { notifyAndClearListeners(); } return triggeredCancel; } ","wordCount":"2489","inLanguage":"en","datePublished":"2020-12-15T22:34:46Z","dateModified":"2020-12-15T22:34:46Z","author":{"@type":"Person","name":"HelloWood"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.hellowood.dev/posts/grpc-server-%E7%AB%AF%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B/"},"publisher":{"@type":"Organization","name":"HelloWood","logo":{"@type":"ImageObject","url":"https://blog.hellowood.dev/favicon.ico"}}}</script><link rel=icon href=/images/avatar.png sizes=16x16><link rel=apple-touch-icon href=/images/avatar.png><link rel=manifest href=/images/avatar.png><link rel=stylesheet href=https://cdn.staticfile.org/lxgw-wenkai-webfont/1.6.0/style.css><link rel=stylesheet href=/css/main.min.f8020eba33d585b82c30b2a1ceb0d4c4e8e41fb6d8843d07d8ad056da8712972.css integrity="sha256-+AIOujPVhbgsMLKhzrDUxOjkH7bYhD0H2K0FbahxKXI=" crossorigin=anonymous media=screen><link rel=stylesheet href=/scss/highlight/github-dark.min.min.66034289ee9a113219a2c4aae0a8bd2095ab255c832a42efcf5863f10814e7a1.css><script src=/js/highlight.min.min.872dfd2cd00064018a833a6e8e77a0fbf8fbac159546f2f205d4dad79a5d8e15.js></script>
<script>hljs.highlightAll()</script><script>(()=>{var t=window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches,e=localStorage.getItem("theme");t&&e===null&&(localStorage.setItem("theme","dark"),document.documentElement.setAttribute("data-dark-mode","")),t&&e==="dark"&&document.documentElement.setAttribute("data-dark-mode",""),e==="dark"&&document.documentElement.setAttribute("data-dark-mode","")})()</script></head><body><main class=wrapper><nav class=navigation><section class=container><a class=navigation-brand href=/>HOME</a>
<input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><span></span><span></span><span></span></label><ul class=navigation-list id=navigation-list><li class="navigation-item navigation-menu"><a class=navigation-link href=/posts>Blog</a></li><li class="navigation-item navigation-menu"><a class=navigation-link href=/tags>Tags</a></li><li class="navigation-item navigation-menu"><a class=navigation-link href=/archives>Archive</a></li><li class="navigation-item navigation-menu"><a class=navigation-link href=https://statistics.lab.hellowood.dev/share/r2Llssnu/Blog>Dashboard</a></li><li class="navigation-item menu-separator"><span>|</span></li><li class="navigation-item navigation-social"><a class=navigation-link href=https://github.com/helloworlde><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a></li><li class="navigation-item navigation-dark"><button id=mode type=button aria-label="toggle user light or dark theme">
<span class=toggle-dark><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-moon"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg></span><span class=toggle-light><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-sun"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></span></button></li></ul></section></nav><div id=content><article class=blog-single><header class=blog-title><h1>gRPC Server 端请求处理流程</h1></header><p><small>December 15, 2020&nbsp;· 2489 words&nbsp;· 12 min</small><p><div class=blog-toc><nav id=TableOfContents><ul><li><a href=#初始化>初始化</a></li><li><a href=#处理请求>处理请求</a><ul><li></li></ul></li><li><a href=#处理响应>处理响应</a><ul><li><a href=#1-执行业务逻辑处理>1. 执行业务逻辑处理</a></li><li><a href=#2-发送响应内容>2. 发送响应内容</a></li><li><a href=#3-完成请求>3. 完成请求</a></li></ul></li></ul></nav></div><section class=blog-content><h1 id=grpc-server-端请求处理流程>gRPC Server 端请求处理流程</h1><p>[TOC]</p><h2 id=初始化>初始化</h2><ol><li>创建并启动 ServerTransport</li></ol><p>在 Server 启动的时候，最终调用 <code>NettyServer</code> 的 <code>start()</code> 方法，为 <code>ServerBootstrap</code> 添加了 <code>ChannelInitializer</code>，最终，当有新的连接建立时，会由 <code>NettyServerHandler</code> 调用该类的 <code>initChannel</code> 方法，初始化一个 <code>NettyServerTransport</code></p><ul><li>io.grpc.netty.NettyServer#start</li></ul><p>在初始化 Netty Channel 时，会先创建 <code>NettyServerTransport</code>，然后调用监听器的 <code>Transport</code> 创建事件，添加一个超时取消任务；
然后会调用 <code>Transport</code> 的 <code>start</code> 方法启动 <code>Transport</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>b<span style=color:#f92672>.</span><span style=color:#a6e22e>childHandler</span><span style=color:#f92672>(</span><span style=color:#66d9ef>new</span> ChannelInitializer<span style=color:#f92672>&lt;</span>Channel<span style=color:#f92672>&gt;()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>initChannel</span><span style=color:#f92672>(</span>Channel ch<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 构建基于 Netty 的 ServerTransport
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        NettyServerTransport transport <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> NettyServerTransport<span style=color:#f92672>(</span><span style=color:#75715e>/*...*/</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        ServerTransportListener transportListener<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>synchronized</span> <span style=color:#f92672>(</span>NettyServer<span style=color:#f92672>.</span><span style=color:#a6e22e>this</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 调用监听器回调，Transport 创建事件
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            transportListener <span style=color:#f92672>=</span> listener<span style=color:#f92672>.</span><span style=color:#a6e22e>transportCreated</span><span style=color:#f92672>(</span>transport<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 启动监听器
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        transport<span style=color:#f92672>.</span><span style=color:#a6e22e>start</span><span style=color:#f92672>(</span>transportListener<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        ChannelFutureListener loopReleaser <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> LoopReleaser<span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>        channelDone<span style=color:#f92672>.</span><span style=color:#a6e22e>addListener</span><span style=color:#f92672>(</span>loopReleaser<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        ch<span style=color:#f92672>.</span><span style=color:#a6e22e>closeFuture</span><span style=color:#f92672>().</span><span style=color:#a6e22e>addListener</span><span style=color:#f92672>(</span>loopReleaser<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>});</span>
</span></span></code></pre></div><ul><li>io.grpc.netty.NettyServerTransport#start</li></ul><p>在启动 <code>Transport</code> 时，会为当前的 <code>Transport</code> 创建一个处理器，并绑定到 Netty 的 Channel 中</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>start</span><span style=color:#f92672>(</span>ServerTransportListener listener<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>listener</span> <span style=color:#f92672>=</span> listener<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 为 pipeline 创建 Netty Handler
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    grpcHandler <span style=color:#f92672>=</span> createHandler<span style=color:#f92672>(</span>listener<span style=color:#f92672>,</span> channelUnused<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 创建 Handler
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    ChannelHandler negotiationHandler <span style=color:#f92672>=</span> protocolNegotiator<span style=color:#f92672>.</span><span style=color:#a6e22e>newHandler</span><span style=color:#f92672>(</span>grpcHandler<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>    ChannelHandler bufferingHandler <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> WriteBufferingAndExceptionHandler<span style=color:#f92672>(</span>negotiationHandler<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 添加监听器
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    ChannelFutureListener terminationNotifier <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> TerminationNotifier<span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>    channelUnused<span style=color:#f92672>.</span><span style=color:#a6e22e>addListener</span><span style=color:#f92672>(</span>terminationNotifier<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>    channel<span style=color:#f92672>.</span><span style=color:#a6e22e>closeFuture</span><span style=color:#f92672>().</span><span style=color:#a6e22e>addListener</span><span style=color:#f92672>(</span>terminationNotifier<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    channel<span style=color:#f92672>.</span><span style=color:#a6e22e>pipeline</span><span style=color:#f92672>().</span><span style=color:#a6e22e>addLast</span><span style=color:#f92672>(</span>bufferingHandler<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><h2 id=处理请求>处理请求</h2><p>当 Server 与 Client 的连接建立成功之后，可以开始处理请求</p><h4 id=请求整体处理流程>请求整体处理流程</h4><ol><li>读取 <code>Settings</code> 帧，触发 <code>Transport</code> <code>ready</code> 事件</li><li>读取 <code>Header</code> 帧，触发 <code>FrameListener#onHeadersRead</code> 事件
3. 由 <code>NettyServerHandler</code> 处理
4. 根据 <code>Header</code> 里面的信息，获取相应的方法
4. 将 HTTP 流转换为 <code>NettyServerStream</code>
5. 触发 <code>Transport#streamCreated</code> 事件
6. 检查编解码、解压缩等信息，创建可取消的上下文
11. 初始化流监听器
6. 提交 <code>StreamCreated</code> 任务
7. 触发 <code>NettyServerStream.TransportState#onStreamAllocated</code> 事件
8. 提交 <code>OnReady</code> 任务</li><li>执行 <code>StreamCreated</code> 任务
10. 根据方法名查找方法定义
11. 调用 <code>startCall</code> 开始处理
12. 遍历拦截器，使用拦截器包装方法处理器
13. 调用 <code>startWrappedCall</code> 处理
14. 创建 <code>ServerCallImpl</code> 实例
15. 通过方法定义的请求处理器 <code>startCall</code> 方法处理
16. 创建响应观察器 <code>ServerCallStreamObserverImpl</code> 实例
17. 调用 <code>call.request()</code> 获取指定数量的消息
18. 提交 <code>RequestRunnable</code> 任务获取指定数量的消息
18. 创建调用监听器 <code>UnaryServerCallListener</code>
19. 创建 <code>ServerStreamListenerImpl</code> 流监听器实例</li><li>执行 <code>OnReady</code> 任务
21. 调用 <code>UnaryServerCallListener#onReady</code> 处理 <code>Ready</code> 事件
22. 修改 <code>ready</code> 状态
23. 如果有 <code>onReadyHandler</code> 任务，则执行</li><li>执行 <code>RequestRunnable</code> 任务
25. 要求指定数量的消息
25. 修改等待投递的消息数量
26. 调用 <code>deliver</code> 方法投递
27. 如果有待投递的消息，根据类型进行投递
28. 当消息类型是消息体时，处理消息体
29. 读取消息体的流
30. 调用 <code>MessageFramer.Listener#messagesAvailable</code> 事件，通知新的消息
31. 提交 <code>MessagesAvailable</code> 任务</li><li>调用 <code>MessageDeframer#close</code> 方法关闭帧
33. 调用流监听器半关闭事件
34. 提交 <code>HalfClosed</code> 任务</li><li>执行 <code>MessagesAvailable</code> 任务
32. 从 <code>MessageProducer</code> 中获取消息，解析为请求对象
33. 调用 <code>SeverCall.Listener#onMessage</code> 方法处理消息
34. 将 <code>request</code> 对象赋值给相应的对象，该对象会在 <code>halfClose</code> 时处理</li><li>执行 <code>HalfClosed</code> 任务
36. 调用 <code>invoke</code> 方法，处理业务逻辑
37. 根据方法 ID，使用相应的实现调用业务逻辑
38. 调用 <code>StreamObserver#onNext</code> 发送响应
39. 发送响应 <code>Header</code>
40. 设置编码和压缩的请求头
41. 写入 <code>Header</code>
40. 发送响应 <code>body</code>
41. 将响应对象序列化为流
42. 写入响应
43. 清空缓存
44. 调用 <code>StreamObserver#onComplete</code> 完成请求
45. 使用 <code>OK</code> 状态关闭调用
46. 修改关闭状态
47. 调用流关闭事件
48. 关闭帧
49. 将响应状态加入响应元数据中
50. 修改 <code>TransportState</code> 的状态
51. 写入响应元数据，发送给客户端
37. 冻结响应
38. 如果 <code>ready</code> 状态，再次执行 <code>onReady</code> 事件
39. 当流关闭时，调用 <code>TransportState#complete</code> 事件
40. 关闭监听器
41. 提交 <code>Closed</code> 任务
42. 执行 <code>Closed</code> 任务
43. 调用 <code>stream#complete</code> 事件
44. 取消上下文</li></ol><h4 id=1-读取-settings-帧>1. 读取 Settings 帧</h4><ul><li>io.grpc.netty.NettyServerHandler.FrameListener#onSettingsRead</li></ul><p>当读取到 Settings 帧时，会调用 onSettingsRead 方法，同时会同时 Transport 监听器 ready 事件</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>onSettingsRead</span><span style=color:#f92672>(</span>ChannelHandlerContext ctx<span style=color:#f92672>,</span> Http2Settings settings<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>firstSettings<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        firstSettings <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 通知 Transport ready
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        attributes <span style=color:#f92672>=</span> transportListener<span style=color:#f92672>.</span><span style=color:#a6e22e>transportReady</span><span style=color:#f92672>(</span>negotiationAttributes<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><ul><li>io.grpc.internal.ServerImpl.ServerTransportListenerImpl#transportReady</li></ul><p>会通知 Transport Ready 事件，会遍历 <code>ServerTransportFilter</code> 通知，默认没有 <code>ServerTransportFilter</code> 的实现</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> Attributes <span style=color:#a6e22e>transportReady</span><span style=color:#f92672>(</span>Attributes attributes<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 如果有握手超时回调，则取消
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    handshakeTimeoutFuture<span style=color:#f92672>.</span><span style=color:#a6e22e>cancel</span><span style=color:#f92672>(</span><span style=color:#66d9ef>false</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>    handshakeTimeoutFuture <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 遍历 TransportFilter，通知 ready 事件并获取 attributes
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>for</span> <span style=color:#f92672>(</span>ServerTransportFilter filter <span style=color:#f92672>:</span> transportFilters<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        attributes <span style=color:#f92672>=</span> Preconditions<span style=color:#f92672>.</span><span style=color:#a6e22e>checkNotNull</span><span style=color:#f92672>(</span>filter<span style=color:#f92672>.</span><span style=color:#a6e22e>transportReady</span><span style=color:#f92672>(</span>attributes<span style=color:#f92672>),</span> <span style=color:#e6db74>&#34;Filter %s returned null&#34;</span><span style=color:#f92672>,</span> filter<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>attributes</span> <span style=color:#f92672>=</span> attributes<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> attributes<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><h4 id=2-接收-header>2. 接收 header</h4><p>当 Server 接收到 Client 发送的 header 后，经过 Netty 处理，最终调用 <code>onHeadersRead</code> 开始处理流</p><ul><li>io.grpc.netty.shaded.io.grpc.netty.NettyServerHandler.FrameListener#onHeadersRead</li></ul><p>接收 header 帧</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>onHeadersRead</span><span style=color:#f92672>(</span>ChannelHandlerContext ctx<span style=color:#f92672>,</span> <span style=color:#66d9ef>int</span> streamId<span style=color:#f92672>,</span> Http2Headers headers<span style=color:#f92672>,</span> <span style=color:#66d9ef>int</span> streamDependency<span style=color:#f92672>,</span> <span style=color:#66d9ef>short</span> weight<span style=color:#f92672>,</span> <span style=color:#66d9ef>boolean</span> exclusive<span style=color:#f92672>,</span> <span style=color:#66d9ef>int</span> padding<span style=color:#f92672>,</span> <span style=color:#66d9ef>boolean</span> endStream<span style=color:#f92672>)</span> <span style=color:#66d9ef>throws</span> Http2Exception <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>NettyServerHandler<span style=color:#f92672>.</span><span style=color:#a6e22e>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>keepAliveManager</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        NettyServerHandler<span style=color:#f92672>.</span><span style=color:#a6e22e>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>keepAliveManager</span><span style=color:#f92672>.</span><span style=color:#a6e22e>onDataReceived</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    NettyServerHandler<span style=color:#f92672>.</span><span style=color:#a6e22e>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>onHeadersRead</span><span style=color:#f92672>(</span>ctx<span style=color:#f92672>,</span> streamId<span style=color:#f92672>,</span> headers<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><ul><li>io.grpc.netty.NettyServerHandler.FrameListener#onHeadersRead</li></ul><p>开始处理 header</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>onHeadersRead</span><span style=color:#f92672>(</span>ChannelHandlerContext ctx<span style=color:#f92672>,</span>
</span></span><span style=display:flex><span>                          <span style=color:#66d9ef>int</span> streamId<span style=color:#f92672>,</span>
</span></span><span style=display:flex><span>                          Http2Headers headers<span style=color:#f92672>,</span>
</span></span><span style=display:flex><span>                          <span style=color:#66d9ef>int</span> streamDependency<span style=color:#f92672>,</span>
</span></span><span style=display:flex><span>                          <span style=color:#66d9ef>short</span> weight<span style=color:#f92672>,</span>
</span></span><span style=display:flex><span>                          <span style=color:#66d9ef>boolean</span> exclusive<span style=color:#f92672>,</span>
</span></span><span style=display:flex><span>                          <span style=color:#66d9ef>int</span> padding<span style=color:#f92672>,</span>
</span></span><span style=display:flex><span>                          <span style=color:#66d9ef>boolean</span> endStream<span style=color:#f92672>)</span> <span style=color:#66d9ef>throws</span> Http2Exception <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>keepAliveManager <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        keepAliveManager<span style=color:#f92672>.</span><span style=color:#a6e22e>onDataReceived</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 最终会创建流并出发流创建事件
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    NettyServerHandler<span style=color:#f92672>.</span><span style=color:#a6e22e>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>onHeadersRead</span><span style=color:#f92672>(</span>ctx<span style=color:#f92672>,</span> streamId<span style=color:#f92672>,</span> headers<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><ul><li>io.grpc.netty.NettyServerHandler#onHeadersRead</li></ul><p>会根据请求的 Header 信息，查找服务和方法，校验请求类型，请求方法，传输编码等内容；然后根据 HTTP2 流 Id，获取对应的流，将其转换为 <code>NettyServerStream</code>；调用 <code>Transport</code> 的 <code>onStreamCreated</code> 事件
向线程池中提交 <code>StreamCreated</code>，然后调用 <code>onStreamAllocated</code> 方法通知流 <code>StreamListener</code>的<code>onReady</code>事件提交<code>OnReady</code>任务</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>onHeadersRead</span><span style=color:#f92672>(</span>ChannelHandlerContext ctx<span style=color:#f92672>,</span> <span style=color:#66d9ef>int</span> streamId<span style=color:#f92672>,</span> Http2Headers headers<span style=color:#f92672>)</span> <span style=color:#66d9ef>throws</span> Http2Exception <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>try</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 删除斜杠获取方法限定名称
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    CharSequence path <span style=color:#f92672>=</span> headers<span style=color:#f92672>.</span><span style=color:#a6e22e>path</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 方法限定名，即包含服务名和方法名
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    String method <span style=color:#f92672>=</span> path<span style=color:#f92672>.</span><span style=color:#a6e22e>subSequence</span><span style=color:#f92672>(</span><span style=color:#ae81ff>1</span><span style=color:#f92672>,</span> path<span style=color:#f92672>.</span><span style=color:#a6e22e>length</span><span style=color:#f92672>()).</span><span style=color:#a6e22e>toString</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 获取 HTTP 流
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    Http2Stream http2Stream <span style=color:#f92672>=</span> requireHttp2Stream<span style=color:#f92672>(</span>streamId<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 将 header 转为 metadata
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    Metadata metadata <span style=color:#f92672>=</span> Utils<span style=color:#f92672>.</span><span style=color:#a6e22e>convertHeaders</span><span style=color:#f92672>(</span>headers<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 创建支持统计的上下文
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    StatsTraceContext statsTraceCtx <span style=color:#f92672>=</span> StatsTraceContext<span style=color:#f92672>.</span><span style=color:#a6e22e>newServerContext</span><span style=color:#f92672>(</span>streamTracerFactories<span style=color:#f92672>,</span> method<span style=color:#f92672>,</span> metadata<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 创建流的声明
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    NettyServerStream<span style=color:#f92672>.</span><span style=color:#a6e22e>TransportState</span> state <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> NettyServerStream<span style=color:#f92672>.</span><span style=color:#a6e22e>TransportState</span><span style=color:#f92672>(</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>this</span><span style=color:#f92672>,</span>
</span></span><span style=display:flex><span>            ctx<span style=color:#f92672>.</span><span style=color:#a6e22e>channel</span><span style=color:#f92672>().</span><span style=color:#a6e22e>eventLoop</span><span style=color:#f92672>(),</span>
</span></span><span style=display:flex><span>            http2Stream<span style=color:#f92672>,</span>
</span></span><span style=display:flex><span>            maxMessageSize<span style=color:#f92672>,</span>
</span></span><span style=display:flex><span>            statsTraceCtx<span style=color:#f92672>,</span>
</span></span><span style=display:flex><span>            transportTracer<span style=color:#f92672>,</span>
</span></span><span style=display:flex><span>            method<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>try</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>      <span style=color:#75715e>// 获取请求的 authority
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      String authority <span style=color:#f92672>=</span> getOrUpdateAuthority<span style=color:#f92672>((</span>AsciiString<span style=color:#f92672>)</span> headers<span style=color:#f92672>.</span><span style=color:#a6e22e>authority</span><span style=color:#f92672>());</span>
</span></span><span style=display:flex><span>      <span style=color:#75715e>// 创建 Server 端的流
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      NettyServerStream stream <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> NettyServerStream<span style=color:#f92672>(</span>ctx<span style=color:#f92672>.</span><span style=color:#a6e22e>channel</span><span style=color:#f92672>(),</span>
</span></span><span style=display:flex><span>              state<span style=color:#f92672>,</span>
</span></span><span style=display:flex><span>              attributes<span style=color:#f92672>,</span>
</span></span><span style=display:flex><span>              authority<span style=color:#f92672>,</span>
</span></span><span style=display:flex><span>              statsTraceCtx<span style=color:#f92672>,</span>
</span></span><span style=display:flex><span>              transportTracer<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#75715e>// 触发监听器，通知流创建事件，查找相应处理器，开始处理流，会提交 StreamCreated 任务到线程池中
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      transportListener<span style=color:#f92672>.</span><span style=color:#a6e22e>streamCreated</span><span style=color:#f92672>(</span>stream<span style=color:#f92672>,</span> method<span style=color:#f92672>,</span> metadata<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>      <span style=color:#75715e>// 会提交 OnReady 任务到线程池中，通知 Stream Ready
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      state<span style=color:#f92672>.</span><span style=color:#a6e22e>onStreamAllocated</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>      http2Stream<span style=color:#f92672>.</span><span style=color:#a6e22e>setProperty</span><span style=color:#f92672>(</span>streamKey<span style=color:#f92672>,</span> state<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>}</span> <span style=color:#66d9ef>catch</span> <span style=color:#f92672>(</span>Exception e<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    logger<span style=color:#f92672>.</span><span style=color:#a6e22e>log</span><span style=color:#f92672>(</span>Level<span style=color:#f92672>.</span><span style=color:#a6e22e>WARNING</span><span style=color:#f92672>,</span> <span style=color:#e6db74>&#34;Exception in onHeadersRead()&#34;</span><span style=color:#f92672>,</span> e<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>throw</span> newStreamException<span style=color:#f92672>(</span>streamId<span style=color:#f92672>,</span> e<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><h4 id=3-流创建事件>3. 流创建事件</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>transportListener<span style=color:#f92672>.</span><span style=color:#a6e22e>streamCreated</span><span style=color:#f92672>(</span>stream<span style=color:#f92672>,</span> method<span style=color:#f92672>,</span> metadata<span style=color:#f92672>);</span>
</span></span></code></pre></div><ul><li>io.grpc.internal.ServerImpl.ServerTransportListenerImpl#streamCreated</li></ul><p>检查并初始化流的编解码，解压缩等信息；创建可需取消的上下文，选择要执行的线程池，初始化流监听器，最终提交流创建任务</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>streamCreatedInternal</span><span style=color:#f92672>(</span><span style=color:#66d9ef>final</span> ServerStream stream<span style=color:#f92672>,</span>
</span></span><span style=display:flex><span>                                   <span style=color:#66d9ef>final</span> String methodName<span style=color:#f92672>,</span>
</span></span><span style=display:flex><span>                                   <span style=color:#66d9ef>final</span> Metadata headers<span style=color:#f92672>,</span>
</span></span><span style=display:flex><span>                                   <span style=color:#66d9ef>final</span> Tag tag<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>final</span> Executor wrappedExecutor<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>executor <span style=color:#f92672>==</span> directExecutor<span style=color:#f92672>())</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        wrappedExecutor <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> SerializeReentrantCallsDirectExecutor<span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>        stream<span style=color:#f92672>.</span><span style=color:#a6e22e>optimizeForDirectExecutor</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span> <span style=color:#66d9ef>else</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 否则使用指定的 Executor 执行
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        wrappedExecutor <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> SerializingExecutor<span style=color:#f92672>(</span>executor<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 创建可以取消的上下文
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>final</span> Context<span style=color:#f92672>.</span><span style=color:#a6e22e>CancellableContext</span> context <span style=color:#f92672>=</span> createContext<span style=color:#f92672>(</span>headers<span style=color:#f92672>,</span> statsTraceCtx<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 流事件监听器，处理流的所有生命周期事件
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>final</span> JumpToApplicationThreadServerStreamListener jumpListener <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> JumpToApplicationThreadServerStreamListener<span style=color:#f92672>(</span>wrappedExecutor<span style=color:#f92672>,</span> executor<span style=color:#f92672>,</span> stream<span style=color:#f92672>,</span> context<span style=color:#f92672>,</span> tag<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>    stream<span style=color:#f92672>.</span><span style=color:#a6e22e>setListener</span><span style=color:#f92672>(</span>jumpListener<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 提交流创建任务
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    wrappedExecutor<span style=color:#f92672>.</span><span style=color:#a6e22e>execute</span><span style=color:#f92672>(</span><span style=color:#66d9ef>new</span> StreamCreated<span style=color:#f92672>());</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><p>接下来会执行流 ready 的任务</p><h4 id=4-流-ready-事件>4. 流 ready 事件</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>state<span style=color:#f92672>.</span><span style=color:#a6e22e>onStreamAllocated</span><span style=color:#f92672>();</span>
</span></span></code></pre></div><ul><li>io.grpc.internal.AbstractStream.TransportState#onStreamAllocated</li></ul><p>流分配，会调用流 ready 事件</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>onStreamAllocated</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    checkState<span style=color:#f92672>(</span>listener<span style=color:#f92672>()</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>synchronized</span> <span style=color:#f92672>(</span>onReadyLock<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        checkState<span style=color:#f92672>(!</span>allocated<span style=color:#f92672>,</span> <span style=color:#e6db74>&#34;Already allocated&#34;</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        allocated <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>    notifyIfReady<span style=color:#f92672>();</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><ul><li>io.grpc.internal.ServerImpl.JumpToApplicationThreadServerStreamListener#onReady</li></ul><p>最终会调用 onReady 提交流的 <code>OnReady</code> 任务</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>onReady</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>try</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        callExecutor<span style=color:#f92672>.</span><span style=color:#a6e22e>execute</span><span style=color:#f92672>(</span><span style=color:#66d9ef>new</span> OnReady<span style=color:#f92672>());</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><h4 id=5-执行流创建任务>5. 执行流创建任务</h4><p>执行 <code>StreamCreated</code>任务</p><ul><li>io.grpc.internal.ServerImpl.ServerTransportListenerImpl#streamCreated</li></ul><p>执行 <code>StreamCreated</code>任务时，会先根据方法名称从注册器中查找对应的方法处理器，然后调用 startCall 方法进行处理</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// 流创建任务处理
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>StreamCreated</span> <span style=color:#66d9ef>extends</span> ContextRunnable <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>runInternal</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            ServerStreamListener listener <span style=color:#f92672>=</span> NOOP_LISTENER<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>try</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 根据方法名称获取方法定义
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                ServerMethodDefinition<span style=color:#f92672>&lt;?,</span> <span style=color:#f92672>?&gt;</span> method <span style=color:#f92672>=</span> registry<span style=color:#f92672>.</span><span style=color:#a6e22e>lookupMethod</span><span style=color:#f92672>(</span>methodName<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 如果没有则从回退的方法注册器中查找
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>method <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                    method <span style=color:#f92672>=</span> fallbackRegistry<span style=color:#f92672>.</span><span style=color:#a6e22e>lookupMethod</span><span style=color:#f92672>(</span>methodName<span style=color:#f92672>,</span> stream<span style=color:#f92672>.</span><span style=color:#a6e22e>getAuthority</span><span style=color:#f92672>());</span>
</span></span><span style=display:flex><span>                <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 如果没有则方法不存在，返回 UNIMPLEMENTED，关闭流，取消上下文
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>method <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                    Status status <span style=color:#f92672>=</span> Status<span style=color:#f92672>.</span><span style=color:#a6e22e>UNIMPLEMENTED</span><span style=color:#f92672>.</span><span style=color:#a6e22e>withDescription</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;Method not found: &#34;</span> <span style=color:#f92672>+</span> methodName<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>                    stream<span style=color:#f92672>.</span><span style=color:#a6e22e>close</span><span style=color:#f92672>(</span>status<span style=color:#f92672>,</span> <span style=color:#66d9ef>new</span> Metadata<span style=color:#f92672>());</span>
</span></span><span style=display:flex><span>                    context<span style=color:#f92672>.</span><span style=color:#a6e22e>cancel</span><span style=color:#f92672>(</span><span style=color:#66d9ef>null</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>return</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>                <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 如果方法存在，则开始调用
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                listener <span style=color:#f92672>=</span> startCall<span style=color:#f92672>(</span>stream<span style=color:#f92672>,</span> methodName<span style=color:#f92672>,</span> method<span style=color:#f92672>,</span> headers<span style=color:#f92672>,</span> context<span style=color:#f92672>,</span> statsTraceCtx<span style=color:#f92672>,</span> tag<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>}</span> <span style=color:#66d9ef>catch</span> <span style=color:#f92672>(</span>Throwable t<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                stream<span style=color:#f92672>.</span><span style=color:#a6e22e>close</span><span style=color:#f92672>(</span>Status<span style=color:#f92672>.</span><span style=color:#a6e22e>fromThrowable</span><span style=color:#f92672>(</span>t<span style=color:#f92672>),</span> <span style=color:#66d9ef>new</span> Metadata<span style=color:#f92672>());</span>
</span></span><span style=display:flex><span>                context<span style=color:#f92672>.</span><span style=color:#a6e22e>cancel</span><span style=color:#f92672>(</span><span style=color:#66d9ef>null</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>throw</span> t<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>}</span> <span style=color:#66d9ef>finally</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                 jumpListener<span style=color:#f92672>.</span><span style=color:#a6e22e>setListener</span><span style=color:#f92672>(</span>listener<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>           
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ServerStreamCancellationListener</span> <span style=color:#66d9ef>implements</span> Context<span style=color:#f92672>.</span><span style=color:#a6e22e>CancellationListener</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>cancelled</span><span style=color:#f92672>(</span>Context context<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                    Status status <span style=color:#f92672>=</span> statusFromCancelled<span style=color:#f92672>(</span>context<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>DEADLINE_EXCEEDED<span style=color:#f92672>.</span><span style=color:#a6e22e>getCode</span><span style=color:#f92672>().</span><span style=color:#a6e22e>equals</span><span style=color:#f92672>(</span>status<span style=color:#f92672>.</span><span style=color:#a6e22e>getCode</span><span style=color:#f92672>()))</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                        stream<span style=color:#f92672>.</span><span style=color:#a6e22e>cancel</span><span style=color:#f92672>(</span>status<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>                    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>                 <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>            context<span style=color:#f92672>.</span><span style=color:#a6e22e>addListener</span><span style=color:#f92672>(</span><span style=color:#66d9ef>new</span> ServerStreamCancellationListener<span style=color:#f92672>(),</span> directExecutor<span style=color:#f92672>());</span>
</span></span><span style=display:flex><span>         <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span></code></pre></div><ul><li>io.grpc.internal.ServerImpl.ServerTransportListenerImpl#startCall</li></ul><p>会获取方法的处理器，然后遍历拦截器，封装处理器，调用 <code>startWrappedCall</code> 处理</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#f92672>&lt;</span>ReqT<span style=color:#f92672>,</span> RespT<span style=color:#f92672>&gt;</span> ServerStreamListener <span style=color:#a6e22e>startCall</span><span style=color:#f92672>(</span>ServerStream stream<span style=color:#f92672>,</span>
</span></span><span style=display:flex><span>                                                     String fullMethodName<span style=color:#f92672>,</span>
</span></span><span style=display:flex><span>                                                     ServerMethodDefinition<span style=color:#f92672>&lt;</span>ReqT<span style=color:#f92672>,</span> RespT<span style=color:#f92672>&gt;</span> methodDef<span style=color:#f92672>,</span>
</span></span><span style=display:flex><span>                                                     Metadata headers<span style=color:#f92672>,</span>
</span></span><span style=display:flex><span>                                                     Context<span style=color:#f92672>.</span><span style=color:#a6e22e>CancellableContext</span> context<span style=color:#f92672>,</span>
</span></span><span style=display:flex><span>                                                     StatsTraceContext statsTraceCtx<span style=color:#f92672>,</span>
</span></span><span style=display:flex><span>                                                     Tag tag<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 从方法描述获取调用处理器
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    ServerCallHandler<span style=color:#f92672>&lt;</span>ReqT<span style=color:#f92672>,</span> RespT<span style=color:#f92672>&gt;</span> handler <span style=color:#f92672>=</span> methodDef<span style=color:#f92672>.</span><span style=color:#a6e22e>getServerCallHandler</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 遍历拦截器，为处理器添加拦截器
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>for</span> <span style=color:#f92672>(</span>ServerInterceptor interceptor <span style=color:#f92672>:</span> interceptors<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        handler <span style=color:#f92672>=</span> InternalServerInterceptors<span style=color:#f92672>.</span><span style=color:#a6e22e>interceptCallHandler</span><span style=color:#f92672>(</span>interceptor<span style=color:#f92672>,</span> handler<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 使用添加了拦截器后的处理器创建新的方法定义
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    ServerMethodDefinition<span style=color:#f92672>&lt;</span>ReqT<span style=color:#f92672>,</span> RespT<span style=color:#f92672>&gt;</span> interceptedDef <span style=color:#f92672>=</span> methodDef<span style=color:#f92672>.</span><span style=color:#a6e22e>withServerCallHandler</span><span style=color:#f92672>(</span>handler<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 处理封装后的调用
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>return</span> startWrappedCall<span style=color:#f92672>(</span>fullMethodName<span style=color:#f92672>,</span> wMethodDef<span style=color:#f92672>,</span> stream<span style=color:#f92672>,</span> headers<span style=color:#f92672>,</span> context<span style=color:#f92672>,</span> tag<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><ul><li>io.grpc.internal.ServerImpl.ServerTransportListenerImpl#startWrappedCall</li></ul><p>创建请求处理器实例，然后调用方法处理器，开始处理请求，同时创建流监听器</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#f92672>&lt;</span>WReqT<span style=color:#f92672>,</span> WRespT<span style=color:#f92672>&gt;</span> ServerStreamListener <span style=color:#a6e22e>startWrappedCall</span><span style=color:#f92672>(</span>String fullMethodName<span style=color:#f92672>,</span>
</span></span><span style=display:flex><span>                                                              ServerMethodDefinition<span style=color:#f92672>&lt;</span>WReqT<span style=color:#f92672>,</span> WRespT<span style=color:#f92672>&gt;</span> methodDef<span style=color:#f92672>,</span>
</span></span><span style=display:flex><span>                                                              ServerStream stream<span style=color:#f92672>,</span>
</span></span><span style=display:flex><span>                                                              Metadata headers<span style=color:#f92672>,</span>
</span></span><span style=display:flex><span>                                                              Context<span style=color:#f92672>.</span><span style=color:#a6e22e>CancellableContext</span> context<span style=color:#f92672>,</span>
</span></span><span style=display:flex><span>                                                              Tag tag<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 创建请求处理器
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    ServerCallImpl<span style=color:#f92672>&lt;</span>WReqT<span style=color:#f92672>,</span> WRespT<span style=color:#f92672>&gt;</span> call <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ServerCallImpl<span style=color:#f92672>&lt;&gt;(</span>stream<span style=color:#f92672>,</span>
</span></span><span style=display:flex><span>            methodDef<span style=color:#f92672>.</span><span style=color:#a6e22e>getMethodDescriptor</span><span style=color:#f92672>(),</span>
</span></span><span style=display:flex><span>            headers<span style=color:#f92672>,</span>
</span></span><span style=display:flex><span>            context<span style=color:#f92672>,</span>
</span></span><span style=display:flex><span>            decompressorRegistry<span style=color:#f92672>,</span>
</span></span><span style=display:flex><span>            compressorRegistry<span style=color:#f92672>,</span>
</span></span><span style=display:flex><span>            serverCallTracer<span style=color:#f92672>,</span>
</span></span><span style=display:flex><span>            tag<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 调用方法处理器，真正调用实现逻辑的方法
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    ServerCall<span style=color:#f92672>.</span><span style=color:#a6e22e>Listener</span><span style=color:#f92672>&lt;</span>WReqT<span style=color:#f92672>&gt;</span> listener <span style=color:#f92672>=</span> methodDef<span style=color:#f92672>.</span><span style=color:#a6e22e>getServerCallHandler</span><span style=color:#f92672>().</span><span style=color:#a6e22e>startCall</span><span style=color:#f92672>(</span>call<span style=color:#f92672>,</span> headers<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>listener <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> NullPointerException<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;startCall() returned a null listener for method &#34;</span> <span style=color:#f92672>+</span> fullMethodName<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 根据调用监听器创建新的流监听器
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>return</span> call<span style=color:#f92672>.</span><span style=color:#a6e22e>newServerStreamListener</span><span style=color:#f92672>(</span>listener<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><ul><li>io.grpc.stub.ServerCalls.UnaryServerCallHandler#startCall</li></ul><p>会创建响应观察器，要求指定数量的消息，并创建监听器</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> ServerCall<span style=color:#f92672>.</span><span style=color:#a6e22e>Listener</span><span style=color:#f92672>&lt;</span>ReqT<span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>startCall</span><span style=color:#f92672>(</span>ServerCall<span style=color:#f92672>&lt;</span>ReqT<span style=color:#f92672>,</span> RespT<span style=color:#f92672>&gt;</span> call<span style=color:#f92672>,</span> Metadata headers<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 创建响应处理器
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    ServerCallStreamObserverImpl<span style=color:#f92672>&lt;</span>ReqT<span style=color:#f92672>,</span> RespT<span style=color:#f92672>&gt;</span> responseObserver <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ServerCallStreamObserverImpl<span style=color:#f92672>&lt;&gt;(</span>call<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 会调用 io.grpc.internal.AbstractStream#request 方法获取消息
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    call<span style=color:#f92672>.</span><span style=color:#a6e22e>request</span><span style=color:#f92672>(</span><span style=color:#ae81ff>2</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 返回监听器
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> UnaryServerCallListener<span style=color:#f92672>(</span>responseObserver<span style=color:#f92672>,</span> call<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><h4 id=6--提交要求指定数量的消息任务>6. 提交要求指定数量的消息任务</h4><p>在执行 <code>StreamCreated</code> 任务时，会调用 <code>startCall</code> 方法，提交 <code>RequestRunnable</code>任务，要求指定数量的消息</p><ul><li>io.grpc.internal.AbstractStream#request</li></ul><p>在执行 <code>StreamCreated</code> 任务时指定接收的帧的数量</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>request</span><span style=color:#f92672>(</span><span style=color:#66d9ef>int</span> numMessages<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    transportState<span style=color:#f92672>().</span><span style=color:#a6e22e>requestMessagesFromDeframer</span><span style=color:#f92672>(</span>numMessages<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><ul><li>io.grpc.internal.AbstractStream.TransportState#requestMessagesFromDeframer</li></ul><p>提交获取指定数量的帧的任务</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>requestMessagesFromDeframer</span><span style=color:#f92672>(</span><span style=color:#66d9ef>final</span> <span style=color:#66d9ef>int</span> numMessages<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 如果不是线程安全的解帧器，则由 Transport 的线程执行
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>RequestRunnable</span> <span style=color:#66d9ef>implements</span> Runnable <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>run</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>try</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                deframer<span style=color:#f92672>.</span><span style=color:#a6e22e>request</span><span style=color:#f92672>(</span>numMessages<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>}</span> <span style=color:#66d9ef>catch</span> <span style=color:#f92672>(</span>Throwable t<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                deframeFailed<span style=color:#f92672>(</span>t<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>    runOnTransportThread<span style=color:#f92672>(</span><span style=color:#66d9ef>new</span> RequestRunnable<span style=color:#f92672>());</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><h4 id=7-执行流-ready-任务>7. 执行流 ready 任务</h4><p>执行 <code>OnReady</code> 任务</p><ul><li>io.grpc.internal.ServerImpl.JumpToApplicationThreadServerStreamListener#onReady</li></ul><p>执行 onReady 时提交的 <code>OnReady</code> 任务</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>    <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>OnReady</span> <span style=color:#66d9ef>extends</span> ContextRunnable <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        OnReady<span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>super</span><span style=color:#f92672>(</span>context<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>runInContext</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>try</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 调用监听器的 ready 事件
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                getListener<span style=color:#f92672>().</span><span style=color:#a6e22e>onReady</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>}</span> <span style=color:#66d9ef>catch</span> <span style=color:#f92672>(</span>Throwable t<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                internalClose<span style=color:#f92672>(</span>t<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>throw</span> t<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span></code></pre></div><ul><li>io.grpc.stub.ServerCalls.UnaryServerCallHandler.UnaryServerCallListener#onReady</li></ul><p>处理流 ready 事件，如果有 <code>onReadyHandler</code> 则会执行</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>onReady</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 将 ready 状态变为 true
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    wasReady <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 如果响应有 readyHandler，则执行
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>responseObserver<span style=color:#f92672>.</span><span style=color:#a6e22e>onReadyHandler</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        responseObserver<span style=color:#f92672>.</span><span style=color:#a6e22e>onReadyHandler</span><span style=color:#f92672>.</span><span style=color:#a6e22e>run</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><h4 id=8-执行读取指定数量的消息任务并提交有可用消息任务>8. 执行读取指定数量的消息任务并提交有可用消息任务</h4><p>执行 <code>RequestRunnable</code>任务</p><ul><li>RequestRunnable</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>RequestRunnable</span> <span style=color:#66d9ef>implements</span> Runnable <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>run</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>try</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            deframer<span style=color:#f92672>.</span><span style=color:#a6e22e>request</span><span style=color:#f92672>(</span>numMessages<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span> <span style=color:#66d9ef>catch</span> <span style=color:#f92672>(</span>Throwable t<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            deframeFailed<span style=color:#f92672>(</span>t<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><ul><li>io.grpc.internal.MessageDeframer#request</li></ul><p>读取指定数量的帧</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>request</span><span style=color:#f92672>(</span><span style=color:#66d9ef>int</span> numMessages<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>isClosed<span style=color:#f92672>())</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>  pendingDeliveries <span style=color:#f92672>+=</span> numMessages<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>  deliver<span style=color:#f92672>();</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><ul><li>io.grpc.internal.MessageDeframer#deliver</li></ul><p>读取消息并投递给监听器</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>deliver</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 检查投递的状态
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>inDelivery<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>  inDelivery <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>try</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 如果没有停止投递，且有等待投递的消息，且读取成功，则根据相应状态进行处理
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>while</span> <span style=color:#f92672>(!</span>stopDelivery <span style=color:#f92672>&amp;&amp;</span> pendingDeliveries <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> readRequiredBytes<span style=color:#f92672>())</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>switch</span> <span style=color:#f92672>(</span>state<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>case</span> HEADER<span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>          <span style=color:#75715e>// 处理 header
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>          processHeader<span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>break</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>case</span> BODY<span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>          <span style=color:#75715e>// 处理body
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>          processBody<span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>          pendingDeliveries<span style=color:#f92672>--;</span>
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>break</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>default</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> AssertionError<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;Invalid state: &#34;</span> <span style=color:#f92672>+</span> state<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 如果已经停止投递，则关闭
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>stopDelivery<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>      close<span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>return</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>closeWhenComplete <span style=color:#f92672>&amp;&amp;</span> isStalled<span style=color:#f92672>())</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>      close<span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>}</span> <span style=color:#66d9ef>finally</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    inDelivery <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><ul><li>io.grpc.internal.MessageDeframer#processBody</li></ul><p>读取请求体并通知监听器有新的消息</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>processBody</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 读取请求体的流
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  InputStream stream <span style=color:#f92672>=</span> compressedFlag <span style=color:#f92672>?</span> getCompressedBody<span style=color:#f92672>()</span> <span style=color:#f92672>:</span> getUncompressedBody<span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>  nextFrame <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 通知监听器有新的消息
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  listener<span style=color:#f92672>.</span><span style=color:#a6e22e>messagesAvailable</span><span style=color:#f92672>(</span><span style=color:#66d9ef>new</span> SingleMessageProducer<span style=color:#f92672>(</span>stream<span style=color:#f92672>));</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 将状态改为处理 header
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  state <span style=color:#f92672>=</span> State<span style=color:#f92672>.</span><span style=color:#a6e22e>HEADER</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>  requiredLength <span style=color:#f92672>=</span> HEADER_LENGTH<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><ul><li>io.grpc.internal.ServerImpl.JumpToApplicationThreadServerStreamListener#messagesAvailable</li></ul><p>通知有新的消息可用，会提交 <code>MessageAvailable</code> 任务</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>messagesAvailable</span><span style=color:#f92672>(</span><span style=color:#66d9ef>final</span> MessageProducer producer<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>try</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 执行任务
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        callExecutor<span style=color:#f92672>.</span><span style=color:#a6e22e>execute</span><span style=color:#f92672>(</span><span style=color:#66d9ef>new</span> MessagesAvailable<span style=color:#f92672>());</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><h4 id=9-执行有新的可用消息任务>9. 执行有新的可用消息任务</h4><ul><li>io.grpc.internal.ServerImpl.JumpToApplicationThreadServerStreamListener#messagesAvailable</li></ul><p>通知有新的消息可用，会提交 <code>MessageAvailable</code> 任务</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>    <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MessagesAvailable</span> <span style=color:#66d9ef>extends</span> ContextRunnable <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        MessagesAvailable<span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>super</span><span style=color:#f92672>(</span>context<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>runInContext</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>try</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 获取监听器，通知有新的消息
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                getListener<span style=color:#f92672>().</span><span style=color:#a6e22e>messagesAvailable</span><span style=color:#f92672>(</span>producer<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>}</span> <span style=color:#66d9ef>catch</span> <span style=color:#f92672>(</span>Throwable t<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                internalClose<span style=color:#f92672>(</span>t<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>throw</span> t<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span></code></pre></div><ul><li>io.grpc.internal.ServerCallImpl.ServerStreamListenerImpl#messagesAvailableInternal</li></ul><p>执行时，会先将流解析为请求对象，然后调用监听器的 <code>onMessage</code>方法，处理消息</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>messagesAvailableInternal</span><span style=color:#f92672>(</span><span style=color:#66d9ef>final</span> MessageProducer producer<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 如果调用已经取消了，则关闭生产者
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>call<span style=color:#f92672>.</span><span style=color:#a6e22e>cancelled</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        GrpcUtil<span style=color:#f92672>.</span><span style=color:#a6e22e>closeQuietly</span><span style=color:#f92672>(</span>producer<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    InputStream message<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>try</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 从生产者中获取消息，
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>while</span> <span style=color:#f92672>((</span>message <span style=color:#f92672>=</span> producer<span style=color:#f92672>.</span><span style=color:#a6e22e>next</span><span style=color:#f92672>())</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>try</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 将流解析为请求对象，发送给监听器
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                listener<span style=color:#f92672>.</span><span style=color:#a6e22e>onMessage</span><span style=color:#f92672>(</span>call<span style=color:#f92672>.</span><span style=color:#a6e22e>method</span><span style=color:#f92672>.</span><span style=color:#a6e22e>parseRequest</span><span style=color:#f92672>(</span>message<span style=color:#f92672>));</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>}</span> <span style=color:#66d9ef>catch</span> <span style=color:#f92672>(</span>Throwable t<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                GrpcUtil<span style=color:#f92672>.</span><span style=color:#a6e22e>closeQuietly</span><span style=color:#f92672>(</span>message<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>throw</span> t<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>            message<span style=color:#f92672>.</span><span style=color:#a6e22e>close</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span> <span style=color:#66d9ef>catch</span> <span style=color:#f92672>(</span>Throwable t<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        GrpcUtil<span style=color:#f92672>.</span><span style=color:#a6e22e>closeQuietly</span><span style=color:#f92672>(</span>producer<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        Throwables<span style=color:#f92672>.</span><span style=color:#a6e22e>throwIfUnchecked</span><span style=color:#f92672>(</span>t<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> RuntimeException<span style=color:#f92672>(</span>t<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><ul><li>io.grpc.stub.ServerCalls.UnaryServerCallHandler.UnaryServerCallListener#onMessage</li></ul><p>由监听器接收消息，并赋值给相应的对象，在 <code>halfClose</code> 事件时处理该请求</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>onMessage</span><span style=color:#f92672>(</span>ReqT request<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 如果已经接收到了一个请求，则返回错误
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span><span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>request</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        call<span style=color:#f92672>.</span><span style=color:#a6e22e>close</span><span style=color:#f92672>(</span>Status<span style=color:#f92672>.</span><span style=color:#a6e22e>INTERNAL</span><span style=color:#f92672>.</span><span style=color:#a6e22e>withDescription</span><span style=color:#f92672>(</span>TOO_MANY_REQUESTS<span style=color:#f92672>),</span> <span style=color:#66d9ef>new</span> Metadata<span style=color:#f92672>());</span>
</span></span><span style=display:flex><span>        canInvoke <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 延迟执行调用 method.invoke() 直到 onHalfClose() 以确保客户端执行了半关闭
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>request</span> <span style=color:#f92672>=</span> request<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><h4 id=10-提交半关闭请求任务>10. 提交半关闭请求任务</h4><p>当执行完 <code>RequestRunnable</code> 任务完成时，会调用 <code>MessageDeframer#close</code> 方法关闭帧</p><ul><li>io.grpc.internal.MessageDeframer#close</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>close</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>isClosed<span style=color:#f92672>())</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>return</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>boolean</span> hasPartialMessage <span style=color:#f92672>=</span> nextFrame <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span> <span style=color:#f92672>&amp;&amp;</span> nextFrame<span style=color:#f92672>.</span><span style=color:#a6e22e>readableBytes</span><span style=color:#f92672>()</span> <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>try</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>fullStreamDecompressor <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        hasPartialMessage <span style=color:#f92672>=</span> hasPartialMessage <span style=color:#f92672>||</span> fullStreamDecompressor<span style=color:#f92672>.</span><span style=color:#a6e22e>hasPartialData</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>        fullStreamDecompressor<span style=color:#f92672>.</span><span style=color:#a6e22e>close</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>unprocessed <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        unprocessed<span style=color:#f92672>.</span><span style=color:#a6e22e>close</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>nextFrame <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        nextFrame<span style=color:#f92672>.</span><span style=color:#a6e22e>close</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span> <span style=color:#66d9ef>finally</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>      fullStreamDecompressor <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>      unprocessed <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>      nextFrame <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>    listener<span style=color:#f92672>.</span><span style=color:#a6e22e>deframerClosed</span><span style=color:#f92672>(</span>hasPartialMessage<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>}</span>
</span></span></code></pre></div><ul><li>io.grpc.internal.AbstractServerStream.TransportState#deframerClosed</li></ul><p>会执行关闭帧，然后调用 Stream 的监听器，通知半关闭</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>deframerClosed</span><span style=color:#f92672>(</span><span style=color:#66d9ef>boolean</span> hasPartialMessage<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    deframerClosed <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 是否到达流结尾
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>endOfStream<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 如果不需要立即关闭，且有未完成的消息，返回错误并抛出异常
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> <span style=color:#f92672>(!</span>immediateCloseRequested <span style=color:#f92672>&amp;&amp;</span> hasPartialMessage<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            deframeFailed<span style=color:#f92672>(</span>Status<span style=color:#f92672>.</span><span style=color:#a6e22e>INTERNAL</span><span style=color:#f92672>.</span><span style=color:#a6e22e>withDescription</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;Encountered end-of-stream mid-frame&#34;</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>                                         <span style=color:#f92672>.</span><span style=color:#a6e22e>asRuntimeException</span><span style=color:#f92672>());</span>
</span></span><span style=display:flex><span>            deframerClosedTask <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 通知半关闭
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        listener<span style=color:#f92672>.</span><span style=color:#a6e22e>halfClosed</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 如果有解帧器关闭的任务，则执行
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>deframerClosedTask <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        deframerClosedTask<span style=color:#f92672>.</span><span style=color:#a6e22e>run</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>        deframerClosedTask <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><ul><li>io.grpc.internal.ServerImpl.JumpToApplicationThreadServerStreamListener#halfClosed</li></ul><p>提交半关闭任务</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>halfClosed</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>try</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        callExecutor<span style=color:#f92672>.</span><span style=color:#a6e22e>execute</span><span style=color:#f92672>(</span><span style=color:#66d9ef>new</span> HalfClosed<span style=color:#f92672>());</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span> 
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><h4 id=11-执行半关闭任务>11. 执行半关闭任务</h4><ul><li>io.grpc.internal.ServerImpl.JumpToApplicationThreadServerStreamListener#halfClosed</li></ul><p>执行半关闭任务</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>    <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>HalfClosed</span> <span style=color:#66d9ef>extends</span> ContextRunnable <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        HalfClosed<span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>super</span><span style=color:#f92672>(</span>context<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>runInContext</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>try</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 调用监听器的半关闭事件
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                getListener<span style=color:#f92672>().</span><span style=color:#a6e22e>halfClosed</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>}</span> <span style=color:#66d9ef>catch</span> <span style=color:#f92672>(</span>Throwable t<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                internalClose<span style=color:#f92672>(</span>t<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>throw</span> t<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span></code></pre></div><ul><li>io.grpc.stub.ServerCalls.UnaryServerCallHandler.UnaryServerCallListener#onHalfClose</li></ul><p>最终在监听器中调用相应的方法处理器，处理请求，并冻结响应；还会再次调用 <code>onReady</code> 事件，如果有 <code>onReadyHandler</code> 会执行</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>onHalfClose</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 如果不能调用则直接返回
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> <span style=color:#f92672>(!</span>canInvoke<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 如果请求是 null，则返回错我
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>request <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        call<span style=color:#f92672>.</span><span style=color:#a6e22e>close</span><span style=color:#f92672>(</span>Status<span style=color:#f92672>.</span><span style=color:#a6e22e>INTERNAL</span><span style=color:#f92672>.</span><span style=color:#a6e22e>withDescription</span><span style=color:#f92672>(</span>MISSING_REQUEST<span style=color:#f92672>),</span> <span style=color:#66d9ef>new</span> Metadata<span style=color:#f92672>());</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 执行方法调用
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    method<span style=color:#f92672>.</span><span style=color:#a6e22e>invoke</span><span style=color:#f92672>(</span>request<span style=color:#f92672>,</span> responseObserver<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 处理了请求之后将请求置为 null
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    request <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 冻结响应
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    responseObserver<span style=color:#f92672>.</span><span style=color:#a6e22e>freeze</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 判断是否 ready
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>wasReady<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 因为在 halfClose 中调用，错过了来自 Transport 的 onReady 事件，从这里恢复
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// 即在 ready 之后用于执行 onReadyHandler
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        onReady<span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><ul><li>io.github.helloworlde.HelloServiceGrpc.MethodHandlers#invoke(Req, io.grpc.stub.StreamObserver)</li></ul><p>处理请求，这部分是生成的代码，会调用相应的实例，处理请求，并将响应内容通过 StreamObserver 发送出去</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>invoke</span><span style=color:#f92672>(</span>Req request<span style=color:#f92672>,</span> io<span style=color:#f92672>.</span><span style=color:#a6e22e>grpc</span><span style=color:#f92672>.</span><span style=color:#a6e22e>stub</span><span style=color:#f92672>.</span><span style=color:#a6e22e>StreamObserver</span><span style=color:#f92672>&lt;</span>Resp<span style=color:#f92672>&gt;</span> responseObserver<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>switch</span> <span style=color:#f92672>(</span>methodId<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>case</span> METHODID_HOW_ARE_YOU<span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>            serviceImpl<span style=color:#f92672>.</span><span style=color:#a6e22e>howAreYou</span><span style=color:#f92672>((</span>io<span style=color:#f92672>.</span><span style=color:#a6e22e>github</span><span style=color:#f92672>.</span><span style=color:#a6e22e>helloworlde</span><span style=color:#f92672>.</span><span style=color:#a6e22e>HelloMessage</span><span style=color:#f92672>)</span> request<span style=color:#f92672>,</span>
</span></span><span style=display:flex><span>                    <span style=color:#f92672>(</span>io<span style=color:#f92672>.</span><span style=color:#a6e22e>grpc</span><span style=color:#f92672>.</span><span style=color:#a6e22e>stub</span><span style=color:#f92672>.</span><span style=color:#a6e22e>StreamObserver</span><span style=color:#f92672>&lt;</span>io<span style=color:#f92672>.</span><span style=color:#a6e22e>github</span><span style=color:#f92672>.</span><span style=color:#a6e22e>helloworlde</span><span style=color:#f92672>.</span><span style=color:#a6e22e>HelloResponse</span><span style=color:#f92672>&gt;)</span> responseObserver<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>break</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>default</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> AssertionError<span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><h2 id=处理响应>处理响应</h2><h3 id=1-执行业务逻辑处理>1. 执行业务逻辑处理</h3><ul><li>io.github.helloworlde.service.HelloServiceImpl#howAreYou</li></ul><p>需要实现生成的接口，在方法中实现逻辑，并将响应通过 <code>StreamObserver</code> 发送出去</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>howAreYou</span><span style=color:#f92672>(</span>HelloMessage request<span style=color:#f92672>,</span> StreamObserver<span style=color:#f92672>&lt;</span>HelloResponse<span style=color:#f92672>&gt;</span> responseObserver<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    responseObserver<span style=color:#f92672>.</span><span style=color:#a6e22e>onNext</span><span style=color:#f92672>(</span>HelloResponse<span style=color:#f92672>.</span><span style=color:#a6e22e>newBuilder</span><span style=color:#f92672>().</span><span style=color:#a6e22e>setResult</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;Hello : &#34;</span> <span style=color:#f92672>+</span> request<span style=color:#f92672>.</span><span style=color:#a6e22e>getMessage</span><span style=color:#f92672>()).</span><span style=color:#a6e22e>build</span><span style=color:#f92672>());</span>
</span></span><span style=display:flex><span>    responseObserver<span style=color:#f92672>.</span><span style=color:#a6e22e>onCompleted</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><h3 id=2-发送响应内容>2. 发送响应内容</h3><ul><li>io.grpc.stub.ServerCalls.ServerCallStreamObserverImpl#onNext</li></ul><p>发送单个响应时，会先检查请求是否取消了，如果已经取消了，则会抛出错误；接着检查请求的状态，如果是已经丢弃或者完成，也会抛出异常</p><p>然后会检查是否发送了 header，如果没有发送，则会先发送 header；发送 header 完成后会发送消息</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>onNext</span><span style=color:#f92672>(</span>RespT response<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 如果已经被取消调用了，则判断是否有取消回调，如果没有则返回取消状态
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>cancelled<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>onCancelHandler <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>throw</span> Status<span style=color:#f92672>.</span><span style=color:#a6e22e>CANCELLED</span><span style=color:#f92672>.</span><span style=color:#a6e22e>withDescription</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;call already cancelled&#34;</span><span style=color:#f92672>).</span><span style=color:#a6e22e>asRuntimeException</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 检查是否已经丢弃或者完成
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    checkState<span style=color:#f92672>(!</span>aborted<span style=color:#f92672>,</span> <span style=color:#e6db74>&#34;Stream was terminated by error, no further calls are allowed&#34;</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>    checkState<span style=color:#f92672>(!</span>completed<span style=color:#f92672>,</span> <span style=color:#e6db74>&#34;Stream is already completed, no further calls are allowed&#34;</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 如果还没有发送 header，则发送 header
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> <span style=color:#f92672>(!</span>sentHeaders<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        call<span style=color:#f92672>.</span><span style=color:#a6e22e>sendHeaders</span><span style=color:#f92672>(</span><span style=color:#66d9ef>new</span> Metadata<span style=color:#f92672>());</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 将发送 header 设置为 true
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        sentHeaders <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 然后发送响应
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    call<span style=color:#f92672>.</span><span style=color:#a6e22e>sendMessage</span><span style=color:#f92672>(</span>response<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><h4 id=1-发送响应-header>1. 发送响应 header</h4><ul><li>io.grpc.internal.ServerCallImpl#sendHeadersInternal</li></ul><p>设置 header 内容，发送 header</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>sendHeadersInternal</span><span style=color:#f92672>(</span>Metadata headers<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 丢弃编码的 key
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        headers<span style=color:#f92672>.</span><span style=color:#a6e22e>discardAll</span><span style=color:#f92672>(</span>MESSAGE_ENCODING_KEY<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 设置压缩器类型
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        headers<span style=color:#f92672>.</span><span style=color:#a6e22e>put</span><span style=color:#f92672>(</span>MESSAGE_ENCODING_KEY<span style=color:#f92672>,</span> compressor<span style=color:#f92672>.</span><span style=color:#a6e22e>getMessageEncoding</span><span style=color:#f92672>());</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 为流设置压缩器
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        stream<span style=color:#f92672>.</span><span style=color:#a6e22e>setCompressor</span><span style=color:#f92672>(</span>compressor<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 丢弃消息编码的 key
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        headers<span style=color:#f92672>.</span><span style=color:#a6e22e>discardAll</span><span style=color:#f92672>(</span>MESSAGE_ACCEPT_ENCODING_KEY<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>advertisedEncodings<span style=color:#f92672>.</span><span style=color:#a6e22e>length</span> <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            headers<span style=color:#f92672>.</span><span style=color:#a6e22e>put</span><span style=color:#f92672>(</span>MESSAGE_ACCEPT_ENCODING_KEY<span style=color:#f92672>,</span> advertisedEncodings<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 将调用 header 状态改为 true
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        sendHeadersCalled <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>        stream<span style=color:#f92672>.</span><span style=color:#a6e22e>writeHeaders</span><span style=color:#f92672>(</span>headers<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span></code></pre></div><ul><li>io.grpc.internal.AbstractServerStream#writeHeaders</li></ul><p>将 header 内容写入帧中，会调用 Netty 相关的方法发送内容</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>writeHeaders</span><span style=color:#f92672>(</span>Metadata headers<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    Preconditions<span style=color:#f92672>.</span><span style=color:#a6e22e>checkNotNull</span><span style=color:#f92672>(</span>headers<span style=color:#f92672>,</span> <span style=color:#e6db74>&#34;headers&#34;</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    headersSent <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    abstractServerStreamSink<span style=color:#f92672>().</span><span style=color:#a6e22e>writeHeaders</span><span style=color:#f92672>(</span>headers<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><h4 id=2-发送响应内容-1>2. 发送响应内容</h4><ul><li>io.grpc.internal.ServerCallImpl#sendMessageInternal</li></ul><p>发送响应内容，会先检查是否已经发送了 header，且请求没有关闭，且响应的状态正确
如果都没有问题，则将响应内容序列化为流，然后发送并清空缓冲区</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>sendMessageInternal</span><span style=color:#f92672>(</span>RespT message<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 检查是否已经发送了 header，和调用是否已经被关闭
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    checkState<span style=color:#f92672>(</span>sendHeadersCalled<span style=color:#f92672>,</span> <span style=color:#e6db74>&#34;sendHeaders has not been called&#34;</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>    checkState<span style=color:#f92672>(!</span>closeCalled<span style=color:#f92672>,</span> <span style=color:#e6db74>&#34;call is closed&#34;</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 如果是 UNARY 或者 CLIENT_STREAMING 类型的消息，且已经发送过消息了，则不允许再发送，返回错误状态
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>method<span style=color:#f92672>.</span><span style=color:#a6e22e>getType</span><span style=color:#f92672>().</span><span style=color:#a6e22e>serverSendsOneMessage</span><span style=color:#f92672>()</span> <span style=color:#f92672>&amp;&amp;</span> messageSent<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        internalClose<span style=color:#f92672>(</span>Status<span style=color:#f92672>.</span><span style=color:#a6e22e>INTERNAL</span><span style=color:#f92672>.</span><span style=color:#a6e22e>withDescription</span><span style=color:#f92672>(</span>TOO_MANY_RESPONSES<span style=color:#f92672>));</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 将发送消息状态改为 true
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    messageSent <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>try</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 将消息序列化为流，写入消息，清空流
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        InputStream resp <span style=color:#f92672>=</span> method<span style=color:#f92672>.</span><span style=color:#a6e22e>streamResponse</span><span style=color:#f92672>(</span>message<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        stream<span style=color:#f92672>.</span><span style=color:#a6e22e>writeMessage</span><span style=color:#f92672>(</span>resp<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        stream<span style=color:#f92672>.</span><span style=color:#a6e22e>flush</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span> <span style=color:#66d9ef>catch</span> <span style=color:#f92672>(</span>RuntimeException e<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        close<span style=color:#f92672>(</span>Status<span style=color:#f92672>.</span><span style=color:#a6e22e>fromThrowable</span><span style=color:#f92672>(</span>e<span style=color:#f92672>),</span> <span style=color:#66d9ef>new</span> Metadata<span style=color:#f92672>());</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span> <span style=color:#66d9ef>catch</span> <span style=color:#f92672>(</span>Error e<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        close<span style=color:#f92672>(</span>Status<span style=color:#f92672>.</span><span style=color:#a6e22e>CANCELLED</span><span style=color:#f92672>.</span><span style=color:#a6e22e>withDescription</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;Server sendMessage() failed with Error&#34;</span><span style=color:#f92672>),</span> <span style=color:#66d9ef>new</span> Metadata<span style=color:#f92672>());</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>throw</span> e<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><ul><li>io.grpc.internal.AbstractStream#writeMessage</li></ul><p>检查帧的状态，如果帧没有关闭，则将流的内容写入帧中，并关闭流
最终消息内容通过 Netty 的相关方法发送给客户端</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>writeMessage</span><span style=color:#f92672>(</span>InputStream message<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    checkNotNull<span style=color:#f92672>(</span>message<span style=color:#f92672>,</span> <span style=color:#e6db74>&#34;message&#34;</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>try</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#f92672>(!</span>framer<span style=color:#f92672>().</span><span style=color:#a6e22e>isClosed</span><span style=color:#f92672>())</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 写入消息体
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            framer<span style=color:#f92672>().</span><span style=color:#a6e22e>writePayload</span><span style=color:#f92672>(</span>message<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span> <span style=color:#66d9ef>finally</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        GrpcUtil<span style=color:#f92672>.</span><span style=color:#a6e22e>closeQuietly</span><span style=color:#f92672>(</span>message<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><ul><li>io.grpc.internal.AbstractStream#flush</li></ul><p>清空帧的缓冲，将所有内容都发送给客户端</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>flush</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 如果帧还没有关闭，则清空帧
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> <span style=color:#f92672>(!</span>framer<span style=color:#f92672>().</span><span style=color:#a6e22e>isClosed</span><span style=color:#f92672>())</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        framer<span style=color:#f92672>().</span><span style=color:#a6e22e>flush</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><h3 id=3-完成请求>3. 完成请求</h3><p>当调用 <code>responseObserver.onCompleted</code> 后，会开始处理请求完成的逻辑</p><ul><li>io.grpc.stub.ServerCalls.ServerCallStreamObserverImpl#onCompleted</li></ul><p>会先检查请求的状态，如果已经被取消了，且没有取消处理任务，则直接抛出取消状态的异常
如果请求正常完成，会使用 OK 状态关闭情趣，修改请求状态为完成</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>onCompleted</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 如果已经被取消，则返回取消的状态
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>cancelled<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>onCancelHandler <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>throw</span> Status<span style=color:#f92672>.</span><span style=color:#a6e22e>CANCELLED</span><span style=color:#f92672>.</span><span style=color:#a6e22e>withDescription</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;call already cancelled&#34;</span><span style=color:#f92672>).</span><span style=color:#a6e22e>asRuntimeException</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span> <span style=color:#66d9ef>else</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 通知请求完成
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        call<span style=color:#f92672>.</span><span style=color:#a6e22e>close</span><span style=color:#f92672>(</span>Status<span style=color:#f92672>.</span><span style=color:#a6e22e>OK</span><span style=color:#f92672>,</span> <span style=color:#66d9ef>new</span> Metadata<span style=color:#f92672>());</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 将完成状态改为 true
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        completed <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><ul><li>io.grpc.internal.ServerCallImpl#closeInternal</li></ul><p>使用指定的状态和响应元数据关闭请求
如果没有发送响应，则会取消请求，并返回 INTERNAL 状态的错误；如果请求正常完成，则调用流关闭的接口，完成请求</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>closeInternal</span><span style=color:#f92672>(</span>Status status<span style=color:#f92672>,</span> Metadata trailers<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 检查是否已经关闭
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    checkState<span style=color:#f92672>(!</span>closeCalled<span style=color:#f92672>,</span> <span style=color:#e6db74>&#34;call already closed&#34;</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>try</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 将关闭状态改为 true
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        closeCalled <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 检查状态如果是 OK，且方法类型是 Server 端只能发送一次，且没有发送消息，则返回错误
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>status<span style=color:#f92672>.</span><span style=color:#a6e22e>isOk</span><span style=color:#f92672>()</span> <span style=color:#f92672>&amp;&amp;</span> method<span style=color:#f92672>.</span><span style=color:#a6e22e>getType</span><span style=color:#f92672>().</span><span style=color:#a6e22e>serverSendsOneMessage</span><span style=color:#f92672>()</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#f92672>!</span>messageSent<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            internalClose<span style=color:#f92672>(</span>Status<span style=color:#f92672>.</span><span style=color:#a6e22e>INTERNAL</span><span style=color:#f92672>.</span><span style=color:#a6e22e>withDescription</span><span style=color:#f92672>(</span>MISSING_RESPONSE<span style=color:#f92672>));</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 关闭流
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        stream<span style=color:#f92672>.</span><span style=color:#a6e22e>close</span><span style=color:#f92672>(</span>status<span style=color:#f92672>,</span> trailers<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span> <span style=color:#66d9ef>finally</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 统计结果
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        serverCallTracer<span style=color:#f92672>.</span><span style=color:#a6e22e>reportCallEnded</span><span style=color:#f92672>(</span>status<span style=color:#f92672>.</span><span style=color:#a6e22e>isOk</span><span style=color:#f92672>());</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><ul><li>io.grpc.internal.AbstractServerStream#close</li></ul><p>关闭流，将响应的 header 写入到帧中；最终通过 Netty 的方法将响应发送给客户端</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>close</span><span style=color:#f92672>(</span>Status status<span style=color:#f92672>,</span> Metadata trailers<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 如果出站的流还未关闭，则将状态改为关闭
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> <span style=color:#f92672>(!</span>outboundClosed<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        outboundClosed <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 从服务端关闭 framer
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        endOfMessages<span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 将响应状态加入到 header 中
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        addStatusToTrailers<span style=color:#f92672>(</span>trailers<span style=color:#f92672>,</span> status<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 安全设置，无需同步，因为访问被严格控制，只有这里设置关闭状态，保证在这里之后读取
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// 给 Transport 设置响应状态
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        transportState<span style=color:#f92672>().</span><span style=color:#a6e22e>setClosedStatus</span><span style=color:#f92672>(</span>status<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 将响应的 header 信息写入帧中
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        abstractServerStreamSink<span style=color:#f92672>().</span><span style=color:#a6e22e>writeTrailers</span><span style=color:#f92672>(</span>trailers<span style=color:#f92672>,</span> headersSent<span style=color:#f92672>,</span> status<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><ul><li>io.grpc.internal.AbstractStream#endOfMessages</li></ul><p>关闭帧</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>endOfMessages</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    framer<span style=color:#f92672>().</span><span style=color:#a6e22e>close</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><h4 id=1-发送响应结尾-header>1. 发送响应结尾 header</h4><p>在关闭流时，会将相应的状态和其他 header 发送给客户端</p><ul><li>io.grpc.internal.AbstractServerStream#close</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>abstractServerStreamSink<span style=color:#f92672>().</span><span style=color:#a6e22e>writeTrailers</span><span style=color:#f92672>(</span>trailers<span style=color:#f92672>,</span> headersSent<span style=color:#f92672>,</span> status<span style=color:#f92672>);</span>
</span></span></code></pre></div><ul><li>io.grpc.netty.NettyServerStream.Sink#writeTrailers</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>writeTrailers</span><span style=color:#f92672>(</span>Metadata trailers<span style=color:#f92672>,</span> <span style=color:#66d9ef>boolean</span> headersSent<span style=color:#f92672>,</span> Status status<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>try</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        Http2Headers http2Trailers <span style=color:#f92672>=</span> Utils<span style=color:#f92672>.</span><span style=color:#a6e22e>convertTrailers</span><span style=color:#f92672>(</span>trailers<span style=color:#f92672>,</span> headersSent<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 将发送 header 的指令写入到队列中
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        writeQueue<span style=color:#f92672>.</span><span style=color:#a6e22e>enqueue</span><span style=color:#f92672>(</span>SendResponseHeadersCommand<span style=color:#f92672>.</span><span style=color:#a6e22e>createTrailers</span><span style=color:#f92672>(</span>transportState<span style=color:#f92672>(),</span> http2Trailers<span style=color:#f92672>,</span> status<span style=color:#f92672>),</span> <span style=color:#66d9ef>true</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><h4 id=2-提交关闭任务>2. 提交关闭任务</h4><p>当发送完响应 Header 和 body 时，会因为已经到达帧末尾，调用<code>closeStreamWhenDone</code> 方法进行关闭</p><ul><li>io.grpc.netty.shaded.io.grpc.netty.NettyServerHandler#closeStreamWhenDone</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>closeStreamWhenDone</span><span style=color:#f92672>(</span>ChannelPromise promise<span style=color:#f92672>,</span> <span style=color:#66d9ef>int</span> streamId<span style=color:#f92672>)</span> <span style=color:#66d9ef>throws</span> Http2Exception <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>final</span> TransportState stream <span style=color:#f92672>=</span> <span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>serverStream</span><span style=color:#f92672>(</span><span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>requireHttp2Stream</span><span style=color:#f92672>(</span>streamId<span style=color:#f92672>));</span>
</span></span><span style=display:flex><span>    promise<span style=color:#f92672>.</span><span style=color:#a6e22e>addListener</span><span style=color:#f92672>(</span><span style=color:#66d9ef>new</span> ChannelFutureListener<span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>operationComplete</span><span style=color:#f92672>(</span>ChannelFuture future<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            stream<span style=color:#f92672>.</span><span style=color:#a6e22e>complete</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>});</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><ul><li>io.grpc.internal.AbstractServerStream.TransportState#complete</li></ul><p>然后调用流的完成事件，关闭监听器</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>complete</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 如果解帧器已经关闭了，则关闭监听器
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>deframerClosed<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        deframerClosedTask <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>        closeListener<span style=color:#f92672>(</span>Status<span style=color:#f92672>.</span><span style=color:#a6e22e>OK</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span> <span style=color:#66d9ef>else</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 如果还未关闭，则创建关闭监听器任务，并立即关闭解帧器
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        deframerClosedTask <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Runnable<span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>run</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                closeListener<span style=color:#f92672>(</span>Status<span style=color:#f92672>.</span><span style=color:#a6e22e>OK</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>};</span>
</span></span><span style=display:flex><span>        immediateCloseRequested <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>        closeDeframer<span style=color:#f92672>(</span><span style=color:#66d9ef>true</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><ul><li>io.grpc.internal.ServerImpl.JumpToApplicationThreadServerStreamListener#closedInternal
提交流关闭任务<code>Closed</code></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>closedInternal</span><span style=color:#f92672>(</span><span style=color:#66d9ef>final</span> Status status<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 如果状态不是 OK，则直接提交关闭 Context 任务
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> <span style=color:#f92672>(!</span>status<span style=color:#f92672>.</span><span style=color:#a6e22e>isOk</span><span style=color:#f92672>())</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        cancelExecutor<span style=color:#f92672>.</span><span style=color:#a6e22e>execute</span><span style=color:#f92672>(</span><span style=color:#66d9ef>new</span> ContextCloser<span style=color:#f92672>(</span>context<span style=color:#f92672>,</span> status<span style=color:#f92672>.</span><span style=color:#a6e22e>getCause</span><span style=color:#f92672>()));</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Closed</span> <span style=color:#66d9ef>extends</span> ContextRunnable <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        Closed<span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>super</span><span style=color:#f92672>(</span>context<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>runInContext</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            PerfMark<span style=color:#f92672>.</span><span style=color:#a6e22e>startTask</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;ServerCallListener(app).closed&#34;</span><span style=color:#f92672>,</span> tag<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>            PerfMark<span style=color:#f92672>.</span><span style=color:#a6e22e>linkIn</span><span style=color:#f92672>(</span>link<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>try</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 调用监听器的关闭事件
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                getListener<span style=color:#f92672>().</span><span style=color:#a6e22e>closed</span><span style=color:#f92672>(</span>status<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>}</span> <span style=color:#66d9ef>finally</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                PerfMark<span style=color:#f92672>.</span><span style=color:#a6e22e>stopTask</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;ServerCallListener(app).closed&#34;</span><span style=color:#f92672>,</span> tag<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    callExecutor<span style=color:#f92672>.</span><span style=color:#a6e22e>execute</span><span style=color:#f92672>(</span><span style=color:#66d9ef>new</span> Closed<span style=color:#f92672>());</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><h4 id=3-执行关闭任务>3. 执行关闭任务</h4><p>执行 <code>Closed</code> 任务</p><p>io.grpc.internal.ServerImpl.JumpToApplicationThreadServerStreamListener#closed$Closed</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>final</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Closed</span> <span style=color:#66d9ef>extends</span> ContextRunnable <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>runInContext</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>try</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 调用监听器的关闭事件
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            getListener<span style=color:#f92672>().</span><span style=color:#a6e22e>closed</span><span style=color:#f92672>(</span>status<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span> 
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><ul><li>io.grpc.internal.ServerCallImpl.ServerStreamListenerImpl#closedInternal</li></ul><p>根据状态通知流监听器完成或者取消，最终取消上下文</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>closedInternal</span><span style=color:#f92672>(</span>Status status<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>try</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 如果状态是 OK，通知监听器完成
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>status<span style=color:#f92672>.</span><span style=color:#a6e22e>isOk</span><span style=color:#f92672>())</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            listener<span style=color:#f92672>.</span><span style=color:#a6e22e>onComplete</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span> <span style=color:#66d9ef>else</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 否则将状态改为取消，通知监听器取消
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            call<span style=color:#f92672>.</span><span style=color:#a6e22e>cancelled</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>            listener<span style=color:#f92672>.</span><span style=color:#a6e22e>onCancel</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span> <span style=color:#66d9ef>finally</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 取消上下文
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        context<span style=color:#f92672>.</span><span style=color:#a6e22e>cancel</span><span style=color:#f92672>(</span><span style=color:#66d9ef>null</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><ul><li>io.grpc.Context.CancellableContext#cancel
取消上下文，取消所有的超时时间任务</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>cancel</span><span style=color:#f92672>(</span>Throwable cause<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>boolean</span> triggeredCancel <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>synchronized</span> <span style=color:#f92672>(</span><span style=color:#66d9ef>this</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 如果没有取消，则取消，并修改状态
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> <span style=color:#f92672>(!</span>cancelled<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            cancelled <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 如果有等待取消的任务，则取消
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>pendingDeadline <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                pendingDeadline<span style=color:#f92672>.</span><span style=color:#a6e22e>cancel</span><span style=color:#f92672>(</span><span style=color:#66d9ef>false</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>                pendingDeadline <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>cancellationCause</span> <span style=color:#f92672>=</span> cause<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>            triggeredCancel <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 如果取消成功了，则通知监听器
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>triggeredCancel<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        notifyAndClearListeners<span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> triggeredCancel<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div></section><div class=paginator><a class=prev href=https://blog.hellowood.dev/posts/grpc-%E4%B8%AD%E7%9B%91%E5%90%AC-sream-%E5%92%8C-transport-%E7%9A%84%E4%BA%8B%E4%BB%B6/><span>&larr;&nbsp;&nbsp;</span><span>gRPC 中监听 Sream 和 Transport 的事件</span></a>
<a class=next href=https://blog.hellowood.dev/posts/grpc-server-%E7%AB%AF%E5%85%B3%E9%97%AD%E6%B5%81%E7%A8%8B/><span>gRPC Server 端关闭流程</span><span>&nbsp;&nbsp;&rarr;</span></a></div></article></div><footer class=footer><p>&copy; 2023 <a href=https://blog.hellowood.dev>HelloWood</a>
Powered by
<a href=https://gohugo.io/ rel=noopener target=_blank>Hugo️️</a>
<a href=https://github.com/guangzhengli/hugo-theme-ladder rel=noopener target=_blank>Ladder</a>
️</p></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-up"><line x1="12" y1="19" x2="12" y2="5"/><polyline points="5 12 12 5 19 12"/></svg></a><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const s=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="Copy";function n(){t.innerHTML="Copied",setTimeout(()=>{t.innerHTML="Copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),n();return}const s=document.createRange();s.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(s);try{document.execCommand("copy"),n()}catch{}o.removeRange(s)}),e.parentNode.appendChild(t)})</script></main></body><script src=https://cdnjs.cloudflare.com/ajax/libs/medium-zoom/1.0.6/medium-zoom.min.js integrity="sha512-N9IJRoc3LaP3NDoiGkcPa4gG94kapGpaA5Zq9/Dr04uf5TbLFU5q0o8AbRhLKUUlp8QFS2u7S+Yti0U7QtuZvQ==" crossorigin=anonymous referrerpolicy=no-referrer></script>
<script>const images=Array.from(document.querySelectorAll(".blog-content img"));images.forEach(e=>{mediumZoom(e,{margin:10,scrollOffset:40,container:null,template:null,background:"rgba(0, 0, 0, 0.5)"})})</script><script src=/main.min.6bb26b69159420159c74dc9e097b06a578ed2b68c701466a91a44a9632d851bd0af167a1b30012387b4c512b48ad9ad4d3394e04d77ae38d57e1920fe4ed34fe.js integrity="sha512-a7JraRWUIBWcdNyeCXsGpXjtK2jHAUZqkaRKljLYUb0K8WehswASOHtMUStIrZrU0zlOBNd6441X4ZIP5O00/g==" crossorigin=anonymous defer></script></html>