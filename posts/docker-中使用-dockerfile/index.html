<!doctype html><html lang=en><head><meta name=viewport content="width=device-width,initial-scale=1"><title>Docker 中使用 Dockerfile</title>
<meta charset=utf-8><meta name=description content='Ladder@Docker 中使用 Dockerfile Dockerfile 是一个文件，其包含了一条条的指令（instruction），每一条指令构建一层，因此每一条指令的内容就是描述该层应当如何构建
构建一个镜像 FROM nginx RUN echo &#39;<h1>Hello, Docker!</h1>&#39; > /usr/share/nginx/html/index.html 构建 命令 FROM 用于指定基础镜像，必备的指令，必须是第一条
FROM scratch scratch是一个特殊的镜像，表示一个空白的镜像，意味着不以任何镜像为基础，接下来的指令作为第一层 RUN RUN 指令是用来执行命令的，格式有两种：
shell 格式：RUN <命令> RUN echo &#39;<h1>Hello, Docker!</h1>&#39; > /usr/share/nginx/html/index.html exec格式：RUN ["可执行文件", "参数1", "参数2"] 每一个 RUN 命令都会构建一层，应当减少不必要的构建
FROM debian:jessie RUN apt-get update RUN apt-get install -y gcc libc6-dev make RUN wget -O redis.tar.gz "http://download.redis.io/releases/redis-3.2.5.tar.gz" RUN mkdir -p /usr/src/redis RUN tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1 RUN make -C /usr/src/redis RUN make -C /usr/src/redis install 这样会构建7层，会提交大量的无用的改动，应当改为：'><meta name=author content="HelloWood"><link rel=canonical href=https://blog.hellowood.dev/posts/docker-%E4%B8%AD%E4%BD%BF%E7%94%A8-dockerfile/><meta name=google-site-verification content="G-3MSGPYTHPZ"><link rel=alternate type=application/rss+xml href=https://blog.hellowood.dev//index.xml title=HelloWood><script async src="https://www.googletagmanager.com/gtag/js?id=G-3MSGPYTHPZ"></script><script>var doNotTrack=!1,dnt;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-3MSGPYTHPZ")}</script><script async defer data-website-id=7a9034de-0ce7-4756-942a-829e6cd22301 src=https://umami.hellowood.dev/script.js></script><script defer data-cf-beacon='{"token": "b2e481d136dc428c8c96c8673e2a04cf"}' src=https://static.cloudflareinsights.com/beacon.min.js></script><meta property="og:url" content="https://blog.hellowood.dev/posts/docker-%E4%B8%AD%E4%BD%BF%E7%94%A8-dockerfile/"><meta property="og:site_name" content="HelloWood"><meta property="og:title" content="Docker 中使用 Dockerfile"><meta property="og:description" content="Docker 中使用 Dockerfile Dockerfile 是一个文件，其包含了一条条的指令（instruction），每一条指令构建一层，因此每一条指令的内容就是描述该层应当如何构建
构建一个镜像 FROM nginx RUN echo &amp;#39;&amp;lt;h1&amp;gt;Hello, Docker!&amp;lt;/h1&amp;gt;&amp;#39; &amp;gt; /usr/share/nginx/html/index.html 构建 命令 FROM 用于指定基础镜像，必备的指令，必须是第一条
FROM scratch scratch是一个特殊的镜像，表示一个空白的镜像，意味着不以任何镜像为基础，接下来的指令作为第一层 RUN RUN 指令是用来执行命令的，格式有两种：
shell 格式：RUN &amp;lt;命令&amp;gt; RUN echo &amp;#39;&amp;lt;h1&amp;gt;Hello, Docker!&amp;lt;/h1&amp;gt;&amp;#39; &amp;gt; /usr/share/nginx/html/index.html exec格式：RUN [&amp;quot;可执行文件&amp;quot;, &amp;quot;参数1&amp;quot;, &amp;quot;参数2&amp;quot;] 每一个 RUN 命令都会构建一层，应当减少不必要的构建
FROM debian:jessie RUN apt-get update RUN apt-get install -y gcc libc6-dev make RUN wget -O redis.tar.gz &amp;#34;http://download.redis.io/releases/redis-3.2.5.tar.gz&amp;#34; RUN mkdir -p /usr/src/redis RUN tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1 RUN make -C /usr/src/redis RUN make -C /usr/src/redis install 这样会构建7层，会提交大量的无用的改动，应当改为："><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2018-04-08T15:21:27+00:00"><meta property="article:modified_time" content="2018-04-08T15:21:27+00:00"><meta property="article:tag" content="Docker"><meta name=twitter:card content="summary"><meta name=twitter:title content="Docker 中使用 Dockerfile"><meta name=twitter:description content='Docker 中使用 Dockerfile Dockerfile 是一个文件，其包含了一条条的指令（instruction），每一条指令构建一层，因此每一条指令的内容就是描述该层应当如何构建
构建一个镜像 FROM nginx RUN echo &#39;<h1>Hello, Docker!</h1>&#39; > /usr/share/nginx/html/index.html 构建 命令 FROM 用于指定基础镜像，必备的指令，必须是第一条
FROM scratch scratch是一个特殊的镜像，表示一个空白的镜像，意味着不以任何镜像为基础，接下来的指令作为第一层 RUN RUN 指令是用来执行命令的，格式有两种：
shell 格式：RUN <命令> RUN echo &#39;<h1>Hello, Docker!</h1>&#39; > /usr/share/nginx/html/index.html exec格式：RUN ["可执行文件", "参数1", "参数2"] 每一个 RUN 命令都会构建一层，应当减少不必要的构建
FROM debian:jessie RUN apt-get update RUN apt-get install -y gcc libc6-dev make RUN wget -O redis.tar.gz "http://download.redis.io/releases/redis-3.2.5.tar.gz" RUN mkdir -p /usr/src/redis RUN tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1 RUN make -C /usr/src/redis RUN make -C /usr/src/redis install 这样会构建7层，会提交大量的无用的改动，应当改为：'><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.hellowood.dev/posts/"},{"@type":"ListItem","position":2,"name":"Docker 中使用 Dockerfile","item":"https://blog.hellowood.dev/posts/docker-%E4%B8%AD%E4%BD%BF%E7%94%A8-dockerfile/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Docker 中使用 Dockerfile","name":"Docker 中使用 Dockerfile","description":"Docker 中使用 Dockerfile Dockerfile 是一个文件，其包含了一条条的指令（instruction），每一条指令构建一层，因此每一条指令的内容就是描述该层应当如何构建\n构建一个镜像 FROM nginx RUN echo \u0026#39;\u0026lt;h1\u0026gt;Hello, Docker!\u0026lt;/h1\u0026gt;\u0026#39; \u0026gt; /usr/share/nginx/html/index.html 构建 命令 FROM 用于指定基础镜像，必备的指令，必须是第一条\nFROM scratch scratch是一个特殊的镜像，表示一个空白的镜像，意味着不以任何镜像为基础，接下来的指令作为第一层 RUN RUN 指令是用来执行命令的，格式有两种：\nshell 格式：RUN \u0026lt;命令\u0026gt; RUN echo \u0026#39;\u0026lt;h1\u0026gt;Hello, Docker!\u0026lt;/h1\u0026gt;\u0026#39; \u0026gt; /usr/share/nginx/html/index.html exec格式：RUN [\u0026quot;可执行文件\u0026quot;, \u0026quot;参数1\u0026quot;, \u0026quot;参数2\u0026quot;] 每一个 RUN 命令都会构建一层，应当减少不必要的构建\nFROM debian:jessie RUN apt-get update RUN apt-get install -y gcc libc6-dev make RUN wget -O redis.tar.gz \u0026#34;http://download.redis.io/releases/redis-3.2.5.tar.gz\u0026#34; RUN mkdir -p /usr/src/redis RUN tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1 RUN make -C /usr/src/redis RUN make -C /usr/src/redis install 这样会构建7层，会提交大量的无用的改动，应当改为：","keywords":["Docker"],"articleBody":"Docker 中使用 Dockerfile Dockerfile 是一个文件，其包含了一条条的指令（instruction），每一条指令构建一层，因此每一条指令的内容就是描述该层应当如何构建\n构建一个镜像 FROM nginx RUN echo 'Hello, Docker!' \u003e /usr/share/nginx/html/index.html 构建 命令 FROM 用于指定基础镜像，必备的指令，必须是第一条\nFROM scratch scratch是一个特殊的镜像，表示一个空白的镜像，意味着不以任何镜像为基础，接下来的指令作为第一层 RUN RUN 指令是用来执行命令的，格式有两种：\nshell 格式：RUN \u003c命令\u003e RUN echo 'Hello, Docker!' \u003e /usr/share/nginx/html/index.html exec格式：RUN [\"可执行文件\", \"参数1\", \"参数2\"] 每一个 RUN 命令都会构建一层，应当减少不必要的构建\nFROM debian:jessie RUN apt-get update RUN apt-get install -y gcc libc6-dev make RUN wget -O redis.tar.gz \"http://download.redis.io/releases/redis-3.2.5.tar.gz\" RUN mkdir -p /usr/src/redis RUN tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1 RUN make -C /usr/src/redis RUN make -C /usr/src/redis install 这样会构建7层，会提交大量的无用的改动，应当改为：\nFROM debian:jessie RUN buildDeps='gcc libc6-dev make' \\ \u0026\u0026 apt-get update \\ \u0026\u0026 apt-get install -y $buildDeps \\ \u0026\u0026 wget -O redis.tar.gz \"http://download.redis.io/releases/redis-3.2.5.tar.gz\" \\ \u0026\u0026 mkdir -p /usr/src/redis \\ \u0026\u0026 tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1 \\ \u0026\u0026 make -C /usr/src/redis \\ \u0026\u0026 make -C /usr/src/redis install \\ \u0026\u0026 rm -rf /var/lib/apt/lists/* \\ \u0026\u0026 rm redis.tar.gz \\ \u0026\u0026 rm -r /usr/src/redis \\ \u0026\u0026 apt-get purge -y --auto-remove $buildDeps Dockerfile 支持在 Shell 行尾添加 \\的命令换行方式，以及行首添加 # 进行注释\n执行构建 docker build -t myubuntu:v2 这样就能构建一个名为myubuntu, 标签为v2的镜像\n从 Git Repo 构建 docker build https://github.com/test/test.git#:test 这样就会在 git clone 之后就会切换到master分支，进入到 test目录执行构建\n用压缩包构建 docker build http://server/context.tar.gz COPY 用于将构建上下文目录中的源文件复制到新的一层镜像内的目标路径位置 格式：\nCOPY \u003c源路径\u003e ... \u003c目标路径\u003e COPY [\"\u003c源路径1\u003e\", \"\u003c目标路径\u003e\"] COPY package.json /usr/src/app/ COPY home* /mydir COPY home?.txt /mydir \u003c目标路径\u003e 可以是容器内的绝对路径，也可以是相对于工作目录的相对路径（工作路径可以通过WORKDIR 指定）\n使用COPY 指令，源文件的各种源数据都会被保留，比如读、写、执行权限。文件变更时间等\nADD 用于文件复制，和COPY一样，但是\u003c源路径\u003e可以是个URL，Docker 会将下载链接的文件放到\u003c目标路径\u003e中，文件权限为 600，如果\u003c源路径\u003e是一个 tar 文件，压缩格式为 gzip,bzip2,xz的情况下会自动解压该文件到\u003c目标路径\u003e\nADD ubuntu-xenial-core-cloudimg-amd64-root.tar.gz /usr/src/ CMD 容器启动命令，指令格式和RUN相似：\nshell格式：CMD \u003c命令\u003e exec格式：CMD [\"可执行文件\", \"参数1\", \"参数2\", ...]，这类格式在执行的时候会被解析为JSON格数组，因此需要用双引号 CMD echo $HOME CMD [\"sh\", \"-c\", \"echo $HOME\"] CMD nginx -g daemon off CMD [\"nginx\", \"-g\", \"daemon off\"] ENTRYPOINT ENTRYPOINT的格式和目的和CMD一样，都是在指定容器启动程序及参数，需要通过 docker run --entrypoint来指定；区别在于 ENTRYPOINT可以接收外部命令传入的参数作为内部命令的参数使用\n当指定了ENTRYPOINT后，CMD不再是直接的运行其命令，而是将CMD的内容作为参数传给ENTRYPOINT\n\"\" ENV 用于设置环境变量，格式有两种：\nENV ENV = = ENV NODE_VERSION 7.2.0 RUN echo $NODE_VERSION ENV可以在ADD,COPY,ENV, EXPOSE,LABEL,USER,WORKDIR, VOLUME,STOPSIGNAL, ONBUILD\nARG 构建参数，和ENV的效果一样，都是设置环境变量，但是ARG所设置的环境变量在容器运行时不存在 格式：ATG \u003c参数名\u003e[=\u003c默认值\u003e] 默认值可以通过docker build --build-arg \u003c参数名\u003e=\u003c值\u003e\nVOLUME 用于指定某些目录挂载为匿名卷，这样在运行时如果用户不指定挂载，其应用也可以正常运行，不会向容器存储层写入大量数据\n格式：\nVOLUME [\"\u003c路径1\u003e\",\"\u003c路径2\u003e\"] VOLUME \u003c路径\u003e VOLUME /data 运行时可以覆盖这个挂载设置：\ndocker run -d -v mydata:/data 这样就使用 mydata这个命名卷挂载到 /data这个位置，替代了在 Dockerfile中定义的匿名卷的挂载配置\nEXPOSE 用于声明运行时容器提供服务端口，仅仅是一个声明，并不会直接开启端口的服务，用于帮助使用者理解镜像服务的守护端口，同时用于在运行时使用端口随机映射docker run -P时使用EXPOSE配置的端口\nEXPOSE \u003c端口1\u003e [\u003c端口2\u003e ...] WORKDIR 用来指定工作目录（当前目录），以后各层的当前目录就被改为指定目录，如果目录不存在，会直接生成该目录\n格式为：WORKDIR \u003c工作目录路径\u003e\nUSER USER和WORKDIR相似，都是改变环境状态并影响以后的层，WORKDIR改变的是工作目录，USER改变之后执行RUN,CMD,ENTRYPOINT之类命令的身份，USER只是切换到指定用户，该用户必须事先建立好\n格式：USER \u003c用户名\u003e\nRUN groupadd -r redis \u0026\u0026 useradd -r -g redis redis USER redis RUN ['redis-server'] HEALTHCHECK 用来告诉 Docker 如何判断容器的状态是否正常 格式：\nHEALTHCHECK [选项] CMD \u003c命令\u003e：设置检查容器健康状况的命令 HEALTHCHECK NONE：如果基础镜像有健康检查指令，使用该命令可以屏蔽 HEALTHCHECK支持下列选项：\n--interval=\u003c间隔\u003e：两次健康检查的间隔，默认为30s timeout=\u003c时长\u003e：健康检查命令运行超时时间，如果超过这个时间则被认为此次健康检查失败 --retries=\u003c时长\u003e：当连续失败指定次数后，则将容器状态视为unhealthy，默认3次 HEALTHCHECK只可以出现一次，如果写了多个，则只有最后一个生效； 在HEALTHCHECK [选项] CMD 后面的命令，格式和ENTRYPOINT一样，分为 shell和exec格式，命令的返回值决定了改次检查的成功与否，0:成功，1:失败，2: 保留\n检查web服务是否可用：\nFROM nginx RUN apt-get update \u0026\u0026 apt-get install -y curl \u0026\u0026 rm -rf /var/lib/apt/lists/* HEALTHCHECK --interval=5s --timeout=3s \\ CMD curl -fs http://localhost/ || exit 1 构建并启动该容器，查看其状态：\ndocker build -t myweb:v1 docker run -d --name web -p 80:80 myweb:v1 $ docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 03e28eb00bd0 myweb:v1 \"nginx -g 'daemon off\" 3 seconds ago Up 2 seconds (health: starting) 80/tcp, 443/tcp web $ docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 03e28eb00bd0 myweb:v1 \"nginx -g 'daemon off\" 18 seconds ago Up 16 seconds (healthy) 80/tcp, 443/tcp web OBUILD 用于构建下一级镜像时执行，当前镜像并不执行，可用看做通用的构建步骤，在之后的镜像构建中执行\n格式 ：ONBUILD \u003c其他指令\u003e\n构建当前镜像为基础镜像，后续镜像依赖该基础镜像，不需要重复写配置： 当前项目配置：\nFROM node:slim RUN mkdir /app WORKDIR /app ONBUILD COPY ./package.json /app ONBUILD RUN [ \"npm\", \"install\" ] ONBUILD COPY . /app/ CMD [ \"npm\", \"start\" ] 构建\ndocker build -t my-node 其他项目配置：\nFROM my-node npm install,COPY . /app/, npm start会在后续的每一次构建中都执行\n","wordCount":"483","inLanguage":"en","datePublished":"2018-04-08T15:21:27Z","dateModified":"2018-04-08T15:21:27Z","author":{"@type":"Person","name":"HelloWood"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.hellowood.dev/posts/docker-%E4%B8%AD%E4%BD%BF%E7%94%A8-dockerfile/"},"publisher":{"@type":"Organization","name":"HelloWood","logo":{"@type":"ImageObject","url":"https://blog.hellowood.dev/favicon.ico"}}}</script><link rel=icon href=/images/avatar.png sizes=16x16><link rel=apple-touch-icon href=/images/avatar.png><link rel=manifest href=/images/avatar.png><link rel=stylesheet href=https://cdn.staticfile.org/lxgw-wenkai-webfont/1.6.0/style.css><link rel=stylesheet href=/css/main.min.ff1bc260fafbfb440e10194d7d06d57eb5e85eed11d12d06255581262664204e.css integrity="sha256-/xvCYPr7+0QOEBlNfQbVfrXoXu0R0S0GJVWBJiZkIE4=" crossorigin=anonymous media=screen><link rel=stylesheet href=/scss/highlight/github-dark.min.min.66034289ee9a113219a2c4aae0a8bd2095ab255c832a42efcf5863f10814e7a1.css><script src=/js/highlight.min.min.c607d6febd16934a82eb61d3a896ed9d869f54373cc63ce95864ed5488fe3128.js></script><script>hljs.highlightAll()</script><script>(()=>{var t=window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches,e=localStorage.getItem("theme");t&&e===null&&(localStorage.setItem("theme","dark"),document.documentElement.setAttribute("data-dark-mode","")),t&&e==="dark"&&document.documentElement.setAttribute("data-dark-mode",""),e==="dark"&&document.documentElement.setAttribute("data-dark-mode","")})()</script><meta name=google-adsense-account content="ca-pub-3401351766168985"><script type=text/javascript>(function(e,t,n,s,o,i,a){e[n]=e[n]||function(){(e[n].q=e[n].q||[]).push(arguments)},i=t.createElement(s),i.async=1,i.src="https://www.clarity.ms/tag/"+o,a=t.getElementsByTagName(s)[0],a.parentNode.insertBefore(i,a)})(window,document,"clarity","script","jtbhx98g62")</script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3401351766168985" crossorigin=anonymous></script></head><body><main class=wrapper><nav class=navigation><section class=container><a class=navigation-brand data-umami-event=navigation-brand href=/>HOME
</a><input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><span></span><span></span><span></span></label><ul class=navigation-list id=navigation-list><li class="navigation-item navigation-menu"><a class=navigation-link data-umami-event=Blog href=/posts>Blog</a></li><li class="navigation-item navigation-menu"><a class=navigation-link data-umami-event=Tags href=/tags>Tags</a></li><li class="navigation-item navigation-menu"><a class=navigation-link data-umami-event=Archive href=/archives>Archive</a></li><li class="navigation-item navigation-menu"><a class=navigation-link data-umami-event=Dashboard href=https://umami.hellowood.dev/share/lab/Blog>Dashboard</a></li><li class="navigation-item menu-separator"><span>|</span></li><li class="navigation-item navigation-social"><a class=navigation-link data-umami-event=navigation-social href=https://github.com/helloworlde><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a></li><li class="navigation-item navigation-dark"><button id=mode type=button data-umami-event=toggle-theme aria-label="toggle user light or dark theme">
<span class=toggle-dark><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-moon"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg></span>
<span class=toggle-light><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-sun"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></span></button></li></ul></section></nav><div id=content><article class=blog-single><header class=blog-title><h1>Docker 中使用 Dockerfile</h1></header><p><small>April 8, 2018&nbsp;· 483 words&nbsp;· 3 min</small><p><div class=blog-toc><nav id=TableOfContents><ul><li><a href=#构建>构建</a><ul><li><a href=#命令>命令</a></li><li><a href=#执行构建>执行构建</a></li></ul></li></ul></nav></div><section class=blog-content><h1 id=docker-中使用-dockerfile>Docker 中使用 Dockerfile</h1><p>Dockerfile 是一个文件，其包含了一条条的指令（instruction），每一条指令构建一层，因此每一条指令的内容就是描述该层应当如何构建</p><ul><li>构建一个镜像</li></ul><pre tabindex=0><code>FROM nginx
RUN echo &#39;&lt;h1&gt;Hello, Docker!&lt;/h1&gt;&#39; &gt; /usr/share/nginx/html/index.html
</code></pre><h2 id=构建>构建</h2><h3 id=命令>命令</h3><h4 id=from>FROM</h4><p>用于指定基础镜像，必备的指令，必须是第一条</p><ul><li><code>FROM scratch</code>
<code>scratch</code>是一个特殊的镜像，表示一个空白的镜像，意味着不以任何镜像为基础，接下来的指令作为第一层</li></ul><h4 id=run>RUN</h4><p><code>RUN</code> 指令是用来执行命令的，格式有两种：</p><ul><li><code>shell</code> 格式：<code>RUN &lt;命令></code></li></ul><pre tabindex=0><code>RUN echo &#39;&lt;h1&gt;Hello, Docker!&lt;/h1&gt;&#39; &gt; /usr/share/nginx/html/index.html
</code></pre><ul><li><code>exec</code>格式：<code>RUN ["可执行文件", "参数1", "参数2"]</code></li></ul><p>每一个 <code>RUN</code> 命令都会构建一层，应当减少不必要的构建</p><pre tabindex=0><code>FROM debian:jessie

RUN apt-get update
RUN apt-get install -y gcc libc6-dev make
RUN wget -O redis.tar.gz &#34;http://download.redis.io/releases/redis-3.2.5.tar.gz&#34;
RUN mkdir -p /usr/src/redis
RUN tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1
RUN make -C /usr/src/redis
RUN make -C /usr/src/redis install
</code></pre><p>这样会构建7层，会提交大量的无用的改动，应当改为：</p><pre tabindex=0><code>FROM debian:jessie

RUN buildDeps=&#39;gcc libc6-dev make&#39; \
    &amp;&amp; apt-get update \
    &amp;&amp; apt-get install -y $buildDeps \
    &amp;&amp; wget -O redis.tar.gz &#34;http://download.redis.io/releases/redis-3.2.5.tar.gz&#34; \
    &amp;&amp; mkdir -p /usr/src/redis \
    &amp;&amp; tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1 \
    &amp;&amp; make -C /usr/src/redis \
    &amp;&amp; make -C /usr/src/redis install \
    &amp;&amp; rm -rf /var/lib/apt/lists/* \
    &amp;&amp; rm redis.tar.gz \
    &amp;&amp; rm -r /usr/src/redis \
    &amp;&amp; apt-get purge -y --auto-remove $buildDeps
  
</code></pre><p><code>Dockerfile</code> 支持在 Shell 行尾添加 <code>\</code>的命令换行方式，以及行首添加 <code>#</code> 进行注释</p><h3 id=执行构建>执行构建</h3><pre tabindex=0><code>docker build -t myubuntu:v2
</code></pre><p>这样就能构建一个名为<code>myubuntu</code>, 标签为<code>v2</code>的镜像</p><ul><li>从 Git Repo 构建</li></ul><pre tabindex=0><code>docker build https://github.com/test/test.git#:test
</code></pre><p>这样就会在 <code>git clone</code> 之后就会切换到<code>master</code>分支，进入到 <code>test</code>目录执行构建</p><ul><li>用压缩包构建</li></ul><pre tabindex=0><code>docker build http://server/context.tar.gz
</code></pre><h4 id=copy>COPY</h4><p>用于将构建上下文目录中的源文件复制到新的一层镜像内的目标路径位置
格式：</p><pre tabindex=0><code>COPY &lt;源路径&gt; ... &lt;目标路径&gt;
COPY [&#34;&lt;源路径1&gt;&#34;, &#34;&lt;目标路径&gt;&#34;]
</code></pre><pre tabindex=0><code>COPY package.json /usr/src/app/
COPY home* /mydir
COPY home?.txt /mydir
</code></pre><p><code>&lt;目标路径></code> 可以是容器内的绝对路径，也可以是相对于工作目录的相对路径（工作路径可以通过<code>WORKDIR</code> 指定）</p><p>使用<code>COPY</code> 指令，源文件的各种源数据都会被保留，比如读、写、执行权限。文件变更时间等</p><h4 id=add>ADD</h4><p>用于文件复制，和<code>COPY</code>一样，但是<code>&lt;源路径></code>可以是个URL，Docker 会将下载链接的文件放到<code>&lt;目标路径></code>中，文件权限为 600，如果<code>&lt;源路径></code>是一个 tar 文件，压缩格式为 <code>gzip</code>,<code>bzip2</code>,<code>xz</code>的情况下会自动解压该文件到<code>&lt;目标路径></code></p><pre tabindex=0><code>ADD ubuntu-xenial-core-cloudimg-amd64-root.tar.gz /usr/src/
</code></pre><h4 id=cmd>CMD</h4><p>容器启动命令，指令格式和<code>RUN</code>相似：</p><ul><li><code>shell</code>格式：<code>CMD &lt;命令></code></li><li><code>exec</code>格式：<code>CMD ["可执行文件", "参数1", "参数2", ...]</code>，这类格式在执行的时候会被解析为<code>JSON</code>格数组，因此需要用双引号</li></ul><pre tabindex=0><code>CMD echo $HOME
CMD [&#34;sh&#34;, &#34;-c&#34;, &#34;echo $HOME&#34;]

CMD nginx -g daemon off
CMD [&#34;nginx&#34;, &#34;-g&#34;, &#34;daemon off&#34;]
</code></pre><h4 id=entrypoint>ENTRYPOINT</h4><p><code>ENTRYPOINT</code>的格式和目的和<code>CMD</code>一样，都是在指定容器启动程序及参数，需要通过 <code>docker run --entrypoint</code>来指定；区别在于 <code>ENTRYPOINT</code>可以接收外部命令传入的参数作为内部命令的参数使用</p><p>当指定了<code>ENTRYPOINT</code>后，<code>CMD</code>不再是直接的运行其命令，而是将<code>CMD</code>的内容作为参数传给<code>ENTRYPOINT</code></p><pre tabindex=0><code>&lt;ENTRYPOINT&gt; &#34;&lt;CMD&gt;&#34;
</code></pre><h4 id=env>ENV</h4><p>用于设置环境变量，格式有两种：</p><pre tabindex=0><code>ENV &lt;key&gt; &lt;value&gt;
ENV &lt;key1&gt;=&lt;value1&gt; &lt;key2&gt;=&lt;value2&gt;
</code></pre><pre tabindex=0><code>ENV NODE_VERSION 7.2.0
RUN echo $NODE_VERSION
</code></pre><p><code>ENV</code>可以在<code>ADD</code>,<code>COPY</code>,<code>ENV</code>, <code>EXPOSE</code>,<code>LABEL</code>,<code>USER</code>,<code>WORKDIR</code>, <code>VOLUME</code>,<code>STOPSIGNAL</code>, <code>ONBUILD</code></p><h4 id=arg>ARG</h4><p>构建参数，和<code>ENV</code>的效果一样，都是设置环境变量，但是<code>ARG</code>所设置的环境变量在容器运行时不存在
格式：<code>ATG &lt;参数名>[=&lt;默认值>]</code>
默认值可以通过<code>docker build --build-arg &lt;参数名>=&lt;值></code></p><h4 id=volume>VOLUME</h4><p>用于指定某些目录挂载为匿名卷，这样在运行时如果用户不指定挂载，其应用也可以正常运行，不会向容器存储层写入大量数据</p><p>格式：</p><pre tabindex=0><code>VOLUME [&#34;&lt;路径1&gt;&#34;,&#34;&lt;路径2&gt;&#34;]
VOLUME &lt;路径&gt;
</code></pre><pre tabindex=0><code>VOLUME /data
</code></pre><p>运行时可以覆盖这个挂载设置：</p><pre tabindex=0><code>docker run -d -v mydata:/data 
</code></pre><p>这样就使用 <code>mydata</code>这个命名卷挂载到 <code>/data</code>这个位置，替代了在 <code>Dockerfile</code>中定义的匿名卷的挂载配置</p><h4 id=expose>EXPOSE</h4><p>用于声明运行时容器提供服务端口，仅仅是一个声明，并不会直接开启端口的服务，用于帮助使用者理解镜像服务的守护端口，同时用于在运行时使用端口随机映射<code>docker run -P</code>时使用<code>EXPOSE</code>配置的端口</p><pre tabindex=0><code>EXPOSE &lt;端口1&gt; [&lt;端口2&gt; ...]
</code></pre><h4 id=workdir>WORKDIR</h4><p>用来指定工作目录（当前目录），以后各层的当前目录就被改为指定目录，如果目录不存在，会直接生成该目录</p><p>格式为：<code>WORKDIR &lt;工作目录路径></code></p><h4 id=user>USER</h4><p><code>USER</code>和<code>WORKDIR</code>相似，都是改变环境状态并影响以后的层，<code>WORKDIR</code>改变的是工作目录，<code>USER</code>改变之后执行<code>RUN</code>,<code>CMD</code>,<code>ENTRYPOINT</code>之类命令的身份，<code>USER</code>只是切换到指定用户，该用户必须事先建立好</p><p>格式：<code>USER &lt;用户名></code></p><pre tabindex=0><code>RUN groupadd -r redis &amp;&amp; useradd -r -g redis redis
USER redis
RUN [&#39;redis-server&#39;]
</code></pre><h4 id=healthcheck>HEALTHCHECK</h4><p>用来告诉 Docker 如何判断容器的状态是否正常
格式：</p><ul><li><code>HEALTHCHECK [选项] CMD &lt;命令></code>：设置检查容器健康状况的命令</li><li><code>HEALTHCHECK NONE</code>：如果基础镜像有健康检查指令，使用该命令可以屏蔽</li></ul><p><code>HEALTHCHECK</code>支持下列选项：</p><ul><li><code>--interval=&lt;间隔></code>：两次健康检查的间隔，默认为30s</li><li><code>timeout=&lt;时长></code>：健康检查命令运行超时时间，如果超过这个时间则被认为此次健康检查失败</li><li><code>--retries=&lt;时长></code>：当连续失败指定次数后，则将容器状态视为<code>unhealthy</code>，默认3次</li></ul><p><code>HEALTHCHECK</code>只可以出现一次，如果写了多个，则只有最后一个生效；
在<code>HEALTHCHECK [选项] CMD</code> 后面的命令，格式和<code>ENTRYPOINT</code>一样，分为 <code>shell</code>和<code>exec</code>格式，命令的返回值决定了改次检查的成功与否，<code>0</code>:成功，<code>1</code>:失败，<code>2</code>: 保留</p><p>检查web服务是否可用：</p><pre tabindex=0><code>FROM nginx
RUN apt-get update &amp;&amp; apt-get install -y curl &amp;&amp; rm -rf /var/lib/apt/lists/*
HEALTHCHECK --interval=5s --timeout=3s \
CMD curl -fs http://localhost/ || exit 1
</code></pre><p>构建并启动该容器，查看其状态：</p><pre tabindex=0><code>docker build -t myweb:v1
docker run -d --name web -p 80:80 myweb:v1
</code></pre><pre tabindex=0><code>$ docker ps
CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES
03e28eb00bd0 myweb:v1 &#34;nginx -g &#39;daemon off&#34; 3 seconds ago Up 2 seconds (health: starting) 80/tcp, 443/tcp web

$ docker ps
CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES
03e28eb00bd0 myweb:v1 &#34;nginx -g &#39;daemon off&#34; 18 seconds ago Up 16 seconds (healthy) 80/tcp, 443/tcp web
</code></pre><h4 id=obuild>OBUILD</h4><p>用于构建下一级镜像时执行，当前镜像并不执行，可用看做通用的构建步骤，在之后的镜像构建中执行</p><p>格式 ：<code>ONBUILD &lt;其他指令></code></p><p>构建当前镜像为基础镜像，后续镜像依赖该基础镜像，不需要重复写配置：
当前项目配置：</p><pre tabindex=0><code>FROM node:slim
RUN mkdir /app
WORKDIR /app
ONBUILD COPY ./package.json /app
ONBUILD RUN [ &#34;npm&#34;, &#34;install&#34; ]
ONBUILD COPY . /app/
CMD [ &#34;npm&#34;, &#34;start&#34; ]
</code></pre><p>构建</p><pre tabindex=0><code>docker build -t my-node 
</code></pre><p>其他项目配置：</p><pre tabindex=0><code>FROM my-node
</code></pre><p><code>npm install</code>,<code>COPY . /app/</code>, <code>npm start</code>会在后续的每一次构建中都执行</p></section><div class=paginator><a class=prev href=https://blog.hellowood.dev/posts/docker-%E9%85%8D%E7%BD%AEubuntu-%E4%B8%8B-tomcat-%E5%92%8C-nginx-%E4%BD%BF%E7%94%A8-https-%E8%AE%BF%E9%97%AE/><svg class="icon" width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M3.77086 21.1546C11.0491 22.698 21.4339 21.7773 21.4339 16.3608V4.63375c0-.69413-.075800000000001-1.3284-.2422-1.86588M3.77086 21.1546C1.9934 20.7777.973585 18.7264 1.08749 16.688c.17931-3.209.06972-7.25665-.08236-10.47293C.87809 3.52811 3.12891 1.16316 5.51029 1.25008c4.25565.15534 9.86671-.04779 13.28091-.24466 1.2952-.074686 2.0494.62843 2.4005 1.76245M3.77086 21.1546C4.56586 21.4723 5.49168 21.7879 6.5 22.0658M21.1917 2.76787c1.918 1.4143 1.9383 9.65123 1.7087 13.59293-2.0526 7.6586-10.5943 7.3054-16.4004 5.705M21.1917 2.76787C21.7612 4.51192 22.7203 9.67216 22 16.3608 21.2797 23.0494 11.3665 22.9511 6.5 22.0658M9.94496 9C9.28897 9.61644 7.63215 10.997 6.04814 11.7966 5.98257 11.8297 5.98456 11.9753 6.05061 12.0063c1.00435.4716 2.8788 1.9201 3.89435 2.9937M6.44444 11.9667C8.86549 12.0608 14 12 16 11" stroke="currentcolor" stroke-linecap="round"/></svg>
<span>Docker 配置Ubuntu 下 Tomcat 和 Nginx 使用 HTTPS 访问</span></a>
<a class=next href=https://blog.hellowood.dev/posts/docker-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/><span>Docker 常用命令</span><svg class="icon" width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M3.77086 21.1546C11.0491 22.698 21.4339 21.7773 21.4339 16.3608V4.63375c0-.69413-.075800000000001-1.3284-.2422-1.86588M3.77086 21.1546C1.9934 20.7777.973585 18.7264 1.08749 16.688c.17931-3.209.06972-7.25665-.08236-10.47293C.87809 3.52811 3.12891 1.16316 5.51029 1.25008c4.25565.15534 9.86671-.04779 13.28091-.24466 1.2952-.074686 2.0494.62843 2.4005 1.76245M3.77086 21.1546C4.56586 21.4723 5.49168 21.7879 6.5 22.0658M21.1917 2.76787c1.918 1.4143 1.9383 9.65123 1.7087 13.59293-2.0526 7.6586-10.5943 7.3054-16.4004 5.705M21.1917 2.76787C21.7612 4.51192 22.7203 9.67216 22 16.3608 21.2797 23.0494 11.3665 22.9511 6.5 22.0658M12.055 9C12.711 9.61644 14.3679 10.997 15.9519 11.7966 16.0174 11.8297 16.0154 11.9753 15.9494 12.0063 14.945 12.4779 13.0706 13.9264 12.055 15m3.5006-3.0333C13.1345 12.0608 8 12 6 11" stroke="currentcolor" stroke-linecap="round"/></svg></a></div></article></div><footer class=footer><p>&copy; 2024 <a href=https://blog.hellowood.dev/>HelloWood</a>
Powered by
<a href=https://gohugo.io/ rel=noopener target=_blank data-umami-event=to-hugo>Hugo️️</a>
<a href=https://github.com/guangzhengli/hugo-theme-ladder rel=noopener target=_blank data-umami-event=to-ladder>Ladder</a>
️</p></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g data-umami-event=top-link><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M10.5376 22.7916C11.0152 22.7207 22.5795 21.1781 22.0978 10.4211 22.0536 9.43274 21.9303 8.53367 21.7387 7.71865M10.5376 22.7916C16.876 22.3728 20.0969 19.8899 21.5383 16.9142M10.5376 22.7916C9.7707 22.9055 8.97982 22.8964 8.19743 22.7725M21.7387 7.71865C21.4988 6.69828 21.1518 5.80967 20.7188 5.04257m1.0199 2.67608C22.6022 10.1105 23.0542 13.7848 21.5383 16.9142M20.7188 5.04257c-3.5504-6.28886-12.88753-4.410077-16.44303.0C2.88063 6.77451-.0433281 11.1668 1.38159 16.6571c.89322 3.4417 3.7911 5.6365 6.81584 6.1154M20.7188 5.04257c1.3509 1.89783 3.3111 6.34223 1.6353 10.37273M21.5383 16.9142C21.8737 16.4251 22.1428 15.9235 22.3541 15.4153M8.19743 22.7725C12.1971 23.4683 20.6281 22.971 22.3541 15.4153M14 10.945C13.3836 10.289 12.003 8.63215 11.2034 7.04814 11.1703 6.98257 11.0247 6.98456 10.9937 7.05061 10.5221 8.05496 9.07362 9.92941 8 10.945m3.0333-3.50056C10.9392 9.86549 11 15 12 17" stroke="currentcolor" stroke-linecap="round"/></svg>
</a><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const s=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="Copy";function n(){t.innerHTML="Copied",setTimeout(()=>{t.innerHTML="Copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),n();return}const s=document.createRange();s.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(s);try{document.execCommand("copy"),n()}catch{}o.removeRange(s)}),e.parentNode.appendChild(t)})</script></main></body><script src=https://cdnjs.cloudflare.com/ajax/libs/medium-zoom/1.0.6/medium-zoom.min.js integrity="sha512-N9IJRoc3LaP3NDoiGkcPa4gG94kapGpaA5Zq9/Dr04uf5TbLFU5q0o8AbRhLKUUlp8QFS2u7S+Yti0U7QtuZvQ==" crossorigin=anonymous referrerpolicy=no-referrer></script><script>const images=Array.from(document.querySelectorAll(".blog-content img"));images.forEach(e=>{mediumZoom(e,{margin:10,scrollOffset:40,container:null,template:null,background:"rgba(0, 0, 0, 0.5)"})})</script><script src=/main.min.6bb26b69159420159c74dc9e097b06a578ed2b68c701466a91a44a9632d851bd0af167a1b30012387b4c512b48ad9ad4d3394e04d77ae38d57e1920fe4ed34fe.js integrity="sha512-a7JraRWUIBWcdNyeCXsGpXjtK2jHAUZqkaRKljLYUb0K8WehswASOHtMUStIrZrU0zlOBNd6441X4ZIP5O00/g==" crossorigin=anonymous defer></script></html>