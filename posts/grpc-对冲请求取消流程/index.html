<!doctype html><html lang=en><head><meta name=viewport content="width=device-width,initial-scale=1"><title>gRPC 对冲请求取消流程</title>
<meta charset=utf-8><meta name=description content="Ladder@gRPC 对冲请求取消流程 当客户端接收到对冲请求集合中的一个完成时，会取消其他的请求，被取消的请求最终会提交一个 CancelClientStreamCommand，发送一个 RST_STEAM 请求；当服务端接受到这个流后，如果监听器还没有关闭，会执行取消上下文的操作，最终将这个请求取消
客户端 当客户端成功接收到响应会，会在 io.grpc.internal.RetriableStream.Sublistener#close 中将成功的流进行提交
io.grpc.internal.RetriableStream#commit$CommitTask#run 在提交时，会通过提交 CommitTask 将其他的流取消
class CommitTask implements Runnable { @Override public void run() { // 遍历保存的枯竭的流，如果不是最后提交的流，则都取消 for (Substream substream : savedDrainedSubstreams) { if (substream != winningSubstream) { substream.stream.cancel(CANCELLED_BECAUSE_COMMITTED); } } // 如果有重试中的，则取消 if (retryFuture != null) { retryFuture.cancel(false); } // 如果有对冲中的，则取消 if (hedgingFuture != null) { hedgingFuture.cancel(false); } // 将当前流从未提交的流中移除 postCommit(); } } io.grpc.internal.AbstractClientStream#cancel 使用指定的原因取消流
public final void cancel(Status reason) { Preconditions."><meta name=author content="HelloWood"><link rel=canonical href=https://blog.hellowood.dev/posts/grpc-%E5%AF%B9%E5%86%B2%E8%AF%B7%E6%B1%82%E5%8F%96%E6%B6%88%E6%B5%81%E7%A8%8B/><meta name=google-site-verification content="G-3MSGPYTHPZ"><link rel=alternate type=application/rss+xml href=https://blog.hellowood.dev//index.xml title=HelloWood><script async src="https://www.googletagmanager.com/gtag/js?id=G-3MSGPYTHPZ"></script><script>var doNotTrack=!1,dnt;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-3MSGPYTHPZ")}</script><script async defer data-website-id=7a9034de-0ce7-4756-942a-829e6cd22301 src=https://umami.hellowood.dev/script.js></script><script defer data-cf-beacon='{"token": "b2e481d136dc428c8c96c8673e2a04cf"}' src=https://static.cloudflareinsights.com/beacon.min.js></script><meta property="og:url" content="https://blog.hellowood.dev/posts/grpc-%E5%AF%B9%E5%86%B2%E8%AF%B7%E6%B1%82%E5%8F%96%E6%B6%88%E6%B5%81%E7%A8%8B/"><meta property="og:site_name" content="HelloWood"><meta property="og:title" content="gRPC 对冲请求取消流程"><meta property="og:description" content="gRPC 对冲请求取消流程 当客户端接收到对冲请求集合中的一个完成时，会取消其他的请求，被取消的请求最终会提交一个 CancelClientStreamCommand，发送一个 RST_STEAM 请求；当服务端接受到这个流后，如果监听器还没有关闭，会执行取消上下文的操作，最终将这个请求取消
客户端 当客户端成功接收到响应会，会在 io.grpc.internal.RetriableStream.Sublistener#close 中将成功的流进行提交
io.grpc.internal.RetriableStream#commit$CommitTask#run 在提交时，会通过提交 CommitTask 将其他的流取消
class CommitTask implements Runnable { @Override public void run() { // 遍历保存的枯竭的流，如果不是最后提交的流，则都取消 for (Substream substream : savedDrainedSubstreams) { if (substream != winningSubstream) { substream.stream.cancel(CANCELLED_BECAUSE_COMMITTED); } } // 如果有重试中的，则取消 if (retryFuture != null) { retryFuture.cancel(false); } // 如果有对冲中的，则取消 if (hedgingFuture != null) { hedgingFuture.cancel(false); } // 将当前流从未提交的流中移除 postCommit(); } } io.grpc.internal.AbstractClientStream#cancel 使用指定的原因取消流
public final void cancel(Status reason) { Preconditions."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-02-20T22:34:46+00:00"><meta property="article:modified_time" content="2021-02-20T22:34:46+00:00"><meta property="article:tag" content="GRPC"><meta name=twitter:card content="summary"><meta name=twitter:title content="gRPC 对冲请求取消流程"><meta name=twitter:description content="gRPC 对冲请求取消流程 当客户端接收到对冲请求集合中的一个完成时，会取消其他的请求，被取消的请求最终会提交一个 CancelClientStreamCommand，发送一个 RST_STEAM 请求；当服务端接受到这个流后，如果监听器还没有关闭，会执行取消上下文的操作，最终将这个请求取消
客户端 当客户端成功接收到响应会，会在 io.grpc.internal.RetriableStream.Sublistener#close 中将成功的流进行提交
io.grpc.internal.RetriableStream#commit$CommitTask#run 在提交时，会通过提交 CommitTask 将其他的流取消
class CommitTask implements Runnable { @Override public void run() { // 遍历保存的枯竭的流，如果不是最后提交的流，则都取消 for (Substream substream : savedDrainedSubstreams) { if (substream != winningSubstream) { substream.stream.cancel(CANCELLED_BECAUSE_COMMITTED); } } // 如果有重试中的，则取消 if (retryFuture != null) { retryFuture.cancel(false); } // 如果有对冲中的，则取消 if (hedgingFuture != null) { hedgingFuture.cancel(false); } // 将当前流从未提交的流中移除 postCommit(); } } io.grpc.internal.AbstractClientStream#cancel 使用指定的原因取消流
public final void cancel(Status reason) { Preconditions."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.hellowood.dev/posts/"},{"@type":"ListItem","position":2,"name":"gRPC 对冲请求取消流程","item":"https://blog.hellowood.dev/posts/grpc-%E5%AF%B9%E5%86%B2%E8%AF%B7%E6%B1%82%E5%8F%96%E6%B6%88%E6%B5%81%E7%A8%8B/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"gRPC 对冲请求取消流程","name":"gRPC 对冲请求取消流程","description":"gRPC 对冲请求取消流程 当客户端接收到对冲请求集合中的一个完成时，会取消其他的请求，被取消的请求最终会提交一个 CancelClientStreamCommand，发送一个 RST_STEAM 请求；当服务端接受到这个流后，如果监听器还没有关闭，会执行取消上下文的操作，最终将这个请求取消\n客户端 当客户端成功接收到响应会，会在 io.grpc.internal.RetriableStream.Sublistener#close 中将成功的流进行提交\nio.grpc.internal.RetriableStream#commit$CommitTask#run 在提交时，会通过提交 CommitTask 将其他的流取消\nclass CommitTask implements Runnable { @Override public void run() { // 遍历保存的枯竭的流，如果不是最后提交的流，则都取消 for (Substream substream : savedDrainedSubstreams) { if (substream != winningSubstream) { substream.stream.cancel(CANCELLED_BECAUSE_COMMITTED); } } // 如果有重试中的，则取消 if (retryFuture != null) { retryFuture.cancel(false); } // 如果有对冲中的，则取消 if (hedgingFuture != null) { hedgingFuture.cancel(false); } // 将当前流从未提交的流中移除 postCommit(); } } io.grpc.internal.AbstractClientStream#cancel 使用指定的原因取消流\npublic final void cancel(Status reason) { Preconditions.","keywords":["gRPC"],"articleBody":"gRPC 对冲请求取消流程 当客户端接收到对冲请求集合中的一个完成时，会取消其他的请求，被取消的请求最终会提交一个 CancelClientStreamCommand，发送一个 RST_STEAM 请求；当服务端接受到这个流后，如果监听器还没有关闭，会执行取消上下文的操作，最终将这个请求取消\n客户端 当客户端成功接收到响应会，会在 io.grpc.internal.RetriableStream.Sublistener#close 中将成功的流进行提交\nio.grpc.internal.RetriableStream#commit$CommitTask#run 在提交时，会通过提交 CommitTask 将其他的流取消\nclass CommitTask implements Runnable { @Override public void run() { // 遍历保存的枯竭的流，如果不是最后提交的流，则都取消 for (Substream substream : savedDrainedSubstreams) { if (substream != winningSubstream) { substream.stream.cancel(CANCELLED_BECAUSE_COMMITTED); } } // 如果有重试中的，则取消 if (retryFuture != null) { retryFuture.cancel(false); } // 如果有对冲中的，则取消 if (hedgingFuture != null) { hedgingFuture.cancel(false); } // 将当前流从未提交的流中移除 postCommit(); } } io.grpc.internal.AbstractClientStream#cancel 使用指定的原因取消流\npublic final void cancel(Status reason) { Preconditions.checkArgument(!reason.isOk(), \"Should not cancel with OK status\"); cancelled = true; abstractClientStreamSink().cancel(reason); } io.grpc.netty.shaded.io.grpc.netty.NettyClientStream.Sink#cancel 提交取消流的指令\npublic void cancel(Status status) { PerfMark.startTask(\"NettyClientStream$Sink.cancel\"); try { NettyClientStream.this.writeQueue.enqueue(new CancelClientStreamCommand(NettyClientStream.this.transportState(), status), true); } finally { PerfMark.stopTask(\"NettyClientStream$Sink.cancel\"); } } io.grpc.netty.shaded.io.grpc.netty.NettyClientHandler#write 在执行写入消息时，写入取消指令\npublic void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception { if (msg instanceof CreateStreamCommand) { this.createStream((CreateStreamCommand)msg, promise); } else if (msg instanceof SendGrpcFrameCommand) { this.sendGrpcFrame(ctx, (SendGrpcFrameCommand)msg, promise); } else if (msg instanceof CancelClientStreamCommand) { this.cancelStream(ctx, (CancelClientStreamCommand)msg, promise); } else if (msg instanceof SendPingCommand) { this.sendPingFrame(ctx, (SendPingCommand)msg, promise); } else if (msg instanceof GracefulCloseCommand) { this.gracefulClose(ctx, (GracefulCloseCommand)msg, promise); } else if (msg instanceof ForcefulCloseCommand) { this.forcefulClose(ctx, (ForcefulCloseCommand)msg, promise); } else { if (msg != NOOP_MESSAGE) { throw new AssertionError(\"Write called for unexpected type: \" + msg.getClass().getName()); } ctx.write(Unpooled.EMPTY_BUFFER, promise); } } io.grpc.netty.shaded.io.grpc.netty.NettyClientHandler#cancelStream 执行取消命令的写入，在 transportReportStatus 会提交关闭监听器的指令，如果停止投递，同时也会选择执行或者延迟执行关闭帧 如果流存在，则会发送一个新的 RST_STREAM 请求，该请求表示当前流错误，错误状态为 CANCEL，即值为 8\nprivate void cancelStream(ChannelHandlerContext ctx, CancelClientStreamCommand cmd, ChannelPromise promise) { TransportState stream = cmd.stream(); try { Status reason = cmd.reason(); if (reason != null) { stream.transportReportStatus(reason, true, new Metadata()); } if (!cmd.stream().isNonExistent()) { this.encoder().writeRstStream(ctx, stream.id(), Http2Error.CANCEL.code(), promise); } else { promise.setSuccess(); } } finally { PerfMark.stopTask(\"NettyClientHandler.cancelStream\", stream.tag()); } } 服务端 io.grpc.netty.shaded.io.grpc.netty.NettyServerHandler.FrameListener#onRstStreamRead 接收到的请求中，errorCode 为 8，代表请求被取消\npublic void onRstStreamRead(ChannelHandlerContext ctx, int streamId, long errorCode) throws Http2Exception { if (NettyServerHandler.this.keepAliveManager != null) { NettyServerHandler.this.keepAliveManager.onDataReceived(); } NettyServerHandler.this.onRstStreamRead(streamId, errorCode); } io.grpc.netty.shaded.io.grpc.netty.NettyServerHandler#onRstStreamRead 然后会在 NettyServerHandler 中根据 streamId 获取流，如果流存在，则会以 CANCELLED 状态取消当前请求 需要注意的是，如果接收到这个请求时流已经完成被清除，则可能无法处理，请求会以 OK 状态完成\nprivate void onRstStreamRead(int streamId, long errorCode) throws Http2Exception { try { TransportState stream = this.serverStream(this.connection().stream(streamId)); if (stream != null) { try { stream.transportReportStatus(Status.CANCELLED.withDescription(\"RST_STREAM received for code \" + errorCode)); } } } catch (Throwable var9) { logger.log(Level.WARNING, \"Exception in onRstStreamRead()\", var9); throw this.newStreamException(streamId, var9); } } io.grpc.internal.AbstractServerStream.TransportState#transportReportStatus 如果解帧器已经关闭，则使用取消状态关闭监听器\npublic final void transportReportStatus(final Status status) { Preconditions.checkArgument(!status.isOk(), \"status must not be OK\"); // 如果解帧器关闭，则关闭监听器 if (deframerClosed) { deframerClosedTask = null; closeListener(status); } else { // 如果解帧器还没有关闭，则创建关闭监听器的任务，并立即关闭解帧器 deframerClosedTask = new Runnable() { @Override public void run() { closeListener(status); } }; immediateCloseRequested = true; closeDeframer(true); } } io.grpc.internal.AbstractServerStream.TransportState#closeListener 使用指定状态关闭监听器\nprivate void closeListener(Status newStatus) { Preconditions.checkState(!newStatus.isOk() || closedStatus != null); // 如果监听器没有关闭，则根据状态操作 if (!listenerClosed) { listenerClosed = true; // 通知流的状态不可以再使用 onStreamDeallocated(); // 使用指定状态关闭监听器 listener().closed(newStatus); } } io.grpc.internal.ServerImpl.JumpToApplicationThreadServerStreamListener#closedInternal 使用 CANCELLED 状态，执行 ContextCloser 任务，取消上下文；然后提交 Closed 任务，取消 监听器\nprivate void closedInternal(final Status status) { // 如果状态不是 OK，则直接提交关闭 Context 任务 if (!status.isOk()) { cancelExecutor.execute(new ContextCloser(context, status.getCause())); } final class Closed extends ContextRunnable { Closed() { super(context); } @Override public void runInContext() { try { // 调用监听器的关闭事件 getListener().closed(status); } } } callExecutor.execute(new Closed()); } io.grpc.internal.ServerImpl.ContextCloser#run 执行提交的 ContextCloser 任务，取消上下文\npublic void run() { // 执行时使用指定异常关闭 Context context.cancel(cause); } io.grpc.Context.CancellableContext#cancel 执行 Context 取消事件，会修改 Context 的状态，取消等待的 deadline 任务，然后会通知并清除监听器\npublic boolean cancel(Throwable cause) { boolean triggeredCancel = false; synchronized (this) { // 如果没有取消，则取消，并修改状态 if (!cancelled) { cancelled = true; // 如果有等待取消的任务，则取消 if (pendingDeadline != null) { pendingDeadline.cancel(false); pendingDeadline = null; } this.cancellationCause = cause; triggeredCancel = true; } } // 如果取消成功了，则通知监听器 if (triggeredCancel) { notifyAndClearListeners(); } return triggeredCancel; } io.grpc.Context.CancellableContext#notifyAndClearListeners 会通知当前的监听器进行取消，默认由两个监听器，一个是CancellationListener，用于取消当前上下文，另一个是 ServerStreamCancellationListener ，用于取消流；如果有其他的监听器，还会通知其他监听器取消，并移除监听器\nprivate void notifyAndClearListeners() { ArrayList\u003cExecutableListener\u003e tmpListeners; CancellationListener tmpParentListener; synchronized (this) { // 如果没有监听器则返回 if (listeners == null) { return; } tmpParentListener = parentListener; parentListener = null; tmpListeners = listeners; listeners = null; } // 在取消之前先通知事件，优先通知当前上下文 for (ExecutableListener tmpListener : tmpListeners) { if (tmpListener.context == this) { tmpListener.deliver(); } } // 通知其他的上下文 for (ExecutableListener tmpListener : tmpListeners) { if (!(tmpListener.context == this)) { tmpListener.deliver(); } } // 移除引用的监听器 if (cancellableAncestor != null) { cancellableAncestor.removeListener(tmpParentListener); } } io.grpc.internal.ServerCallImpl.ServerStreamListenerImpl#ServerStreamListenerImpl 最终会调用构造 ServerStreamListenerImpl 时添加的 Context.CancellationListener 的 cancelled 方法，将 ServerCallImpl 的 cancelled 状态改为 true\nthis.context.addListener(new Context.CancellationListener() { @Override public void cancelled(Context context) { ServerStreamListenerImpl.this.call.cancelled = true; } }, MoreExecutors.directExecutor()); io.grpc.internal.ServerImpl.ServerTransportListenerImpl#StreamCreated$ServerStreamCancellationListener#cancelled 执行创建流时添加的流取消监听器，如果没有异常信息，则会使用 \"io.grpc.Context was cancelled without error\"作为描述，更新状态\npublic void cancelled(Context context) { Status status = statusFromCancelled(context); if (DEADLINE_EXCEEDED.getCode().equals(status.getCode())) { // This should rarely get run, since the client will likely cancel the stream // before the timeout is reached. stream.cancel(status); } } io.grpc.internal.ServerCallImpl.ServerStreamListenerImpl#closedInternal 在执行 OnClosed 任务时，会使用 CANCELLED 状态，触发 ServerCall.Listener 的 onCanncel 事件，如果有取消任务，会执行取消任务\n另外，无论请求成功与否，都会执行 context.cancel(null)，通知 notifyAndClearListeners取消上下文监听器和流监听器，然后移除监听器\nprivate void closedInternal(Status status) { try { // 如果状态是 OK，通知监听器完成 if (status.isOk()) { listener.onComplete(); } else { // 否则将状态改为取消，通知监听器取消 call.cancelled = true; listener.onCancel(); } } finally { // 取消上下文 context.cancel(null); } } ","wordCount":"730","inLanguage":"en","datePublished":"2021-02-20T22:34:46Z","dateModified":"2021-02-20T22:34:46Z","author":{"@type":"Person","name":"HelloWood"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.hellowood.dev/posts/grpc-%E5%AF%B9%E5%86%B2%E8%AF%B7%E6%B1%82%E5%8F%96%E6%B6%88%E6%B5%81%E7%A8%8B/"},"publisher":{"@type":"Organization","name":"HelloWood","logo":{"@type":"ImageObject","url":"https://blog.hellowood.dev/favicon.ico"}}}</script><link rel=icon href=/images/avatar.png sizes=16x16><link rel=apple-touch-icon href=/images/avatar.png><link rel=manifest href=/images/avatar.png><link rel=stylesheet href=https://cdn.staticfile.org/lxgw-wenkai-webfont/1.6.0/style.css><link rel=stylesheet href=/css/main.min.ff1bc260fafbfb440e10194d7d06d57eb5e85eed11d12d06255581262664204e.css integrity="sha256-/xvCYPr7+0QOEBlNfQbVfrXoXu0R0S0GJVWBJiZkIE4=" crossorigin=anonymous media=screen><link rel=stylesheet href=/scss/highlight/github-dark.min.min.66034289ee9a113219a2c4aae0a8bd2095ab255c832a42efcf5863f10814e7a1.css><script src=/js/highlight.min.min.c607d6febd16934a82eb61d3a896ed9d869f54373cc63ce95864ed5488fe3128.js></script><script>hljs.highlightAll()</script><script>(()=>{var t=window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches,e=localStorage.getItem("theme");t&&e===null&&(localStorage.setItem("theme","dark"),document.documentElement.setAttribute("data-dark-mode","")),t&&e==="dark"&&document.documentElement.setAttribute("data-dark-mode",""),e==="dark"&&document.documentElement.setAttribute("data-dark-mode","")})()</script><meta name=google-adsense-account content="ca-pub-3401351766168985"><script type=text/javascript>(function(e,t,n,s,o,i,a){e[n]=e[n]||function(){(e[n].q=e[n].q||[]).push(arguments)},i=t.createElement(s),i.async=1,i.src="https://www.clarity.ms/tag/"+o,a=t.getElementsByTagName(s)[0],a.parentNode.insertBefore(i,a)})(window,document,"clarity","script","jtbhx98g62")</script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3401351766168985" crossorigin=anonymous></script></head><body><main class=wrapper><nav class=navigation><section class=container><a class=navigation-brand data-umami-event=navigation-brand href=/>HOME
</a><input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><span></span><span></span><span></span></label><ul class=navigation-list id=navigation-list><li class="navigation-item navigation-menu"><a class=navigation-link data-umami-event=Blog href=/posts>Blog</a></li><li class="navigation-item navigation-menu"><a class=navigation-link data-umami-event=Tags href=/tags>Tags</a></li><li class="navigation-item navigation-menu"><a class=navigation-link data-umami-event=Archive href=/archives>Archive</a></li><li class="navigation-item navigation-menu"><a class=navigation-link data-umami-event=Dashboard href=https://umami.hellowood.dev/share/lab/Blog>Dashboard</a></li><li class="navigation-item menu-separator"><span>|</span></li><li class="navigation-item navigation-social"><a class=navigation-link data-umami-event=navigation-social href=https://github.com/helloworlde><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a></li><li class="navigation-item navigation-dark"><button id=mode type=button data-umami-event=toggle-theme aria-label="toggle user light or dark theme">
<span class=toggle-dark><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-moon"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg></span>
<span class=toggle-light><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-sun"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></span></button></li></ul></section></nav><div id=content><article class=blog-single><header class=blog-title><h1>gRPC 对冲请求取消流程</h1></header><p><small>February 20, 2021&nbsp;· 730 words&nbsp;· 4 min</small><p><div class=blog-toc><nav id=TableOfContents><ul><li><a href=#客户端>客户端</a></li><li><a href=#服务端>服务端</a></li></ul></nav></div><section class=blog-content><h1 id=grpc-对冲请求取消流程>gRPC 对冲请求取消流程</h1><p>当客户端接收到对冲请求集合中的一个完成时，会取消其他的请求，被取消的请求最终会提交一个 CancelClientStreamCommand，发送一个 RST_STEAM 请求；当服务端接受到这个流后，如果监听器还没有关闭，会执行取消上下文的操作，最终将这个请求取消</p><p><img alt=grpc-hedging-request-cancel.svg src=https://img.hellowood.dev/picture/grpc-hedging-request-cancel.svg></p><h2 id=客户端>客户端</h2><p>当客户端成功接收到响应会，会在 io.grpc.internal.RetriableStream.Sublistener#close 中将成功的流进行提交</p><ul><li>io.grpc.internal.RetriableStream#commit$CommitTask#run</li></ul><p>在提交时，会通过提交 CommitTask 将其他的流取消</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>CommitTask</span> <span style=color:#66d9ef>implements</span> Runnable {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>run</span>() {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 遍历保存的枯竭的流，如果不是最后提交的流，则都取消</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (Substream substream : savedDrainedSubstreams) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (substream <span style=color:#f92672>!=</span> winningSubstream) {
</span></span><span style=display:flex><span>                substream.<span style=color:#a6e22e>stream</span>.<span style=color:#a6e22e>cancel</span>(CANCELLED_BECAUSE_COMMITTED);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 如果有重试中的，则取消</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (retryFuture <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>            retryFuture.<span style=color:#a6e22e>cancel</span>(<span style=color:#66d9ef>false</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 如果有对冲中的，则取消</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (hedgingFuture <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>            hedgingFuture.<span style=color:#a6e22e>cancel</span>(<span style=color:#66d9ef>false</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 将当前流从未提交的流中移除</span>
</span></span><span style=display:flex><span>        postCommit();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>io.grpc.internal.AbstractClientStream#cancel</li></ul><p>使用指定的原因取消流</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>cancel</span>(Status reason) {
</span></span><span style=display:flex><span>    Preconditions.<span style=color:#a6e22e>checkArgument</span>(<span style=color:#f92672>!</span>reason.<span style=color:#a6e22e>isOk</span>(), <span style=color:#e6db74>&#34;Should not cancel with OK status&#34;</span>);
</span></span><span style=display:flex><span>    cancelled <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>    abstractClientStreamSink().<span style=color:#a6e22e>cancel</span>(reason);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>io.grpc.netty.shaded.io.grpc.netty.NettyClientStream.Sink#cancel</li></ul><p>提交取消流的指令</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>cancel</span>(Status status) {
</span></span><span style=display:flex><span>    PerfMark.<span style=color:#a6e22e>startTask</span>(<span style=color:#e6db74>&#34;NettyClientStream$Sink.cancel&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>        NettyClientStream.<span style=color:#a6e22e>this</span>.<span style=color:#a6e22e>writeQueue</span>.<span style=color:#a6e22e>enqueue</span>(<span style=color:#66d9ef>new</span> CancelClientStreamCommand(NettyClientStream.<span style=color:#a6e22e>this</span>.<span style=color:#a6e22e>transportState</span>(), status), <span style=color:#66d9ef>true</span>);
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>finally</span> {
</span></span><span style=display:flex><span>        PerfMark.<span style=color:#a6e22e>stopTask</span>(<span style=color:#e6db74>&#34;NettyClientStream$Sink.cancel&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>io.grpc.netty.shaded.io.grpc.netty.NettyClientHandler#write</li></ul><p>在执行写入消息时，写入取消指令</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>write</span>(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) <span style=color:#66d9ef>throws</span> Exception {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (msg <span style=color:#66d9ef>instanceof</span> CreateStreamCommand) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>createStream</span>((CreateStreamCommand)msg, promise);
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (msg <span style=color:#66d9ef>instanceof</span> SendGrpcFrameCommand) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>sendGrpcFrame</span>(ctx, (SendGrpcFrameCommand)msg, promise);
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (msg <span style=color:#66d9ef>instanceof</span> CancelClientStreamCommand) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>cancelStream</span>(ctx, (CancelClientStreamCommand)msg, promise);
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (msg <span style=color:#66d9ef>instanceof</span> SendPingCommand) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>sendPingFrame</span>(ctx, (SendPingCommand)msg, promise);
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (msg <span style=color:#66d9ef>instanceof</span> GracefulCloseCommand) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>gracefulClose</span>(ctx, (GracefulCloseCommand)msg, promise);
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (msg <span style=color:#66d9ef>instanceof</span> ForcefulCloseCommand) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>forcefulClose</span>(ctx, (ForcefulCloseCommand)msg, promise);
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (msg <span style=color:#f92672>!=</span> NOOP_MESSAGE) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> AssertionError(<span style=color:#e6db74>&#34;Write called for unexpected type: &#34;</span> <span style=color:#f92672>+</span> msg.<span style=color:#a6e22e>getClass</span>().<span style=color:#a6e22e>getName</span>());
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        ctx.<span style=color:#a6e22e>write</span>(Unpooled.<span style=color:#a6e22e>EMPTY_BUFFER</span>, promise);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>io.grpc.netty.shaded.io.grpc.netty.NettyClientHandler#cancelStream</li></ul><p>执行取消命令的写入，在 transportReportStatus 会提交关闭监听器的指令，如果停止投递，同时也会选择执行或者延迟执行关闭帧
如果流存在，则会发送一个新的 RST_STREAM 请求，该请求表示当前流错误，错误状态为 CANCEL，即值为 8</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>cancelStream</span>(ChannelHandlerContext ctx, CancelClientStreamCommand cmd, ChannelPromise promise) {
</span></span><span style=display:flex><span>    TransportState stream <span style=color:#f92672>=</span> cmd.<span style=color:#a6e22e>stream</span>();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>        Status reason <span style=color:#f92672>=</span> cmd.<span style=color:#a6e22e>reason</span>();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (reason <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>            stream.<span style=color:#a6e22e>transportReportStatus</span>(reason, <span style=color:#66d9ef>true</span>, <span style=color:#66d9ef>new</span> Metadata());
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>cmd.<span style=color:#a6e22e>stream</span>().<span style=color:#a6e22e>isNonExistent</span>()) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>encoder</span>().<span style=color:#a6e22e>writeRstStream</span>(ctx, stream.<span style=color:#a6e22e>id</span>(), Http2Error.<span style=color:#a6e22e>CANCEL</span>.<span style=color:#a6e22e>code</span>(), promise);
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            promise.<span style=color:#a6e22e>setSuccess</span>();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>finally</span> {
</span></span><span style=display:flex><span>        PerfMark.<span style=color:#a6e22e>stopTask</span>(<span style=color:#e6db74>&#34;NettyClientHandler.cancelStream&#34;</span>, stream.<span style=color:#a6e22e>tag</span>());
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=服务端>服务端</h2><ul><li>io.grpc.netty.shaded.io.grpc.netty.NettyServerHandler.FrameListener#onRstStreamRead</li></ul><p>接收到的请求中，errorCode 为 8，代表请求被取消</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>onRstStreamRead</span>(ChannelHandlerContext ctx, <span style=color:#66d9ef>int</span> streamId, <span style=color:#66d9ef>long</span> errorCode) <span style=color:#66d9ef>throws</span> Http2Exception {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (NettyServerHandler.<span style=color:#a6e22e>this</span>.<span style=color:#a6e22e>keepAliveManager</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>        NettyServerHandler.<span style=color:#a6e22e>this</span>.<span style=color:#a6e22e>keepAliveManager</span>.<span style=color:#a6e22e>onDataReceived</span>();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    NettyServerHandler.<span style=color:#a6e22e>this</span>.<span style=color:#a6e22e>onRstStreamRead</span>(streamId, errorCode);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>io.grpc.netty.shaded.io.grpc.netty.NettyServerHandler#onRstStreamRead</li></ul><p>然后会在 NettyServerHandler 中根据 streamId 获取流，如果流存在，则会以 CANCELLED 状态取消当前请求
需要注意的是，如果接收到这个请求时流已经完成被清除，则可能无法处理，请求会以 OK 状态完成</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>onRstStreamRead</span>(<span style=color:#66d9ef>int</span> streamId, <span style=color:#66d9ef>long</span> errorCode) <span style=color:#66d9ef>throws</span> Http2Exception {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>        TransportState stream <span style=color:#f92672>=</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>serverStream</span>(<span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>connection</span>().<span style=color:#a6e22e>stream</span>(streamId));
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (stream <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>                stream.<span style=color:#a6e22e>transportReportStatus</span>(Status.<span style=color:#a6e22e>CANCELLED</span>.<span style=color:#a6e22e>withDescription</span>(<span style=color:#e6db74>&#34;RST_STREAM received for code &#34;</span> <span style=color:#f92672>+</span> errorCode));
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>catch</span> (Throwable var9) {
</span></span><span style=display:flex><span>        logger.<span style=color:#a6e22e>log</span>(Level.<span style=color:#a6e22e>WARNING</span>, <span style=color:#e6db74>&#34;Exception in onRstStreamRead()&#34;</span>, var9);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>newStreamException</span>(streamId, var9);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>io.grpc.internal.AbstractServerStream.TransportState#transportReportStatus</li></ul><p>如果解帧器已经关闭，则使用取消状态关闭监听器</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>transportReportStatus</span>(<span style=color:#66d9ef>final</span> Status status) {
</span></span><span style=display:flex><span>    Preconditions.<span style=color:#a6e22e>checkArgument</span>(<span style=color:#f92672>!</span>status.<span style=color:#a6e22e>isOk</span>(), <span style=color:#e6db74>&#34;status must not be OK&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 如果解帧器关闭，则关闭监听器</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (deframerClosed) {
</span></span><span style=display:flex><span>        deframerClosedTask <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>        closeListener(status);
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 如果解帧器还没有关闭，则创建关闭监听器的任务，并立即关闭解帧器</span>
</span></span><span style=display:flex><span>        deframerClosedTask <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Runnable() {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>run</span>() {
</span></span><span style=display:flex><span>                closeListener(status);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        };
</span></span><span style=display:flex><span>        immediateCloseRequested <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>        closeDeframer(<span style=color:#66d9ef>true</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>io.grpc.internal.AbstractServerStream.TransportState#closeListener</li></ul><p>使用指定状态关闭监听器</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>closeListener</span>(Status newStatus) {
</span></span><span style=display:flex><span>    Preconditions.<span style=color:#a6e22e>checkState</span>(<span style=color:#f92672>!</span>newStatus.<span style=color:#a6e22e>isOk</span>() <span style=color:#f92672>||</span> closedStatus <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>);
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 如果监听器没有关闭，则根据状态操作</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>listenerClosed) {
</span></span><span style=display:flex><span>        listenerClosed <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 通知流的状态不可以再使用</span>
</span></span><span style=display:flex><span>        onStreamDeallocated();
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 使用指定状态关闭监听器</span>
</span></span><span style=display:flex><span>        listener().<span style=color:#a6e22e>closed</span>(newStatus);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>io.grpc.internal.ServerImpl.JumpToApplicationThreadServerStreamListener#closedInternal</li></ul><p>使用 CANCELLED 状态，执行 ContextCloser 任务，取消上下文；然后提交 Closed 任务，取消
监听器</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>closedInternal</span>(<span style=color:#66d9ef>final</span> Status status) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 如果状态不是 OK，则直接提交关闭 Context 任务</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>status.<span style=color:#a6e22e>isOk</span>()) {
</span></span><span style=display:flex><span>        cancelExecutor.<span style=color:#a6e22e>execute</span>(<span style=color:#66d9ef>new</span> ContextCloser(context, status.<span style=color:#a6e22e>getCause</span>()));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Closed</span> <span style=color:#66d9ef>extends</span> ContextRunnable {
</span></span><span style=display:flex><span>        Closed() {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>super</span>(context);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>runInContext</span>() {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 调用监听器的关闭事件</span>
</span></span><span style=display:flex><span>                getListener().<span style=color:#a6e22e>closed</span>(status);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    callExecutor.<span style=color:#a6e22e>execute</span>(<span style=color:#66d9ef>new</span> Closed());
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>io.grpc.internal.ServerImpl.ContextCloser#run</li></ul><p>执行提交的 ContextCloser 任务，取消上下文</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>run</span>() {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 执行时使用指定异常关闭 Context</span>
</span></span><span style=display:flex><span>    context.<span style=color:#a6e22e>cancel</span>(cause);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>io.grpc.Context.CancellableContext#cancel</li></ul><p>执行 Context 取消事件，会修改 Context 的状态，取消等待的 deadline 任务，然后会通知并清除监听器</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>cancel</span>(Throwable cause) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>boolean</span> triggeredCancel <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>synchronized</span> (<span style=color:#66d9ef>this</span>) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 如果没有取消，则取消，并修改状态</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>cancelled) {
</span></span><span style=display:flex><span>            cancelled <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 如果有等待取消的任务，则取消</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (pendingDeadline <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>                pendingDeadline.<span style=color:#a6e22e>cancel</span>(<span style=color:#66d9ef>false</span>);
</span></span><span style=display:flex><span>                pendingDeadline <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>cancellationCause</span> <span style=color:#f92672>=</span> cause;
</span></span><span style=display:flex><span>            triggeredCancel <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 如果取消成功了，则通知监听器</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (triggeredCancel) {
</span></span><span style=display:flex><span>        notifyAndClearListeners();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> triggeredCancel;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>io.grpc.Context.CancellableContext#notifyAndClearListeners</li></ul><p>会通知当前的监听器进行取消，默认由两个监听器，一个是<code>CancellationListener</code>，用于取消当前上下文，另一个是 <code>ServerStreamCancellationListener</code> ，用于取消流；如果有其他的监听器，还会通知其他监听器取消，并移除监听器</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>notifyAndClearListeners</span>() {
</span></span><span style=display:flex><span>    ArrayList<span style=color:#f92672>&lt;</span>ExecutableListener<span style=color:#f92672>&gt;</span> tmpListeners;
</span></span><span style=display:flex><span>    CancellationListener tmpParentListener;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>synchronized</span> (<span style=color:#66d9ef>this</span>) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 如果没有监听器则返回</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (listeners <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        tmpParentListener <span style=color:#f92672>=</span> parentListener;
</span></span><span style=display:flex><span>        parentListener <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>        tmpListeners <span style=color:#f92672>=</span> listeners;
</span></span><span style=display:flex><span>        listeners <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 在取消之前先通知事件，优先通知当前上下文</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (ExecutableListener tmpListener : tmpListeners) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (tmpListener.<span style=color:#a6e22e>context</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>this</span>) {
</span></span><span style=display:flex><span>            tmpListener.<span style=color:#a6e22e>deliver</span>();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 通知其他的上下文</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (ExecutableListener tmpListener : tmpListeners) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>(tmpListener.<span style=color:#a6e22e>context</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>this</span>)) {
</span></span><span style=display:flex><span>            tmpListener.<span style=color:#a6e22e>deliver</span>();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 移除引用的监听器</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (cancellableAncestor <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>        cancellableAncestor.<span style=color:#a6e22e>removeListener</span>(tmpParentListener);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>io.grpc.internal.ServerCallImpl.ServerStreamListenerImpl#ServerStreamListenerImpl</li></ul><p>最终会调用构造 ServerStreamListenerImpl 时添加的 Context.CancellationListener 的 cancelled 方法，将 ServerCallImpl 的 cancelled 状态改为 true</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>context</span>.<span style=color:#a6e22e>addListener</span>(<span style=color:#66d9ef>new</span> Context.<span style=color:#a6e22e>CancellationListener</span>() {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>cancelled</span>(Context context) {
</span></span><span style=display:flex><span>        ServerStreamListenerImpl.<span style=color:#a6e22e>this</span>.<span style=color:#a6e22e>call</span>.<span style=color:#a6e22e>cancelled</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}, MoreExecutors.<span style=color:#a6e22e>directExecutor</span>());
</span></span></code></pre></div><ul><li>io.grpc.internal.ServerImpl.ServerTransportListenerImpl#StreamCreated$ServerStreamCancellationListener#cancelled</li></ul><p>执行创建流时添加的流取消监听器，如果没有异常信息，则会使用 <code>"io.grpc.Context was cancelled without error"</code>作为描述，更新状态</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>cancelled</span>(Context context) {
</span></span><span style=display:flex><span>    Status status <span style=color:#f92672>=</span> statusFromCancelled(context);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (DEADLINE_EXCEEDED.<span style=color:#a6e22e>getCode</span>().<span style=color:#a6e22e>equals</span>(status.<span style=color:#a6e22e>getCode</span>())) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// This should rarely get run, since the client will likely cancel the stream</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// before the timeout is reached.</span>
</span></span><span style=display:flex><span>        stream.<span style=color:#a6e22e>cancel</span>(status);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>io.grpc.internal.ServerCallImpl.ServerStreamListenerImpl#closedInternal</li></ul><p>在执行 OnClosed 任务时，会使用 CANCELLED 状态，触发 ServerCall.Listener 的 onCanncel 事件，如果有取消任务，会执行取消任务</p><p>另外，无论请求成功与否，都会执行 <code>context.cancel(null)</code>，通知 <code>notifyAndClearListeners</code>取消上下文监听器和流监听器，然后移除监听器</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>closedInternal</span>(Status status) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 如果状态是 OK，通知监听器完成</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (status.<span style=color:#a6e22e>isOk</span>()) {
</span></span><span style=display:flex><span>            listener.<span style=color:#a6e22e>onComplete</span>();
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 否则将状态改为取消，通知监听器取消</span>
</span></span><span style=display:flex><span>            call.<span style=color:#a6e22e>cancelled</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>            listener.<span style=color:#a6e22e>onCancel</span>();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>finally</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 取消上下文</span>
</span></span><span style=display:flex><span>        context.<span style=color:#a6e22e>cancel</span>(<span style=color:#66d9ef>null</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></section><div class=paginator><a class=prev href=https://blog.hellowood.dev/posts/%E6%A0%91%E8%8E%93%E6%B4%BE-4b-%E4%BD%BF%E7%94%A8-wifi-%E4%BB%8E-ssd-headless-%E5%90%AF%E5%8A%A8/><svg class="icon" width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M3.77086 21.1546C11.0491 22.698 21.4339 21.7773 21.4339 16.3608V4.63375c0-.69413-.075800000000001-1.3284-.2422-1.86588M3.77086 21.1546C1.9934 20.7777.973585 18.7264 1.08749 16.688c.17931-3.209.06972-7.25665-.08236-10.47293C.87809 3.52811 3.12891 1.16316 5.51029 1.25008c4.25565.15534 9.86671-.04779 13.28091-.24466 1.2952-.074686 2.0494.62843 2.4005 1.76245M3.77086 21.1546C4.56586 21.4723 5.49168 21.7879 6.5 22.0658M21.1917 2.76787c1.918 1.4143 1.9383 9.65123 1.7087 13.59293-2.0526 7.6586-10.5943 7.3054-16.4004 5.705M21.1917 2.76787C21.7612 4.51192 22.7203 9.67216 22 16.3608 21.2797 23.0494 11.3665 22.9511 6.5 22.0658M9.94496 9C9.28897 9.61644 7.63215 10.997 6.04814 11.7966 5.98257 11.8297 5.98456 11.9753 6.05061 12.0063c1.00435.4716 2.8788 1.9201 3.89435 2.9937M6.44444 11.9667C8.86549 12.0608 14 12 16 11" stroke="currentcolor" stroke-linecap="round"/></svg>
<span>树莓派 4b 使用 WiFi 从 SSD Headless 启动</span></a>
<a class=next href=https://blog.hellowood.dev/posts/grpc-%E6%9C%8D%E5%8A%A1%E9%97%B4%E8%B0%83%E7%94%A8%E4%BA%8B%E4%BB%B6%E6%B5%81%E7%A8%8B/><span>gRPC 服务间调用事件流程</span><svg class="icon" width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M3.77086 21.1546C11.0491 22.698 21.4339 21.7773 21.4339 16.3608V4.63375c0-.69413-.075800000000001-1.3284-.2422-1.86588M3.77086 21.1546C1.9934 20.7777.973585 18.7264 1.08749 16.688c.17931-3.209.06972-7.25665-.08236-10.47293C.87809 3.52811 3.12891 1.16316 5.51029 1.25008c4.25565.15534 9.86671-.04779 13.28091-.24466 1.2952-.074686 2.0494.62843 2.4005 1.76245M3.77086 21.1546C4.56586 21.4723 5.49168 21.7879 6.5 22.0658M21.1917 2.76787c1.918 1.4143 1.9383 9.65123 1.7087 13.59293-2.0526 7.6586-10.5943 7.3054-16.4004 5.705M21.1917 2.76787C21.7612 4.51192 22.7203 9.67216 22 16.3608 21.2797 23.0494 11.3665 22.9511 6.5 22.0658M12.055 9C12.711 9.61644 14.3679 10.997 15.9519 11.7966 16.0174 11.8297 16.0154 11.9753 15.9494 12.0063 14.945 12.4779 13.0706 13.9264 12.055 15m3.5006-3.0333C13.1345 12.0608 8 12 6 11" stroke="currentcolor" stroke-linecap="round"/></svg></a></div></article></div><footer class=footer><p>&copy; 2024 <a href=https://blog.hellowood.dev/>HelloWood</a>
Powered by
<a href=https://gohugo.io/ rel=noopener target=_blank data-umami-event=to-hugo>Hugo️️</a>
<a href=https://github.com/guangzhengli/hugo-theme-ladder rel=noopener target=_blank data-umami-event=to-ladder>Ladder</a>
️</p></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g data-umami-event=top-link><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M10.5376 22.7916C11.0152 22.7207 22.5795 21.1781 22.0978 10.4211 22.0536 9.43274 21.9303 8.53367 21.7387 7.71865M10.5376 22.7916C16.876 22.3728 20.0969 19.8899 21.5383 16.9142M10.5376 22.7916C9.7707 22.9055 8.97982 22.8964 8.19743 22.7725M21.7387 7.71865C21.4988 6.69828 21.1518 5.80967 20.7188 5.04257m1.0199 2.67608C22.6022 10.1105 23.0542 13.7848 21.5383 16.9142M20.7188 5.04257c-3.5504-6.28886-12.88753-4.410077-16.44303.0C2.88063 6.77451-.0433281 11.1668 1.38159 16.6571c.89322 3.4417 3.7911 5.6365 6.81584 6.1154M20.7188 5.04257c1.3509 1.89783 3.3111 6.34223 1.6353 10.37273M21.5383 16.9142C21.8737 16.4251 22.1428 15.9235 22.3541 15.4153M8.19743 22.7725C12.1971 23.4683 20.6281 22.971 22.3541 15.4153M14 10.945C13.3836 10.289 12.003 8.63215 11.2034 7.04814 11.1703 6.98257 11.0247 6.98456 10.9937 7.05061 10.5221 8.05496 9.07362 9.92941 8 10.945m3.0333-3.50056C10.9392 9.86549 11 15 12 17" stroke="currentcolor" stroke-linecap="round"/></svg>
</a><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const s=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="Copy";function n(){t.innerHTML="Copied",setTimeout(()=>{t.innerHTML="Copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),n();return}const s=document.createRange();s.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(s);try{document.execCommand("copy"),n()}catch{}o.removeRange(s)}),e.parentNode.appendChild(t)})</script></main></body><script src=https://cdnjs.cloudflare.com/ajax/libs/medium-zoom/1.0.6/medium-zoom.min.js integrity="sha512-N9IJRoc3LaP3NDoiGkcPa4gG94kapGpaA5Zq9/Dr04uf5TbLFU5q0o8AbRhLKUUlp8QFS2u7S+Yti0U7QtuZvQ==" crossorigin=anonymous referrerpolicy=no-referrer></script><script>const images=Array.from(document.querySelectorAll(".blog-content img"));images.forEach(e=>{mediumZoom(e,{margin:10,scrollOffset:40,container:null,template:null,background:"rgba(0, 0, 0, 0.5)"})})</script><script src=/main.min.6bb26b69159420159c74dc9e097b06a578ed2b68c701466a91a44a9632d851bd0af167a1b30012387b4c512b48ad9ad4d3394e04d77ae38d57e1920fe4ed34fe.js integrity="sha512-a7JraRWUIBWcdNyeCXsGpXjtK2jHAUZqkaRKljLYUb0K8WehswASOHtMUStIrZrU0zlOBNd6441X4ZIP5O00/g==" crossorigin=anonymous defer></script></html>