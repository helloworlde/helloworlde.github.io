<!doctype html><html lang=en><head><meta name=viewport content="width=device-width,initial-scale=1"><title>Thrfit 服务端请求处理流程</title>
<meta charset=utf-8><meta name=description content="Ladder@Thrfit 服务端请求处理流程 使用同步的非阻塞的服务端的请求处理流程
实现 IDL helloworld.thrift namespace java io.github.helloworlde.thrift struct HelloMessage { 1: required string message, } struct HelloResponse { 1: required string message, } service HelloService { HelloResponse sayHello(1: HelloMessage request); } 服务端实现 使用 TThreadedSelectorServer 作为服务端，支持接收连接，处理 IO 事件，执行请求由不同的线程实现；底层连接使用 ServerSocket
public class NonblockingServer { @SneakyThrows public static void main(String[] args) { HelloServiceImpl helloService = new HelloServiceImpl(); HelloService.Processor<HelloService.Iface> helloServiceProcessor = new HelloService.Processor<>(helloService); TNonblockingServerTransport transport = new TNonblockingServerSocket(9090); // 配置参数以及处理器 TThreadedSelectorServer.Args serverArgs = new TThreadedSelectorServer."><meta name=author content="HelloWood"><link rel=canonical href=https://blog.hellowood.dev/posts/thrfit-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B/><meta name=google-site-verification content="G-3MSGPYTHPZ"><link rel=alternate type=application/rss+xml href=https://blog.hellowood.dev//index.xml title=HelloWood><script async src="https://www.googletagmanager.com/gtag/js?id=G-3MSGPYTHPZ"></script><script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-3MSGPYTHPZ",{anonymize_ip:!1})}</script><script async defer data-website-id=7a9034de-0ce7-4756-942a-829e6cd22301 src=https://umami.hellowood.dev/script.js></script><script defer data-cf-beacon='{"token": "b2e481d136dc428c8c96c8673e2a04cf"}' src=https://static.cloudflareinsights.com/beacon.min.js></script><meta property="og:title" content="Thrfit 服务端请求处理流程"><meta property="og:description" content="Thrfit 服务端请求处理流程 使用同步的非阻塞的服务端的请求处理流程
实现 IDL helloworld.thrift namespace java io.github.helloworlde.thrift struct HelloMessage { 1: required string message, } struct HelloResponse { 1: required string message, } service HelloService { HelloResponse sayHello(1: HelloMessage request); } 服务端实现 使用 TThreadedSelectorServer 作为服务端，支持接收连接，处理 IO 事件，执行请求由不同的线程实现；底层连接使用 ServerSocket
public class NonblockingServer { @SneakyThrows public static void main(String[] args) { HelloServiceImpl helloService = new HelloServiceImpl(); HelloService.Processor<HelloService.Iface> helloServiceProcessor = new HelloService.Processor<>(helloService); TNonblockingServerTransport transport = new TNonblockingServerSocket(9090); // 配置参数以及处理器 TThreadedSelectorServer.Args serverArgs = new TThreadedSelectorServer."><meta property="og:type" content="article"><meta property="og:url" content="https://blog.hellowood.dev/posts/thrfit-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-02-20T22:34:46+00:00"><meta property="article:modified_time" content="2021-02-20T22:34:46+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Thrfit 服务端请求处理流程"><meta name=twitter:description content="Thrfit 服务端请求处理流程 使用同步的非阻塞的服务端的请求处理流程
实现 IDL helloworld.thrift namespace java io.github.helloworlde.thrift struct HelloMessage { 1: required string message, } struct HelloResponse { 1: required string message, } service HelloService { HelloResponse sayHello(1: HelloMessage request); } 服务端实现 使用 TThreadedSelectorServer 作为服务端，支持接收连接，处理 IO 事件，执行请求由不同的线程实现；底层连接使用 ServerSocket
public class NonblockingServer { @SneakyThrows public static void main(String[] args) { HelloServiceImpl helloService = new HelloServiceImpl(); HelloService.Processor<HelloService.Iface> helloServiceProcessor = new HelloService.Processor<>(helloService); TNonblockingServerTransport transport = new TNonblockingServerSocket(9090); // 配置参数以及处理器 TThreadedSelectorServer.Args serverArgs = new TThreadedSelectorServer."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.hellowood.dev/posts/"},{"@type":"ListItem","position":2,"name":"Thrfit 服务端请求处理流程","item":"https://blog.hellowood.dev/posts/thrfit-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Thrfit 服务端请求处理流程","name":"Thrfit 服务端请求处理流程","description":"Thrfit 服务端请求处理流程 使用同步的非阻塞的服务端的请求处理流程\n实现 IDL helloworld.thrift namespace java io.github.helloworlde.thrift struct HelloMessage { 1: required string message, } struct HelloResponse { 1: required string message, } service HelloService { HelloResponse sayHello(1: HelloMessage request); } 服务端实现 使用 TThreadedSelectorServer 作为服务端，支持接收连接，处理 IO 事件，执行请求由不同的线程实现；底层连接使用 ServerSocket\npublic class NonblockingServer { @SneakyThrows public static void main(String[] args) { HelloServiceImpl helloService = new HelloServiceImpl(); HelloService.Processor\u0026lt;HelloService.Iface\u0026gt; helloServiceProcessor = new HelloService.Processor\u0026lt;\u0026gt;(helloService); TNonblockingServerTransport transport = new TNonblockingServerSocket(9090); // 配置参数以及处理器 TThreadedSelectorServer.Args serverArgs = new TThreadedSelectorServer.","keywords":["Thrift"],"articleBody":"Thrfit 服务端请求处理流程 使用同步的非阻塞的服务端的请求处理流程\n实现 IDL helloworld.thrift namespace java io.github.helloworlde.thrift struct HelloMessage { 1: required string message, } struct HelloResponse { 1: required string message, } service HelloService { HelloResponse sayHello(1: HelloMessage request); } 服务端实现 使用 TThreadedSelectorServer 作为服务端，支持接收连接，处理 IO 事件，执行请求由不同的线程实现；底层连接使用 ServerSocket\npublic class NonblockingServer { @SneakyThrows public static void main(String[] args) { HelloServiceImpl helloService = new HelloServiceImpl(); HelloService.Processor\u003cHelloService.Iface\u003e helloServiceProcessor = new HelloService.Processor\u003c\u003e(helloService); TNonblockingServerTransport transport = new TNonblockingServerSocket(9090); // 配置参数以及处理器 TThreadedSelectorServer.Args serverArgs = new TThreadedSelectorServer.Args(transport) .selectorThreads(4) .workerThreads(10) .acceptQueueSizePerThread(20) .processor(helloServiceProcessor); TServer server = new TThreadedSelectorServer(serverArgs); server.serve(); } } 请求处理流程 1. 启动 Server TServer server = new TThreadedSelectorServer(serverArgs); server.serve(); org.apache.thrift.server.AbstractNonblockingServer#serve 启动 Server，启动用于连接的线程 AcceptThread 和用于处理 IO 事件的多个线程 SelectorThread；然后开始监听 IO 事件，由线程池处理请求\npublic void serve() { // 启动 if (!startThreads()) { return; } // 开始监听 if (!startListening()) { return; } // 修改状态 setServing(true); // 阻塞直到关闭 waitForShutdown(); setServing(false); // 停止监听器 stopListening(); } org.apache.thrift.server.TThreadedSelectorServer#startThreads 启动用于连接的线程 AcceptThread 和用于处理 IO 事件的多个线程 SelectorThread\nprotected boolean startThreads() { try { // 创建选择线程，并添加到集合中 for (int i = 0; i \u003c args.selectorThreads; ++i) { selectorThreads.add(new SelectorThread(args.acceptQueueSizePerThread)); } // 创建处理连接的负载均衡， 创建处理连接的线程 acceptThread = new AcceptThread((TNonblockingServerTransport) serverTransport_, createSelectorThreadLoadBalancer(selectorThreads)); // 启动选择线程 for (SelectorThread thread : selectorThreads) { thread.start(); } // 启动连接的线程 acceptThread.start(); return true; } catch (IOException e) { LOGGER.error(\"Failed to start threads!\", e); return false; } } org.apache.thrift.transport.TNonblockingServerSocket#listen 开始监听\npublic void listen() throws TTransportException { // Make sure not to block on accept if (serverSocket_ != null) { try { serverSocket_.setSoTimeout(0); } catch (SocketException sx) { LOGGER.error(\"Socket exception while setting socket timeout\", sx); } } } 2. 处理连接事件 org.apache.thrift.server.TThreadedSelectorServer.AcceptThread#run 连接事件由 AcceptThread 线程独立处理；会循环监听 Selector事件，当有新的连接事件时，会建立连接\npublic void run() { try { if (eventHandler_ != null) { // 通知 Server 开始启动 eventHandler_.preServe(); } while (!stopped_) { // 选择处理连接 select(); } } finally { acceptSelector.close(); TThreadedSelectorServer.this.stop(); } } org.apache.thrift.server.TThreadedSelectorServer.AcceptThread#select 会不断从 Selector获取事件，判断如果是 accept 事件，则处理，并建立连接\nprivate void select() { try { // 等待连接事件 acceptSelector.select(); // 处理接收到的事件 Iterator\u003cSelectionKey\u003e selectedKeys = acceptSelector.selectedKeys().iterator(); while (!stopped_ \u0026\u0026 selectedKeys.hasNext()) { SelectionKey key = selectedKeys.next(); selectedKeys.remove(); if (!key.isValid()) { continue; } if (key.isAcceptable()) { // 建立连接 handleAccept(); } else { LOGGER.warn(\"Unexpected state in select! \" + key.interestOps()); } } } catch (IOException e) { LOGGER.warn(\"Got an IOException while selecting!\", e); } } org.apache.thrift.server.TThreadedSelectorServer.AcceptThread#handleAccept 会通过底层的 ServerSocketChannel 建立连接，然后将这个连接添加到 SelectorThread 的队列中，由 SelectorThread处理 IO 事件\nprivate void handleAccept() { // 建立连接 final TNonblockingTransport client = doAccept(); if (client != null) { // 将连接传递给选择线程 final SelectorThread targetThread = threadChooser.nextThread(); // 如果策略是尽快建立连接，则添加到处理的队列中 if (args.acceptPolicy == Args.AcceptPolicy.FAST_ACCEPT || invoker == null) { doAddAccept(targetThread, client); } else { try { // 如果是 FAIR_ACCEPT，则提交异步任务进行添加 invoker.submit(new Runnable() { public void run() { doAddAccept(targetThread, client); } }); } catch (RejectedExecutionException rx) { LOGGER.warn(\"ExecutorService rejected accept registration!\", rx); // close immediately client.close(); } } } } org.apache.thrift.transport.TNonblockingServerSocket#acceptImpl 建立连接，返回新的 TNonblockingSocket\nprotected TNonblockingSocket acceptImpl() throws TTransportException { if (serverSocket_ == null) { throw new TTransportException(TTransportException.NOT_OPEN, \"No underlying server socket.\"); } try { // 接受连接 SocketChannel socketChannel = serverSocketChannel.accept(); if (socketChannel == null) { return null; } // 使用 Channel 构建 Socket TNonblockingSocket tsocket = new TNonblockingSocket(socketChannel); tsocket.setTimeout(clientTimeout_); return tsocket; } catch (IOException iox) { throw new TTransportException(iox); } } org.apache.thrift.server.TThreadedSelectorServer.SelectorThread#addAcceptedConnection 将连接添加到 SelectorThread的队列中，由 SelectorThread处理 IO 事件\npublic boolean addAcceptedConnection(TNonblockingTransport accepted) { try { // 放入队列中 acceptedQueue.put(accepted); } catch (InterruptedException e) { LOGGER.warn(\"Interrupted while adding accepted connection!\", e); return false; } selector.wakeup(); return true; } 3. 处理 IO 事件 IO 事件由 SelectorThread 处理\norg.apache.thrift.server.TThreadedSelectorServer.SelectorThread#run 轮询读取事件，如果是 IO 事件，则分别处理；如果是新的连接，则注册 Selector\npublic void run() { try { while (!stopped_) { // 选择读取或写入事件 select(); // 处理新的连接 processAcceptedConnections(); // 改变需要改变的状态 processInterestChanges(); } // 如果停止了，则清理选择 for (SelectionKey selectionKey : selector.keys()) { cleanupSelectionKey(selectionKey); } } catch (Throwable t) { LOGGER.error(\"run() on SelectorThread exiting due to uncaught error\", t); } finally { // 关闭 selector.close(); TThreadedSelectorServer.this.stop(); } } org.apache.thrift.server.TThreadedSelectorServer.SelectorThread#select 处理 IO 事件，根据事件类型分别处理读取或者写入\nprivate void select() { try { // 获取事件 doSelect(); Iterator\u003cSelectionKey\u003e selectedKeys = selector.selectedKeys().iterator(); while (!stopped_ \u0026\u0026 selectedKeys.hasNext()) { SelectionKey key = selectedKeys.next(); selectedKeys.remove(); // 如果无效则跳过 if (!key.isValid()) { cleanupSelectionKey(key); continue; } if (key.isReadable()) { // 如果是读取则处理读取事件 handleRead(key); } else if (key.isWritable()) { // 如果是写入则处理写入 handleWrite(key); } else { LOGGER.warn(\"Unexpected state in select! \" + key.interestOps()); } } } catch (IOException e) { LOGGER.warn(\"Got an IOException while selecting!\", e); } } 处理读取事件 org.apache.thrift.server.AbstractNonblockingServer.AbstractSelectThread#handleRead 在处理读取事件时，会读取整个帧，当完全读取时，会调用 requestInvoke 方法，通过线程池处理请求\nprotected void handleRead(SelectionKey key) { // 获取帧 FrameBuffer buffer = (FrameBuffer) key.attachment(); // 如果没有可读取的，则清理 if (!buffer.read()) { cleanupSelectionKey(key); return; } // if the buffer's frame read is complete, invoke the method. // 如果 buffer 完全读取，则执行处理，如果失败则清理 if (buffer.isFrameFullyRead()) { if (!requestInvoke(buffer)) { cleanupSelectionKey(key); } } } org.apache.thrift.server.TThreadedSelectorServer#requestInvoke 处理调用，会将帧封装为 Runnable 任务，提交给线程池执行\nprotected boolean requestInvoke(FrameBuffer frameBuffer) { // 封装为 Runnable Runnable invocation = getRunnable(frameBuffer); if (invoker != null) { try { // 执行处理 invoker.execute(invocation); return true; } catch (RejectedExecutionException rx) { LOGGER.warn(\"ExecutorService rejected execution!\", rx); return false; } } else { // Invoke on the caller's thread // 如果没有线程池，由当前线程直接处理 invocation.run(); return true; } } 处理写入事件 org.apache.thrift.server.AbstractNonblockingServer.AbstractSelectThread#handleWrite 处理写入事件，调用 FrameBuffer 的写入方法进行处理\nprotected void handleWrite(SelectionKey key) { FrameBuffer buffer = (FrameBuffer) key.attachment(); if (!buffer.write()) { cleanupSelectionKey(key); } } org.apache.thrift.server.AbstractNonblockingServer.FrameBuffer#write 由 Transport 执行写入，最终由 SocketChannel 执行，将响应内容发送给客户端\npublic boolean write() { if (state_ == FrameBufferState.WRITING) { // 写入 if (trans_.write(buffer_) \u003c 0) { return false; } // 如果没有待写入的，则切换到读取 if (buffer_.remaining() == 0) { prepareRead(); } return true; } return false; } 4. 执行请求 org.apache.thrift.server.AbstractNonblockingServer.FrameBuffer#invoke 在处理读取事件时，会将 FrameBuffer 包装为 Runnable，提交给线程池执行；最终由 FrameBuffer处理 会获取 Processor，然后调用 process 方法进行处理\npublic void invoke() { frameTrans_.reset(buffer_.array()); response_.reset(); try { // 如果有事件处理器，则触发 if (eventHandler_ != null) { eventHandler_.processContext(context_, inTrans_, outTrans_); } // 获取处理器，调用处理方法 processorFactory_.getProcessor(inTrans_).process(inProt_, outProt_); responseReady(); return; } catch (TException te) { } // This will only be reached when there is a throwable. state_ = FrameBufferState.AWAITING_CLOSE; requestSelectInterestChange(); } org.apache.thrift.TBaseProcessor#process 在处理时，根据方法名获取具体的处理函数，然后调用响应的处理方法进行处理\npublic void process(TProtocol in, TProtocol out) throws TException { TMessage msg = in.readMessageBegin(); ProcessFunction fn = processMap.get(msg.name); if (fn == null) { TProtocolUtil.skip(in, TType.STRUCT); in.readMessageEnd(); TApplicationException x = new TApplicationException(TApplicationException.UNKNOWN_METHOD, \"Invalid method name: '\"+msg.name+\"'\"); out.writeMessageBegin(new TMessage(msg.name, TMessageType.EXCEPTION, msg.seqid)); x.write(out); out.writeMessageEnd(); out.getTransport().flush(); } else { fn.process(msg.seqid, in, out, iface); } } org.apache.thrift.ProcessFunction#process 读取请求信息，反序列化为对象，然后调用 getResult 方法执行实现逻辑，获取响应；如果不是 oneway 的请求，则将相应结果写入流中，发送给客户端\npublic final void process(int seqid, TProtocol iprot, TProtocol oprot, I iface) throws TException { // 获取空参数实例 T args = getEmptyArgsInstance(); // 读取 args.read(iprot); iprot.readMessageEnd(); TSerializable result = null; byte msgType = TMessageType.REPLY; // 获取结果 result = getResult(iface, args); // 如果不是 oneway 的，则写入响应结果 if (!isOneway()) { oprot.writeMessageBegin(new TMessage(getMethodName(), msgType, seqid)); result.write(oprot); oprot.writeMessageEnd(); oprot.getTransport().flush(); } } io.github.helloworlde.thrift.HelloService.Processor.sayHello#getResult 由生成的代码处理，会先构建一个响应结构体，然后调用相应的方法进行处理，返回结果\npublic sayHello_result getResult(I iface, sayHello_args args) throws org.apache.thrift.TException { sayHello_result result = new sayHello_result(); result.success = iface.sayHello(args.request); return result; } io.github.helloworlde.thrift.HelloServiceImpl#sayHello 具体的逻辑处理，返回响应\npublic HelloResponse sayHello(HelloMessage request) throws TException { String message = request.getMessage(); HelloResponse response = new HelloResponse(); response.setMessage(\"Hello \" + message); return response; } 4. 写入响应 org.apache.thrift.ProcessFunction#process 在处理完请求之后，会判断是否是 oneway 请求，如果不是，则会执行写入响应\nif(!isOneway()) { oprot.writeMessageBegin(new TMessage(getMethodName(), msgType, seqid)); result.write(oprot); oprot.writeMessageEnd(); oprot.getTransport().flush(); } org.apache.thrift.protocol.TBinaryProtocol#writeMessageBegin 写入响应时，会先写入响应头；会将版本信息，消息类型，方法的名称和请求 ID 一起写入\npublic void writeMessageBegin(TMessage message) throws TException { if (strictWrite_) { int version = VERSION_1 | message.type; writeI32(version); writeString(message.name); writeI32(message.seqid); } else { writeString(message.name); writeByte(message.type); writeI32(message.seqid); } } io.github.helloworlde.thrift.HelloResponse.HelloResponseStandardScheme#write 随后写入响应内容，将对象序列化为字节\npublic void write(org.apache.thrift.protocol.TProtocol oprot, HelloResponse struct) throws org.apache.thrift.TException { struct.validate(); oprot.writeStructBegin(STRUCT_DESC); if (struct.message != null) { oprot.writeFieldBegin(MESSAGE_FIELD_DESC); oprot.writeString(struct.message); oprot.writeFieldEnd(); } oprot.writeFieldStop(); oprot.writeStructEnd(); } 然后会写入响应结尾符，由 SelectorThread 处理写入事件，最终将请求发送给客户端\n参考文档 helloworlde/thrift-java-sample ","wordCount":"1121","inLanguage":"en","datePublished":"2021-02-20T22:34:46Z","dateModified":"2021-02-20T22:34:46Z","author":{"@type":"Person","name":"HelloWood"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.hellowood.dev/posts/thrfit-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B/"},"publisher":{"@type":"Organization","name":"HelloWood","logo":{"@type":"ImageObject","url":"https://blog.hellowood.dev/favicon.ico"}}}</script><link rel=icon href=/images/avatar.png sizes=16x16><link rel=apple-touch-icon href=/images/avatar.png><link rel=manifest href=/images/avatar.png><link rel=stylesheet href=https://cdn.staticfile.org/lxgw-wenkai-webfont/1.6.0/style.css><link rel=stylesheet href=/css/main.min.ff1bc260fafbfb440e10194d7d06d57eb5e85eed11d12d06255581262664204e.css integrity="sha256-/xvCYPr7+0QOEBlNfQbVfrXoXu0R0S0GJVWBJiZkIE4=" crossorigin=anonymous media=screen><link rel=stylesheet href=/scss/highlight/github-dark.min.min.66034289ee9a113219a2c4aae0a8bd2095ab255c832a42efcf5863f10814e7a1.css><script src=/js/highlight.min.min.c607d6febd16934a82eb61d3a896ed9d869f54373cc63ce95864ed5488fe3128.js></script><script>hljs.highlightAll()</script><script>(()=>{var t=window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches,e=localStorage.getItem("theme");t&&e===null&&(localStorage.setItem("theme","dark"),document.documentElement.setAttribute("data-dark-mode","")),t&&e==="dark"&&document.documentElement.setAttribute("data-dark-mode",""),e==="dark"&&document.documentElement.setAttribute("data-dark-mode","")})()</script><meta name=google-adsense-account content="ca-pub-3401351766168985"><script type=text/javascript>(function(e,t,n,s,o,i,a){e[n]=e[n]||function(){(e[n].q=e[n].q||[]).push(arguments)},i=t.createElement(s),i.async=1,i.src="https://www.clarity.ms/tag/"+o,a=t.getElementsByTagName(s)[0],a.parentNode.insertBefore(i,a)})(window,document,"clarity","script","jtbhx98g62")</script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3401351766168985" crossorigin=anonymous></script></head><body><main class=wrapper><nav class=navigation><section class=container><a class=navigation-brand data-umami-event=navigation-brand href=/>HOME
</a><input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><span></span><span></span><span></span></label><ul class=navigation-list id=navigation-list><li class="navigation-item navigation-menu"><a class=navigation-link data-umami-event=Blog href=/posts>Blog</a></li><li class="navigation-item navigation-menu"><a class=navigation-link data-umami-event=Tags href=/tags>Tags</a></li><li class="navigation-item navigation-menu"><a class=navigation-link data-umami-event=Archive href=/archives>Archive</a></li><li class="navigation-item navigation-menu"><a class=navigation-link data-umami-event=Dashboard href=https://umami.hellowood.dev/share/lab/Blog>Dashboard</a></li><li class="navigation-item menu-separator"><span>|</span></li><li class="navigation-item navigation-social"><a class=navigation-link data-umami-event=navigation-social href=https://github.com/helloworlde><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a></li><li class="navigation-item navigation-dark"><button id=mode type=button data-umami-event=toggle-theme aria-label="toggle user light or dark theme">
<span class=toggle-dark><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-moon"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg></span>
<span class=toggle-light><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-sun"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></span></button></li></ul></section></nav><div id=content><article class=blog-single><header class=blog-title><h1>Thrfit 服务端请求处理流程</h1></header><p><small>February 20, 2021&nbsp;· 1121 words&nbsp;· 6 min</small><p><div class=blog-toc><nav id=TableOfContents><ul><li><a href=#实现>实现</a><ul><li><a href=#idl>IDL</a></li><li><a href=#服务端实现>服务端实现</a></li></ul></li><li><a href=#请求处理流程>请求处理流程</a><ul><li><a href=#1-启动-server>1. 启动 Server</a></li><li><a href=#2-处理连接事件>2. 处理连接事件</a></li><li><a href=#3-处理-io-事件>3. 处理 IO 事件</a></li><li><a href=#4-执行请求>4. 执行请求</a></li><li><a href=#4-写入响应>4. 写入响应</a></li></ul></li><li><a href=#参考文档>参考文档</a></li></ul></nav></div><section class=blog-content><h1 id=thrfit-服务端请求处理流程>Thrfit 服务端请求处理流程</h1><p>使用同步的非阻塞的服务端的请求处理流程</p><h2 id=实现>实现</h2><h3 id=idl>IDL</h3><ul><li>helloworld.thrift</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-thrift data-lang=thrift><span style=display:flex><span><span style=color:#f92672>namespace</span> java io.github.helloworlde.thrift
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>HelloMessage</span> {
</span></span><span style=display:flex><span>    <span style=color:#ae81ff>1</span>: <span style=color:#66d9ef>required</span> <span style=color:#66d9ef>string</span> message,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>HelloResponse</span> {
</span></span><span style=display:flex><span>    <span style=color:#ae81ff>1</span>: <span style=color:#66d9ef>required</span> <span style=color:#66d9ef>string</span> message,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>service</span> <span style=color:#a6e22e>HelloService</span> {
</span></span><span style=display:flex><span>    HelloResponse <span style=color:#a6e22e>sayHello</span><span style=color:#f92672>(</span><span style=color:#ae81ff>1</span>: HelloMessage request);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=服务端实现>服务端实现</h3><p>使用 <code>TThreadedSelectorServer</code> 作为服务端，支持接收连接，处理 IO 事件，执行请求由不同的线程实现；底层连接使用 <code>ServerSocket</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>NonblockingServer</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@SneakyThrows</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        HelloServiceImpl helloService <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> HelloServiceImpl();
</span></span><span style=display:flex><span>        HelloService.<span style=color:#a6e22e>Processor</span><span style=color:#f92672>&lt;</span>HelloService.<span style=color:#a6e22e>Iface</span><span style=color:#f92672>&gt;</span> helloServiceProcessor <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> HelloService.<span style=color:#a6e22e>Processor</span><span style=color:#f92672>&lt;&gt;</span>(helloService);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        TNonblockingServerTransport transport <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> TNonblockingServerSocket(9090);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 配置参数以及处理器</span>
</span></span><span style=display:flex><span>        TThreadedSelectorServer.<span style=color:#a6e22e>Args</span> serverArgs <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> TThreadedSelectorServer.<span style=color:#a6e22e>Args</span>(transport)
</span></span><span style=display:flex><span>                .<span style=color:#a6e22e>selectorThreads</span>(4)
</span></span><span style=display:flex><span>                .<span style=color:#a6e22e>workerThreads</span>(10)
</span></span><span style=display:flex><span>                .<span style=color:#a6e22e>acceptQueueSizePerThread</span>(20)
</span></span><span style=display:flex><span>                .<span style=color:#a6e22e>processor</span>(helloServiceProcessor);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        TServer server <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> TThreadedSelectorServer(serverArgs);
</span></span><span style=display:flex><span>        server.<span style=color:#a6e22e>serve</span>();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=请求处理流程>请求处理流程</h2><h3 id=1-启动-server>1. 启动 Server</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>TServer server <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> TThreadedSelectorServer(serverArgs);
</span></span><span style=display:flex><span>server.<span style=color:#a6e22e>serve</span>();
</span></span></code></pre></div><ul><li>org.apache.thrift.server.AbstractNonblockingServer#serve</li></ul><p>启动 Server，启动用于连接的线程 <code>AcceptThread</code> 和用于处理 IO 事件的多个线程 <code>SelectorThread</code>；然后开始监听 IO 事件，由线程池处理请求</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>serve</span>() {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 启动</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>startThreads()) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 开始监听</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>startListening()) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 修改状态</span>
</span></span><span style=display:flex><span>    setServing(<span style=color:#66d9ef>true</span>);
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 阻塞直到关闭</span>
</span></span><span style=display:flex><span>    waitForShutdown();
</span></span><span style=display:flex><span>    setServing(<span style=color:#66d9ef>false</span>);
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 停止监听器</span>
</span></span><span style=display:flex><span>    stopListening();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>org.apache.thrift.server.TThreadedSelectorServer#startThreads</li></ul><p>启动用于连接的线程 <code>AcceptThread</code> 和用于处理 IO 事件的多个线程 <code>SelectorThread</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>startThreads</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 创建选择线程，并添加到集合中</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 0; i <span style=color:#f92672>&lt;</span> args.<span style=color:#a6e22e>selectorThreads</span>; <span style=color:#f92672>++</span>i) {
</span></span><span style=display:flex><span>            selectorThreads.<span style=color:#a6e22e>add</span>(<span style=color:#66d9ef>new</span> SelectorThread(args.<span style=color:#a6e22e>acceptQueueSizePerThread</span>));
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 创建处理连接的负载均衡， 创建处理连接的线程</span>
</span></span><span style=display:flex><span>        acceptThread <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> AcceptThread((TNonblockingServerTransport) serverTransport_, createSelectorThreadLoadBalancer(selectorThreads));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 启动选择线程</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (SelectorThread thread : selectorThreads) {
</span></span><span style=display:flex><span>            thread.<span style=color:#a6e22e>start</span>();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 启动连接的线程</span>
</span></span><span style=display:flex><span>        acceptThread.<span style=color:#a6e22e>start</span>();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>catch</span> (IOException e) {
</span></span><span style=display:flex><span>        LOGGER.<span style=color:#a6e22e>error</span>(<span style=color:#e6db74>&#34;Failed to start threads!&#34;</span>, e);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>org.apache.thrift.transport.TNonblockingServerSocket#listen</li></ul><p>开始监听</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>listen</span>() <span style=color:#66d9ef>throws</span> TTransportException {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Make sure not to block on accept</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (serverSocket_ <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>            serverSocket_.<span style=color:#a6e22e>setSoTimeout</span>(0);
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>catch</span> (SocketException sx) {
</span></span><span style=display:flex><span>            LOGGER.<span style=color:#a6e22e>error</span>(<span style=color:#e6db74>&#34;Socket exception while setting socket timeout&#34;</span>, sx);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=2-处理连接事件>2. 处理连接事件</h3><ul><li>org.apache.thrift.server.TThreadedSelectorServer.AcceptThread#run</li></ul><p>连接事件由 <code>AcceptThread</code> 线程独立处理；会循环监听 <code>Selector</code>事件，当有新的连接事件时，会建立连接</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>run</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (eventHandler_ <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 通知 Server 开始启动</span>
</span></span><span style=display:flex><span>            eventHandler_.<span style=color:#a6e22e>preServe</span>();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (<span style=color:#f92672>!</span>stopped_) {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 选择处理连接</span>
</span></span><span style=display:flex><span>            select();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>finally</span> {
</span></span><span style=display:flex><span>        acceptSelector.<span style=color:#a6e22e>close</span>();
</span></span><span style=display:flex><span>        TThreadedSelectorServer.<span style=color:#a6e22e>this</span>.<span style=color:#a6e22e>stop</span>();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>org.apache.thrift.server.TThreadedSelectorServer.AcceptThread#select</li></ul><p>会不断从 <code>Selector</code>获取事件，判断如果是 accept 事件，则处理，并建立连接</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>select</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 等待连接事件</span>
</span></span><span style=display:flex><span>        acceptSelector.<span style=color:#a6e22e>select</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 处理接收到的事件</span>
</span></span><span style=display:flex><span>        Iterator<span style=color:#f92672>&lt;</span>SelectionKey<span style=color:#f92672>&gt;</span> selectedKeys <span style=color:#f92672>=</span> acceptSelector.<span style=color:#a6e22e>selectedKeys</span>().<span style=color:#a6e22e>iterator</span>();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (<span style=color:#f92672>!</span>stopped_ <span style=color:#f92672>&amp;&amp;</span> selectedKeys.<span style=color:#a6e22e>hasNext</span>()) {
</span></span><span style=display:flex><span>            SelectionKey key <span style=color:#f92672>=</span> selectedKeys.<span style=color:#a6e22e>next</span>();
</span></span><span style=display:flex><span>            selectedKeys.<span style=color:#a6e22e>remove</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>key.<span style=color:#a6e22e>isValid</span>()) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (key.<span style=color:#a6e22e>isAcceptable</span>()) {
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 建立连接</span>
</span></span><span style=display:flex><span>                handleAccept();
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                LOGGER.<span style=color:#a6e22e>warn</span>(<span style=color:#e6db74>&#34;Unexpected state in select! &#34;</span> <span style=color:#f92672>+</span> key.<span style=color:#a6e22e>interestOps</span>());
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>catch</span> (IOException e) {
</span></span><span style=display:flex><span>        LOGGER.<span style=color:#a6e22e>warn</span>(<span style=color:#e6db74>&#34;Got an IOException while selecting!&#34;</span>, e);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>org.apache.thrift.server.TThreadedSelectorServer.AcceptThread#handleAccept</li></ul><p>会通过底层的 <code>ServerSocketChannel</code> 建立连接，然后将这个连接添加到 <code>SelectorThread</code> 的队列中，由 <code>SelectorThread</code>处理 IO 事件</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>handleAccept</span>() {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 建立连接</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>final</span> TNonblockingTransport client <span style=color:#f92672>=</span> doAccept();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (client <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 将连接传递给选择线程</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>final</span> SelectorThread targetThread <span style=color:#f92672>=</span> threadChooser.<span style=color:#a6e22e>nextThread</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 如果策略是尽快建立连接，则添加到处理的队列中</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (args.<span style=color:#a6e22e>acceptPolicy</span> <span style=color:#f92672>==</span> Args.<span style=color:#a6e22e>AcceptPolicy</span>.<span style=color:#a6e22e>FAST_ACCEPT</span> <span style=color:#f92672>||</span> invoker <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>            doAddAccept(targetThread, client);
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 如果是 FAIR_ACCEPT，则提交异步任务进行添加</span>
</span></span><span style=display:flex><span>                invoker.<span style=color:#a6e22e>submit</span>(<span style=color:#66d9ef>new</span> Runnable() {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>run</span>() {
</span></span><span style=display:flex><span>                        doAddAccept(targetThread, client);
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                });
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>catch</span> (RejectedExecutionException rx) {
</span></span><span style=display:flex><span>                LOGGER.<span style=color:#a6e22e>warn</span>(<span style=color:#e6db74>&#34;ExecutorService rejected accept registration!&#34;</span>, rx);
</span></span><span style=display:flex><span>                <span style=color:#75715e>// close immediately</span>
</span></span><span style=display:flex><span>                client.<span style=color:#a6e22e>close</span>();
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>org.apache.thrift.transport.TNonblockingServerSocket#acceptImpl</li></ul><p>建立连接，返回新的 <code>TNonblockingSocket</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>protected</span> TNonblockingSocket <span style=color:#a6e22e>acceptImpl</span>() <span style=color:#66d9ef>throws</span> TTransportException {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (serverSocket_ <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> TTransportException(TTransportException.<span style=color:#a6e22e>NOT_OPEN</span>, <span style=color:#e6db74>&#34;No underlying server socket.&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 接受连接</span>
</span></span><span style=display:flex><span>        SocketChannel socketChannel <span style=color:#f92672>=</span> serverSocketChannel.<span style=color:#a6e22e>accept</span>();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (socketChannel <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 使用 Channel 构建 Socket</span>
</span></span><span style=display:flex><span>        TNonblockingSocket tsocket <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> TNonblockingSocket(socketChannel);
</span></span><span style=display:flex><span>        tsocket.<span style=color:#a6e22e>setTimeout</span>(clientTimeout_);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> tsocket;
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>catch</span> (IOException iox) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> TTransportException(iox);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>org.apache.thrift.server.TThreadedSelectorServer.SelectorThread#addAcceptedConnection</li></ul><p>将连接添加到 <code>SelectorThread</code>的队列中，由 <code>SelectorThread</code>处理 IO 事件</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>addAcceptedConnection</span>(TNonblockingTransport accepted) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 放入队列中</span>
</span></span><span style=display:flex><span>        acceptedQueue.<span style=color:#a6e22e>put</span>(accepted);
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>catch</span> (InterruptedException e) {
</span></span><span style=display:flex><span>        LOGGER.<span style=color:#a6e22e>warn</span>(<span style=color:#e6db74>&#34;Interrupted while adding accepted connection!&#34;</span>, e);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    selector.<span style=color:#a6e22e>wakeup</span>();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=3-处理-io-事件>3. 处理 IO 事件</h3><p>IO 事件由 <code>SelectorThread</code> 处理</p><ul><li>org.apache.thrift.server.TThreadedSelectorServer.SelectorThread#run</li></ul><p>轮询读取事件，如果是 IO 事件，则分别处理；如果是新的连接，则注册 <code>Selector</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>run</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (<span style=color:#f92672>!</span>stopped_) {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 选择读取或写入事件</span>
</span></span><span style=display:flex><span>            select();
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 处理新的连接</span>
</span></span><span style=display:flex><span>            processAcceptedConnections();
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 改变需要改变的状态</span>
</span></span><span style=display:flex><span>            processInterestChanges();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 如果停止了，则清理选择</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (SelectionKey selectionKey : selector.<span style=color:#a6e22e>keys</span>()) {
</span></span><span style=display:flex><span>            cleanupSelectionKey(selectionKey);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>catch</span> (Throwable t) {
</span></span><span style=display:flex><span>        LOGGER.<span style=color:#a6e22e>error</span>(<span style=color:#e6db74>&#34;run() on SelectorThread exiting due to uncaught error&#34;</span>, t);
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>finally</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 关闭</span>
</span></span><span style=display:flex><span>        selector.<span style=color:#a6e22e>close</span>();
</span></span><span style=display:flex><span>        TThreadedSelectorServer.<span style=color:#a6e22e>this</span>.<span style=color:#a6e22e>stop</span>();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>org.apache.thrift.server.TThreadedSelectorServer.SelectorThread#select</li></ul><p>处理 IO 事件，根据事件类型分别处理读取或者写入</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>select</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 获取事件</span>
</span></span><span style=display:flex><span>        doSelect();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        Iterator<span style=color:#f92672>&lt;</span>SelectionKey<span style=color:#f92672>&gt;</span> selectedKeys <span style=color:#f92672>=</span> selector.<span style=color:#a6e22e>selectedKeys</span>().<span style=color:#a6e22e>iterator</span>();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (<span style=color:#f92672>!</span>stopped_ <span style=color:#f92672>&amp;&amp;</span> selectedKeys.<span style=color:#a6e22e>hasNext</span>()) {
</span></span><span style=display:flex><span>            SelectionKey key <span style=color:#f92672>=</span> selectedKeys.<span style=color:#a6e22e>next</span>();
</span></span><span style=display:flex><span>            selectedKeys.<span style=color:#a6e22e>remove</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 如果无效则跳过</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>key.<span style=color:#a6e22e>isValid</span>()) {
</span></span><span style=display:flex><span>                cleanupSelectionKey(key);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (key.<span style=color:#a6e22e>isReadable</span>()) {
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 如果是读取则处理读取事件</span>
</span></span><span style=display:flex><span>                handleRead(key);
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (key.<span style=color:#a6e22e>isWritable</span>()) {
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 如果是写入则处理写入</span>
</span></span><span style=display:flex><span>                handleWrite(key);
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                LOGGER.<span style=color:#a6e22e>warn</span>(<span style=color:#e6db74>&#34;Unexpected state in select! &#34;</span> <span style=color:#f92672>+</span> key.<span style=color:#a6e22e>interestOps</span>());
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>catch</span> (IOException e) {
</span></span><span style=display:flex><span>        LOGGER.<span style=color:#a6e22e>warn</span>(<span style=color:#e6db74>&#34;Got an IOException while selecting!&#34;</span>, e);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=处理读取事件>处理读取事件</h4><ul><li>org.apache.thrift.server.AbstractNonblockingServer.AbstractSelectThread#handleRead</li></ul><p>在处理读取事件时，会读取整个帧，当完全读取时，会调用 <code>requestInvoke</code> 方法，通过线程池处理请求</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>handleRead</span>(SelectionKey key) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 获取帧</span>
</span></span><span style=display:flex><span>    FrameBuffer buffer <span style=color:#f92672>=</span> (FrameBuffer) key.<span style=color:#a6e22e>attachment</span>();
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 如果没有可读取的，则清理</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>buffer.<span style=color:#a6e22e>read</span>()) {
</span></span><span style=display:flex><span>        cleanupSelectionKey(key);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>// if the buffer&#39;s frame read is complete, invoke the method.</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 如果 buffer 完全读取，则执行处理，如果失败则清理</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (buffer.<span style=color:#a6e22e>isFrameFullyRead</span>()) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>requestInvoke(buffer)) {
</span></span><span style=display:flex><span>            cleanupSelectionKey(key);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>org.apache.thrift.server.TThreadedSelectorServer#requestInvoke</li></ul><p>处理调用，会将帧封装为 Runnable 任务，提交给线程池执行</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>requestInvoke</span>(FrameBuffer frameBuffer) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 封装为 Runnable</span>
</span></span><span style=display:flex><span>    Runnable invocation <span style=color:#f92672>=</span> getRunnable(frameBuffer);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (invoker <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 执行处理</span>
</span></span><span style=display:flex><span>            invoker.<span style=color:#a6e22e>execute</span>(invocation);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>catch</span> (RejectedExecutionException rx) {
</span></span><span style=display:flex><span>            LOGGER.<span style=color:#a6e22e>warn</span>(<span style=color:#e6db74>&#34;ExecutorService rejected execution!&#34;</span>, rx);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Invoke on the caller&#39;s thread</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 如果没有线程池，由当前线程直接处理</span>
</span></span><span style=display:flex><span>        invocation.<span style=color:#a6e22e>run</span>();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=处理写入事件>处理写入事件</h4><ul><li>org.apache.thrift.server.AbstractNonblockingServer.AbstractSelectThread#handleWrite</li></ul><p>处理写入事件，调用 <code>FrameBuffer</code> 的写入方法进行处理</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>handleWrite</span>(SelectionKey key) {
</span></span><span style=display:flex><span>    FrameBuffer buffer <span style=color:#f92672>=</span> (FrameBuffer) key.<span style=color:#a6e22e>attachment</span>();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>buffer.<span style=color:#a6e22e>write</span>()) {
</span></span><span style=display:flex><span>        cleanupSelectionKey(key);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>org.apache.thrift.server.AbstractNonblockingServer.FrameBuffer#write</li></ul><p>由 Transport 执行写入，最终由 <code>SocketChannel</code> 执行，将响应内容发送给客户端</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>write</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (state_ <span style=color:#f92672>==</span> FrameBufferState.<span style=color:#a6e22e>WRITING</span>) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 写入</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (trans_.<span style=color:#a6e22e>write</span>(buffer_) <span style=color:#f92672>&lt;</span> 0) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 如果没有待写入的，则切换到读取</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (buffer_.<span style=color:#a6e22e>remaining</span>() <span style=color:#f92672>==</span> 0) {
</span></span><span style=display:flex><span>            prepareRead();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=4-执行请求>4. 执行请求</h3><ul><li>org.apache.thrift.server.AbstractNonblockingServer.FrameBuffer#invoke</li></ul><p>在处理读取事件时，会将 <code>FrameBuffer</code> 包装为 <code>Runnable</code>，提交给线程池执行；最终由 <code>FrameBuffer</code>处理
会获取 Processor，然后调用 process 方法进行处理</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>invoke</span>() {
</span></span><span style=display:flex><span>    frameTrans_.<span style=color:#a6e22e>reset</span>(buffer_.<span style=color:#a6e22e>array</span>());
</span></span><span style=display:flex><span>    response_.<span style=color:#a6e22e>reset</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 如果有事件处理器，则触发</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (eventHandler_ <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>            eventHandler_.<span style=color:#a6e22e>processContext</span>(context_, inTrans_, outTrans_);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 获取处理器，调用处理方法</span>
</span></span><span style=display:flex><span>        processorFactory_.<span style=color:#a6e22e>getProcessor</span>(inTrans_).<span style=color:#a6e22e>process</span>(inProt_, outProt_);
</span></span><span style=display:flex><span>        responseReady();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>catch</span> (TException te) {
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>// This will only be reached when there is a throwable.</span>
</span></span><span style=display:flex><span>    state_ <span style=color:#f92672>=</span> FrameBufferState.<span style=color:#a6e22e>AWAITING_CLOSE</span>;
</span></span><span style=display:flex><span>    requestSelectInterestChange();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>org.apache.thrift.TBaseProcessor#process</li></ul><p>在处理时，根据方法名获取具体的处理函数，然后调用响应的处理方法进行处理</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>process</span>(TProtocol in, TProtocol out) <span style=color:#66d9ef>throws</span> TException {
</span></span><span style=display:flex><span>  TMessage msg <span style=color:#f92672>=</span> in.<span style=color:#a6e22e>readMessageBegin</span>();
</span></span><span style=display:flex><span>  ProcessFunction fn <span style=color:#f92672>=</span> processMap.<span style=color:#a6e22e>get</span>(msg.<span style=color:#a6e22e>name</span>);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (fn <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>    TProtocolUtil.<span style=color:#a6e22e>skip</span>(in, TType.<span style=color:#a6e22e>STRUCT</span>);
</span></span><span style=display:flex><span>    in.<span style=color:#a6e22e>readMessageEnd</span>();
</span></span><span style=display:flex><span>    TApplicationException x <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> TApplicationException(TApplicationException.<span style=color:#a6e22e>UNKNOWN_METHOD</span>, <span style=color:#e6db74>&#34;Invalid method name: &#39;&#34;</span><span style=color:#f92672>+</span>msg.<span style=color:#a6e22e>name</span><span style=color:#f92672>+</span><span style=color:#e6db74>&#34;&#39;&#34;</span>);
</span></span><span style=display:flex><span>    out.<span style=color:#a6e22e>writeMessageBegin</span>(<span style=color:#66d9ef>new</span> TMessage(msg.<span style=color:#a6e22e>name</span>, TMessageType.<span style=color:#a6e22e>EXCEPTION</span>, msg.<span style=color:#a6e22e>seqid</span>));
</span></span><span style=display:flex><span>    x.<span style=color:#a6e22e>write</span>(out);
</span></span><span style=display:flex><span>    out.<span style=color:#a6e22e>writeMessageEnd</span>();
</span></span><span style=display:flex><span>    out.<span style=color:#a6e22e>getTransport</span>().<span style=color:#a6e22e>flush</span>();
</span></span><span style=display:flex><span>  } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>    fn.<span style=color:#a6e22e>process</span>(msg.<span style=color:#a6e22e>seqid</span>, in, out, iface);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>org.apache.thrift.ProcessFunction#process</li></ul><p>读取请求信息，反序列化为对象，然后调用 <code>getResult</code> 方法执行实现逻辑，获取响应；如果不是 oneway 的请求，则将相应结果写入流中，发送给客户端</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>process</span>(<span style=color:#66d9ef>int</span> seqid,
</span></span><span style=display:flex><span>                          TProtocol iprot,
</span></span><span style=display:flex><span>                          TProtocol oprot,
</span></span><span style=display:flex><span>                          I iface) <span style=color:#66d9ef>throws</span> TException {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 获取空参数实例</span>
</span></span><span style=display:flex><span>    T args <span style=color:#f92672>=</span> getEmptyArgsInstance();
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 读取</span>
</span></span><span style=display:flex><span>    args.<span style=color:#a6e22e>read</span>(iprot);
</span></span><span style=display:flex><span>    iprot.<span style=color:#a6e22e>readMessageEnd</span>();
</span></span><span style=display:flex><span>    TSerializable result <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>byte</span> msgType <span style=color:#f92672>=</span> TMessageType.<span style=color:#a6e22e>REPLY</span>;
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 获取结果</span>
</span></span><span style=display:flex><span>    result <span style=color:#f92672>=</span> getResult(iface, args);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 如果不是 oneway 的，则写入响应结果</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>isOneway()) {
</span></span><span style=display:flex><span>        oprot.<span style=color:#a6e22e>writeMessageBegin</span>(<span style=color:#66d9ef>new</span> TMessage(getMethodName(), msgType, seqid));
</span></span><span style=display:flex><span>        result.<span style=color:#a6e22e>write</span>(oprot);
</span></span><span style=display:flex><span>        oprot.<span style=color:#a6e22e>writeMessageEnd</span>();
</span></span><span style=display:flex><span>        oprot.<span style=color:#a6e22e>getTransport</span>().<span style=color:#a6e22e>flush</span>();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>io.github.helloworlde.thrift.HelloService.Processor.sayHello#getResult</li></ul><p>由生成的代码处理，会先构建一个响应结构体，然后调用相应的方法进行处理，返回结果</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> sayHello_result <span style=color:#a6e22e>getResult</span>(I iface, sayHello_args args) <span style=color:#66d9ef>throws</span> org.<span style=color:#a6e22e>apache</span>.<span style=color:#a6e22e>thrift</span>.<span style=color:#a6e22e>TException</span> {
</span></span><span style=display:flex><span>  sayHello_result result <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> sayHello_result();
</span></span><span style=display:flex><span>  result.<span style=color:#a6e22e>success</span> <span style=color:#f92672>=</span> iface.<span style=color:#a6e22e>sayHello</span>(args.<span style=color:#a6e22e>request</span>);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> result;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>io.github.helloworlde.thrift.HelloServiceImpl#sayHello</li></ul><p>具体的逻辑处理，返回响应</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> HelloResponse <span style=color:#a6e22e>sayHello</span>(HelloMessage request) <span style=color:#66d9ef>throws</span> TException {
</span></span><span style=display:flex><span>    String message <span style=color:#f92672>=</span> request.<span style=color:#a6e22e>getMessage</span>();
</span></span><span style=display:flex><span>    HelloResponse response <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> HelloResponse();
</span></span><span style=display:flex><span>    response.<span style=color:#a6e22e>setMessage</span>(<span style=color:#e6db74>&#34;Hello &#34;</span> <span style=color:#f92672>+</span> message);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> response;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=4-写入响应>4. 写入响应</h3><ul><li>org.apache.thrift.ProcessFunction#process</li></ul><p>在处理完请求之后，会判断是否是 oneway 请求，如果不是，则会执行写入响应</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>if</span>(<span style=color:#f92672>!</span>isOneway()) {
</span></span><span style=display:flex><span>  oprot.<span style=color:#a6e22e>writeMessageBegin</span>(<span style=color:#66d9ef>new</span> TMessage(getMethodName(), msgType, seqid));
</span></span><span style=display:flex><span>  result.<span style=color:#a6e22e>write</span>(oprot);
</span></span><span style=display:flex><span>  oprot.<span style=color:#a6e22e>writeMessageEnd</span>();
</span></span><span style=display:flex><span>  oprot.<span style=color:#a6e22e>getTransport</span>().<span style=color:#a6e22e>flush</span>();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>org.apache.thrift.protocol.TBinaryProtocol#writeMessageBegin</li></ul><p>写入响应时，会先写入响应头；会将版本信息，消息类型，方法的名称和请求 ID 一起写入</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>writeMessageBegin</span>(TMessage message) <span style=color:#66d9ef>throws</span> TException {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (strictWrite_) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> version <span style=color:#f92672>=</span> VERSION_1 <span style=color:#f92672>|</span> message.<span style=color:#a6e22e>type</span>;
</span></span><span style=display:flex><span>    writeI32(version);
</span></span><span style=display:flex><span>    writeString(message.<span style=color:#a6e22e>name</span>);
</span></span><span style=display:flex><span>    writeI32(message.<span style=color:#a6e22e>seqid</span>);
</span></span><span style=display:flex><span>  } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>    writeString(message.<span style=color:#a6e22e>name</span>);
</span></span><span style=display:flex><span>    writeByte(message.<span style=color:#a6e22e>type</span>);
</span></span><span style=display:flex><span>    writeI32(message.<span style=color:#a6e22e>seqid</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>io.github.helloworlde.thrift.HelloResponse.HelloResponseStandardScheme#write</li></ul><p>随后写入响应内容，将对象序列化为字节</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>write</span>(org.<span style=color:#a6e22e>apache</span>.<span style=color:#a6e22e>thrift</span>.<span style=color:#a6e22e>protocol</span>.<span style=color:#a6e22e>TProtocol</span> oprot, HelloResponse struct) <span style=color:#66d9ef>throws</span> org.<span style=color:#a6e22e>apache</span>.<span style=color:#a6e22e>thrift</span>.<span style=color:#a6e22e>TException</span> {
</span></span><span style=display:flex><span>  struct.<span style=color:#a6e22e>validate</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  oprot.<span style=color:#a6e22e>writeStructBegin</span>(STRUCT_DESC);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (struct.<span style=color:#a6e22e>message</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>    oprot.<span style=color:#a6e22e>writeFieldBegin</span>(MESSAGE_FIELD_DESC);
</span></span><span style=display:flex><span>    oprot.<span style=color:#a6e22e>writeString</span>(struct.<span style=color:#a6e22e>message</span>);
</span></span><span style=display:flex><span>    oprot.<span style=color:#a6e22e>writeFieldEnd</span>();
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  oprot.<span style=color:#a6e22e>writeFieldStop</span>();
</span></span><span style=display:flex><span>  oprot.<span style=color:#a6e22e>writeStructEnd</span>();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>然后会写入响应结尾符，由 <code>SelectorThread</code> 处理写入事件，最终将请求发送给客户端</p><h2 id=参考文档>参考文档</h2><ul><li><a href=https://github.com/helloworlde/thrift-java-sample>helloworlde/thrift-java-sample</a></li></ul></section><div class=paginator><a class=prev href=https://blog.hellowood.dev/posts/thrfit-%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B/><svg class="icon" width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M3.77086 21.1546C11.0491 22.698 21.4339 21.7773 21.4339 16.3608V4.63375c0-.69413-.075800000000001-1.3284-.2422-1.86588M3.77086 21.1546C1.9934 20.7777.973585 18.7264 1.08749 16.688c.17931-3.209.06972-7.25665-.08236-10.47293C.87809 3.52811 3.12891 1.16316 5.51029 1.25008c4.25565.15534 9.86671-.04779 13.28091-.24466 1.2952-.074686 2.0494.62843 2.4005 1.76245M3.77086 21.1546C4.56586 21.4723 5.49168 21.7879 6.5 22.0658M21.1917 2.76787c1.918 1.4143 1.9383 9.65123 1.7087 13.59293-2.0526 7.6586-10.5943 7.3054-16.4004 5.705M21.1917 2.76787C21.7612 4.51192 22.7203 9.67216 22 16.3608 21.2797 23.0494 11.3665 22.9511 6.5 22.0658M9.94496 9C9.28897 9.61644 7.63215 10.997 6.04814 11.7966 5.98257 11.8297 5.98456 11.9753 6.05061 12.0063c1.00435.4716 2.8788 1.9201 3.89435 2.9937M6.44444 11.9667C8.86549 12.0608 14 12 16 11" stroke="currentcolor" stroke-linecap="round"/></svg>
<span>Thrfit 客户端请求处理流程</span></a>
<a class=next href=https://blog.hellowood.dev/posts/thrift-%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82/><span>Thrift 客户端异步请求</span><svg class="icon" width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M3.77086 21.1546C11.0491 22.698 21.4339 21.7773 21.4339 16.3608V4.63375c0-.69413-.075800000000001-1.3284-.2422-1.86588M3.77086 21.1546C1.9934 20.7777.973585 18.7264 1.08749 16.688c.17931-3.209.06972-7.25665-.08236-10.47293C.87809 3.52811 3.12891 1.16316 5.51029 1.25008c4.25565.15534 9.86671-.04779 13.28091-.24466 1.2952-.074686 2.0494.62843 2.4005 1.76245M3.77086 21.1546C4.56586 21.4723 5.49168 21.7879 6.5 22.0658M21.1917 2.76787c1.918 1.4143 1.9383 9.65123 1.7087 13.59293-2.0526 7.6586-10.5943 7.3054-16.4004 5.705M21.1917 2.76787C21.7612 4.51192 22.7203 9.67216 22 16.3608 21.2797 23.0494 11.3665 22.9511 6.5 22.0658M12.055 9C12.711 9.61644 14.3679 10.997 15.9519 11.7966 16.0174 11.8297 16.0154 11.9753 15.9494 12.0063 14.945 12.4779 13.0706 13.9264 12.055 15m3.5006-3.0333C13.1345 12.0608 8 12 6 11" stroke="currentcolor" stroke-linecap="round"/></svg></a></div></article></div><footer class=footer><p>&copy; 2024 <a href=https://blog.hellowood.dev/>HelloWood</a>
Powered by
<a href=https://gohugo.io/ rel=noopener target=_blank data-umami-event=to-hugo>Hugo️️</a>
<a href=https://github.com/guangzhengli/hugo-theme-ladder rel=noopener target=_blank data-umami-event=to-ladder>Ladder</a>
️</p></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g data-umami-event=top-link><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M10.5376 22.7916C11.0152 22.7207 22.5795 21.1781 22.0978 10.4211 22.0536 9.43274 21.9303 8.53367 21.7387 7.71865M10.5376 22.7916C16.876 22.3728 20.0969 19.8899 21.5383 16.9142M10.5376 22.7916C9.7707 22.9055 8.97982 22.8964 8.19743 22.7725M21.7387 7.71865C21.4988 6.69828 21.1518 5.80967 20.7188 5.04257m1.0199 2.67608C22.6022 10.1105 23.0542 13.7848 21.5383 16.9142M20.7188 5.04257c-3.5504-6.28886-12.88753-4.410077-16.44303.0C2.88063 6.77451-.0433281 11.1668 1.38159 16.6571c.89322 3.4417 3.7911 5.6365 6.81584 6.1154M20.7188 5.04257c1.3509 1.89783 3.3111 6.34223 1.6353 10.37273M21.5383 16.9142C21.8737 16.4251 22.1428 15.9235 22.3541 15.4153M8.19743 22.7725C12.1971 23.4683 20.6281 22.971 22.3541 15.4153M14 10.945C13.3836 10.289 12.003 8.63215 11.2034 7.04814 11.1703 6.98257 11.0247 6.98456 10.9937 7.05061 10.5221 8.05496 9.07362 9.92941 8 10.945m3.0333-3.50056C10.9392 9.86549 11 15 12 17" stroke="currentcolor" stroke-linecap="round"/></svg>
</a><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const s=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="Copy";function n(){t.innerHTML="Copied",setTimeout(()=>{t.innerHTML="Copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),n();return}const s=document.createRange();s.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(s);try{document.execCommand("copy"),n()}catch{}o.removeRange(s)}),e.parentNode.appendChild(t)})</script></main></body><script src=https://cdnjs.cloudflare.com/ajax/libs/medium-zoom/1.0.6/medium-zoom.min.js integrity="sha512-N9IJRoc3LaP3NDoiGkcPa4gG94kapGpaA5Zq9/Dr04uf5TbLFU5q0o8AbRhLKUUlp8QFS2u7S+Yti0U7QtuZvQ==" crossorigin=anonymous referrerpolicy=no-referrer></script><script>const images=Array.from(document.querySelectorAll(".blog-content img"));images.forEach(e=>{mediumZoom(e,{margin:10,scrollOffset:40,container:null,template:null,background:"rgba(0, 0, 0, 0.5)"})})</script><script src=/main.min.6bb26b69159420159c74dc9e097b06a578ed2b68c701466a91a44a9632d851bd0af167a1b30012387b4c512b48ad9ad4d3394e04d77ae38d57e1920fe4ed34fe.js integrity="sha512-a7JraRWUIBWcdNyeCXsGpXjtK2jHAUZqkaRKljLYUb0K8WehswASOHtMUStIrZrU0zlOBNd6441X4ZIP5O00/g==" crossorigin=anonymous defer></script></html>