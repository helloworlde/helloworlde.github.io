<!doctype html><html lang=en><head><meta name=viewport content="width=device-width,initial-scale=1"><title>gRPC 健康检查</title>
<meta charset=utf-8><meta name=description content='Ladder@gRPC 健康检查 在 gRPC 中使用健康检查，在负载均衡前通过健康检查，只对健康的 Subchannel 发起请求，保证请求的成功率
使用 Server 端 健康检查是一个独立的 Service，需要在 Server 端显式添加健康检查服务
健康检查定义了两个方法，一个适用于单次请求的 check 方法，另一个是适用于 Stream 流的 watch 方法
Server 端的健康检查由 io.grpc.services.HealthStatusManager控制，抽象类是 io.grpc.health.v1.HealthGrpc.HealthImplBase，具体实现是通过 io.grpc.services.HealthServiceImpl
在 Server 端添加健康检查服务 HealthStatusManager healthStatusManager = new HealthStatusManager(); Server server = ServerBuilder.forPort(1234) .addService(healthStatusManager.getHealthService()) .addService(new HelloServiceImpl()) .build(); 这样，当 Server 端启动之后，就可以通过访问 grpc.health.v1.Health服务获取当前的 Server 端的状态
客户端 添加配置 客户端开启健康检查有两个条件：
配置了健康检查参数，配置的名称是 healthCheckConfig，通过指定 serviceName 的方式配置 使用了支持健康检查的 LB (如 round_robin) 需要注意，这里的 serviceName可以是组件名称，或者服务名称；服务端默认为 ""， 如果想检查某个组件，需要自己实现健康检查的逻辑；配置中的 serviceName只有在 NameReovler 解析到新的配置，且发生变化时才会更新，所以设置 serviceName 意义不大
Map<String, Object> configMap = new HashMap<String, Object>() {{ put("healthCheckConfig", new HashMap<String, Object>() {{ put("serviceName", ""); }}); }}; this.'><meta name=author content="HelloWood"><link rel=canonical href=https://blog.hellowood.dev/posts/grpc-%E5%81%A5%E5%BA%B7%E6%A3%80%E6%9F%A5/><meta name=google-site-verification content="G-3MSGPYTHPZ"><link rel=alternate type=application/rss+xml href=https://blog.hellowood.dev//index.xml title=HelloWood><script async src="https://www.googletagmanager.com/gtag/js?id=G-3MSGPYTHPZ"></script><script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-3MSGPYTHPZ",{anonymize_ip:!1})}</script><script async defer data-website-id=7a9034de-0ce7-4756-942a-829e6cd22301 src=https://umami.hellowood.dev/script.js></script><script defer data-cf-beacon='{"token": "b2e481d136dc428c8c96c8673e2a04cf"}' src=https://static.cloudflareinsights.com/beacon.min.js></script><meta property="og:title" content="gRPC  健康检查"><meta property="og:description" content='gRPC 健康检查 在 gRPC 中使用健康检查，在负载均衡前通过健康检查，只对健康的 Subchannel 发起请求，保证请求的成功率
使用 Server 端 健康检查是一个独立的 Service，需要在 Server 端显式添加健康检查服务
健康检查定义了两个方法，一个适用于单次请求的 check 方法，另一个是适用于 Stream 流的 watch 方法
Server 端的健康检查由 io.grpc.services.HealthStatusManager控制，抽象类是 io.grpc.health.v1.HealthGrpc.HealthImplBase，具体实现是通过 io.grpc.services.HealthServiceImpl
在 Server 端添加健康检查服务 HealthStatusManager healthStatusManager = new HealthStatusManager(); Server server = ServerBuilder.forPort(1234) .addService(healthStatusManager.getHealthService()) .addService(new HelloServiceImpl()) .build(); 这样，当 Server 端启动之后，就可以通过访问 grpc.health.v1.Health服务获取当前的 Server 端的状态
客户端 添加配置 客户端开启健康检查有两个条件：
配置了健康检查参数，配置的名称是 healthCheckConfig，通过指定 serviceName 的方式配置 使用了支持健康检查的 LB (如 round_robin) 需要注意，这里的 serviceName可以是组件名称，或者服务名称；服务端默认为 ""， 如果想检查某个组件，需要自己实现健康检查的逻辑；配置中的 serviceName只有在 NameReovler 解析到新的配置，且发生变化时才会更新，所以设置 serviceName 意义不大
Map<String, Object> configMap = new HashMap<String, Object>() {{ put("healthCheckConfig", new HashMap<String, Object>() {{ put("serviceName", ""); }}); }}; this.'><meta property="og:type" content="article"><meta property="og:url" content="https://blog.hellowood.dev/posts/grpc-%E5%81%A5%E5%BA%B7%E6%A3%80%E6%9F%A5/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-09-20T22:37:34+00:00"><meta property="article:modified_time" content="2020-09-20T22:37:34+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="gRPC  健康检查"><meta name=twitter:description content='gRPC 健康检查 在 gRPC 中使用健康检查，在负载均衡前通过健康检查，只对健康的 Subchannel 发起请求，保证请求的成功率
使用 Server 端 健康检查是一个独立的 Service，需要在 Server 端显式添加健康检查服务
健康检查定义了两个方法，一个适用于单次请求的 check 方法，另一个是适用于 Stream 流的 watch 方法
Server 端的健康检查由 io.grpc.services.HealthStatusManager控制，抽象类是 io.grpc.health.v1.HealthGrpc.HealthImplBase，具体实现是通过 io.grpc.services.HealthServiceImpl
在 Server 端添加健康检查服务 HealthStatusManager healthStatusManager = new HealthStatusManager(); Server server = ServerBuilder.forPort(1234) .addService(healthStatusManager.getHealthService()) .addService(new HelloServiceImpl()) .build(); 这样，当 Server 端启动之后，就可以通过访问 grpc.health.v1.Health服务获取当前的 Server 端的状态
客户端 添加配置 客户端开启健康检查有两个条件：
配置了健康检查参数，配置的名称是 healthCheckConfig，通过指定 serviceName 的方式配置 使用了支持健康检查的 LB (如 round_robin) 需要注意，这里的 serviceName可以是组件名称，或者服务名称；服务端默认为 ""， 如果想检查某个组件，需要自己实现健康检查的逻辑；配置中的 serviceName只有在 NameReovler 解析到新的配置，且发生变化时才会更新，所以设置 serviceName 意义不大
Map<String, Object> configMap = new HashMap<String, Object>() {{ put("healthCheckConfig", new HashMap<String, Object>() {{ put("serviceName", ""); }}); }}; this.'><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.hellowood.dev/posts/"},{"@type":"ListItem","position":2,"name":"gRPC  健康检查","item":"https://blog.hellowood.dev/posts/grpc-%E5%81%A5%E5%BA%B7%E6%A3%80%E6%9F%A5/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"gRPC  健康检查","name":"gRPC  健康检查","description":"gRPC 健康检查 在 gRPC 中使用健康检查，在负载均衡前通过健康检查，只对健康的 Subchannel 发起请求，保证请求的成功率\n使用 Server 端 健康检查是一个独立的 Service，需要在 Server 端显式添加健康检查服务\n健康检查定义了两个方法，一个适用于单次请求的 check 方法，另一个是适用于 Stream 流的 watch 方法\nServer 端的健康检查由 io.grpc.services.HealthStatusManager控制，抽象类是 io.grpc.health.v1.HealthGrpc.HealthImplBase，具体实现是通过 io.grpc.services.HealthServiceImpl\n在 Server 端添加健康检查服务 HealthStatusManager healthStatusManager = new HealthStatusManager(); Server server = ServerBuilder.forPort(1234) .addService(healthStatusManager.getHealthService()) .addService(new HelloServiceImpl()) .build(); 这样，当 Server 端启动之后，就可以通过访问 grpc.health.v1.Health服务获取当前的 Server 端的状态\n客户端 添加配置 客户端开启健康检查有两个条件：\n配置了健康检查参数，配置的名称是 healthCheckConfig，通过指定 serviceName 的方式配置 使用了支持健康检查的 LB (如 round_robin) 需要注意，这里的 serviceName可以是组件名称，或者服务名称；服务端默认为 \u0026quot;\u0026quot;， 如果想检查某个组件，需要自己实现健康检查的逻辑；配置中的 serviceName只有在 NameReovler 解析到新的配置，且发生变化时才会更新，所以设置 serviceName 意义不大\nMap\u0026lt;String, Object\u0026gt; configMap = new HashMap\u0026lt;String, Object\u0026gt;() {{ put(\u0026#34;healthCheckConfig\u0026#34;, new HashMap\u0026lt;String, Object\u0026gt;() {{ put(\u0026#34;serviceName\u0026#34;, \u0026#34;\u0026#34;); }}); }}; this.","keywords":["gRPC"],"articleBody":"gRPC 健康检查 在 gRPC 中使用健康检查，在负载均衡前通过健康检查，只对健康的 Subchannel 发起请求，保证请求的成功率\n使用 Server 端 健康检查是一个独立的 Service，需要在 Server 端显式添加健康检查服务\n健康检查定义了两个方法，一个适用于单次请求的 check 方法，另一个是适用于 Stream 流的 watch 方法\nServer 端的健康检查由 io.grpc.services.HealthStatusManager控制，抽象类是 io.grpc.health.v1.HealthGrpc.HealthImplBase，具体实现是通过 io.grpc.services.HealthServiceImpl\n在 Server 端添加健康检查服务 HealthStatusManager healthStatusManager = new HealthStatusManager(); Server server = ServerBuilder.forPort(1234) .addService(healthStatusManager.getHealthService()) .addService(new HelloServiceImpl()) .build(); 这样，当 Server 端启动之后，就可以通过访问 grpc.health.v1.Health服务获取当前的 Server 端的状态\n客户端 添加配置 客户端开启健康检查有两个条件：\n配置了健康检查参数，配置的名称是 healthCheckConfig，通过指定 serviceName 的方式配置 使用了支持健康检查的 LB (如 round_robin) 需要注意，这里的 serviceName可以是组件名称，或者服务名称；服务端默认为 \"\"， 如果想检查某个组件，需要自己实现健康检查的逻辑；配置中的 serviceName只有在 NameReovler 解析到新的配置，且发生变化时才会更新，所以设置 serviceName 意义不大\nMap\u003cString, Object\u003e configMap = new HashMap\u003cString, Object\u003e() {{ put(\"healthCheckConfig\", new HashMap\u003cString, Object\u003e() {{ put(\"serviceName\", \"\"); }}); }}; this.channel = ManagedChannelBuilder .forTarget(\"server\") .usePlaintext() .defaultServiceConfig(configMap) .defaultLoadBalancingPolicy(\"round_robin\") .build() 执行健康检查 在发起请求前，会先使用 Service 的名称请求服务端健康检查服务，检查服务是否处于 SERVING 状态，如果状态正常，则发起请求，否则将会失败\n调整日志级别 将io.grpc.ChannelLogger的日志级别调整到 ALL，用于观察日志\nLogger logger = Logger.getLogger(\"io.grpc.ChannelLogger\"); logger.setLevel(Level.ALL); ConsoleHandler handler = new ConsoleHandler(); handler.setLevel(Level.ALL); logger.addHandler(handler); 当健康检查成功时输出成功日志 非常详细: [Subchannel\u003c3\u003e: (server)] CONNECTING: Starting health-check for \"io.github.helloworlde.HelloService\" 非常详细: [Subchannel\u003c3\u003e: (server)] READY: health-check responded SERVING 非常详细: [Channel\u003c1\u003e: (server)] Entering READY state with picker: ReadyPicker{list=[SubchannelImpl{delegate=Subchannel\u003c3\u003e: (server)}]} 当健康检查失败时输出错误日志 非常详细: [Subchannel\u003c3\u003e: (server)] READY 非常详细: [Subchannel\u003c3\u003e: (server)] CONNECTING: Starting health-check for \"io.github.helloworlde.HelloService\" 非常详细: [Subchannel\u003c3\u003e: (server)] TRANSIENT_FAILURE: health-check responded NOT_SERVING 非常详细: [Channel\u003c1\u003e: (server)] Entering TRANSIENT_FAILURE state with picker: EmptyPicker{status=Status{code=UNAVAILABLE, description=Health-check service responded NOT_SERVING for 'io.github.helloworlde.HelloService', cause=null}} Exception in thread \"main\" io.grpc.StatusRuntimeException: UNAVAILABLE: Health-check service responded NOT_SERVING for 'io.github.helloworlde.HelloService' at io.grpc.stub.ClientCalls.toStatusRuntimeException(ClientCalls.java:274) at io.grpc.stub.ClientCalls.getUnchecked(ClientCalls.java:255) at io.grpc.stub.ClientCalls.blockingUnaryCall(ClientCalls.java:166) at io.github.helloworlde.HelloServiceGrpc$HelloServiceBlockingStub.howAreYou(HelloServiceGrpc.java:157) at io.github.helloworlde.CustomClient.howAreYou(CustomClient.java:74) at io.github.helloworlde.CustomClient.main(CustomClient.java:66) 实现 定义 健康检查通过 health.proto 文件定义\nhealth.proto syntax = \"proto3\"; package grpc.health.v1; option csharp_namespace = \"Grpc.Health.V1\"; option go_package = \"google.golang.org/grpc/health/grpc_health_v1\"; option java_multiple_files = true; option java_outer_classname = \"HealthProto\"; option java_package = \"io.grpc.health.v1\"; message HealthCheckRequest { string service = 1; } message HealthCheckResponse { enum ServingStatus { UNKNOWN = 0; SERVING = 1; NOT_SERVING = 2; SERVICE_UNKNOWN = 3; } ServingStatus status = 1; } service Health { // 单次健康检查 rpc Check(HealthCheckRequest) returns (HealthCheckResponse); // 流式健康检查 rpc Watch(HealthCheckRequest) returns (stream HealthCheckResponse); } 客户端 执行检查 发起检查 获取配置 在 NameResolver 解析后，调用 io.grpc.internal.ManagedChannelImpl.NameResolverListener#onResult 时检查是否有健康检查的配置，如果有则将配置添加到 Attributes 中\n// 获取属性 Attributes effectiveAttrs = resolutionResult.getAttributes(); // 如果服务发现没有关闭 if (NameResolverListener.this.helper == ManagedChannelImpl.this.lbHelper) { // 获取健康检查 Map\u003cString, ?\u003e healthCheckingConfig = effectiveServiceConfig.getHealthCheckingConfig(); // 构建健康检查配置 if (healthCheckingConfig != null) { effectiveAttrs = effectiveAttrs.toBuilder() .set(LoadBalancer.ATTR_HEALTH_CHECKING_CONFIG, healthCheckingConfig) .build(); } // 更新负载均衡算法，处理未处理的请求 Status handleResult = helper.lb.tryHandleResolvedAddresses( ResolvedAddresses.newBuilder() .setAddresses(servers) .setAttributes(effectiveAttrs) .setLoadBalancingPolicyConfig(effectiveServiceConfig.getLoadBalancingConfig()) .build()); } 为 Subchannel 配置健康检查 通过代理调用 io.grpc.util.RoundRobinLoadBalancer#handleResolvedAddresses方法，然后调用 io.grpc.services.HealthCheckingLoadBalancerFactory.HelperImpl#createSubchannel 方法创建 Subchannel；创建用于健康检查的 SubchannelStateListener的实例 HealthCheckState\nio.grpc.services.HealthCheckingLoadBalancerFactory.HelperImpl#createSubchannel HealthCheckState hcState = new HealthCheckState(this, originalSubchannel, syncContext, delegate.getScheduledExecutorService()); 添加健康检查 如果有设置健康检查，则将健康检查添加到 Subchannel健康检查集合中；然后调用 io.grpc.services.HealthCheckingLoadBalancerFactory.HealthCheckState#setServiceName 方法执行\nio.grpc.services.HealthCheckingLoadBalancerFactory.HealthCheckState#setServiceName 如果此时有已经提交的请求，则取消，并发送健康检查请求；当第一次执行的时候，如果状态是 IDLEs，则会跳出不执行，直到状态变为READY时执行\nvoid setServiceName(@Nullable String newServiceName) { serviceName = newServiceName; // 如果在 RPC 请求期间服务名称更改，请取消该服务，以便用新名称进行新的调用 String cancelMsg = serviceName == null ? \"Health check disabled by service config\" : \"Switching to new service name: \" + newServiceName; // 停止调用 stopRpc(cancelMsg); // 调整健康检查 adjustHealthCheck(); } io.grpc.internal.InternalSubchannel.TransportListener#transportReady 当 Transport 状态是READY 的时候，开始健康检查\npublic void transportReady() { syncContext.execute(new Runnable() { @Override public void run() { reconnectPolicy = null; if (shutdownReason != null) { Preconditions.checkState(activeTransport == null, \"Unexpected non-null activeTransport\"); transport.shutdown(shutdownReason); } else if (pendingTransport == transport) { activeTransport = transport; pendingTransport = null; gotoNonErrorState(READY); } } }); } io.grpc.internal.InternalSubchannel#gotoState 将状态变为 READY 状态， private void gotoState(final ConnectivityStateInfo newState) { if (state.getState() != newState.getState()) { Preconditions.checkState(state.getState() != SHUTDOWN, \"Cannot transition out of SHUTDOWN to \" + newState); state = newState; callback.onStateChange(InternalSubchannel.this, newState); } } ManagedInternalSubchannelCallback#onStateChange void onStateChange(InternalSubchannel is, ConnectivityStateInfo newState) { // 调用服务发现，重新解析 handleInternalSubchannelState(newState); checkState(listener != null, \"listener is null\"); listener.onSubchannelState(newState); } io.grpc.services.HealthCheckingLoadBalancerFactory.HealthCheckState#onSubchannelState 当 Subchannel 状态发生变化时执行健康检查\npublic void onSubchannelState(ConnectivityStateInfo rawState) { // 如果当前的状态是 READY，且新的状态不是 READY，则更新 disabled 为 false if (Objects.equal(this.rawState.getState(), READY) \u0026\u0026 !Objects.equal(rawState.getState(), READY)) { // 断开连接，将重置已禁用标志，因为健康检查在新连接上可能可用 disabled = false; } // 如果是 SHUTDOWN，则移除 if (Objects.equal(rawState.getState(), SHUTDOWN)) { helperImpl.hcStates.remove(this); } this.rawState = rawState; // 调整健康检查状态 adjustHealthCheck(); } io.grpc.services.HealthCheckingLoadBalancerFactory.HealthCheckState#adjustHealthCheck 当没有禁止，且服务名不为空，且连接状态是 READY，则发送健康检查的请求\nprivate void adjustHealthCheck() { // 如果没有禁止，且服务名不为空，且连接状态是 READY if (!disabled \u0026\u0026 serviceName != null \u0026\u0026 Objects.equal(rawState.getState(), READY)) { running = true; // 如果没有活跃的 RPC，且重试计时器没有等待，则开始 RPC if (activeRpc == null \u0026\u0026 !isRetryTimerPending()) { // 执行健康检查，并根据结果发送请求 startRpc(); } } else { running = false; stopRpc(\"Client stops health check\"); backoffPolicy = null; gotoState(rawState); } } io.grpc.services.HealthCheckingLoadBalancerFactory.HealthCheckState#startRpc 在开始健康检查之前，将连接状态由 READY 改为 CONNECTING； 创建新的 ClientCall.Listener实例 HcStream，并调用 start 方法，发起请求\nprivate void startRpc() { if (!Objects.equal(concludedState.getState(), READY)) { // 修改连接状态 gotoState(ConnectivityStateInfo.forNonError(CONNECTING)); } // 创建新的 ClientCall.Listener activeRpc = new HcStream(); // 开始调用，发出请求 activeRpc.start(); } io.grpc.services.HealthCheckingLoadBalancerFactory.HealthCheckState.HcStream#HcStream 在 HcStream 构造方法中，创建新的 Stream 请求\nHcStream() { stopwatch = stopwatchSupplier.get().start(); callServiceName = serviceName; // 开始新的调用 call = subchannel.asChannel().newCall(HealthGrpc.getWatchMethod(), CallOptions.DEFAULT); } io.grpc.internal.SubchannelChannel#newCall 发起一个 SERVER_STREAMING 请求\npublic \u003cRequestT, ResponseT\u003e ClientCall\u003cRequestT, ResponseT\u003e newCall(MethodDescriptor\u003cRequestT, ResponseT\u003e methodDescriptor, CallOptions callOptions) { final Executor effectiveExecutor = callOptions.getExecutor() == null ? executor : callOptions.getExecutor(); return new ClientCallImpl\u003c\u003e(methodDescriptor, effectiveExecutor, callOptions.withOption(GrpcUtil.CALL_OPTIONS_RPC_OWNED_BY_BALANCER, Boolean.TRUE), transportProvider, deadlineCancellationExecutor, callsTracer, false /* retryEnabled */); } io.grpc.services.HealthCheckingLoadBalancerFactory.HealthCheckState.HcStream#start 开始调用，使用服务名作为健康检查的参数，向服务端发起健康检查请求 此时服务端接收到健康检查请求，根据请求的参数进行检查，然后返回结果\nvoid start() { // 开始调用 call.start(this, new Metadata()); // 发送服务健康检查消息 call.sendMessage(HealthCheckRequest.newBuilder().setService(serviceName).build()); call.halfClose(); call.request(1); } 处理结果 io.grpc.services.HealthCheckingLoadBalancerFactory.HealthCheckState.HcStream#onMessage 监听响应结果，如果是当前 Subchannel的请求响应，则进行处理\npublic void onMessage(final HealthCheckResponse response) { syncContext.execute(new Runnable() { @Override public void run() { // 如果是当前的请求，则进行处理 if (activeRpc == HcStream.this) { // 根据响应更新连接状态 handleResponse(response); } } }); } 根据响应结果处理连接状态 在 io.grpc.services.HealthCheckingLoadBalancerFactory.HealthCheckState.HcStream#handleResponse 方法中处理响应结果；如果是 SERVING状态，则将连接状态改为 READY，否则将状态改为 UNAVAILABLE\nvoid handleResponse(HealthCheckResponse response) { callHasResponded = true; backoffPolicy = null; // 获取返回的状态 ServingStatus status = response.getStatus(); // 如果是服务中，则更新连接状态为 READY if (Objects.equal(status, ServingStatus.SERVING)) { gotoState(ConnectivityStateInfo.forNonError(READY)); } else { // 更新连接状态为 UNAVAILABLE gotoState(ConnectivityStateInfo.forTransientFailure(Status.UNAVAILABLE.withDescription(\"Health-check service responded \" + status + \" for '\" + callServiceName + \"'\"))); } call.request(1); } 也会将 LB 状态也改为 READY，此时 Picker 变为 ReadyPicker，至此，完成健康检查\nServer 端 设置服务状态 默认服务 io.grpc.services.HealthServiceImpl#HealthServiceImpl 内有一个 Map，用于存放各个服务的状态；默认含有一个 key 为 \"\", value 为 SERVING的键值对，当请求参数中没有 seviceName 时直接返回 SERVING 状态\n其他服务 其他服务需要 Server 主动设置状态，具体的逻辑由自己实现，当服务状态发生变化时，通过调用 io.grpc.services.HealthStatusManager#setStatus 进行设置\nio.grpc.services.HealthStatusManager#setStatus public void setStatus(String service, ServingStatus status) { checkNotNull(status, \"status\"); healthService.setStatus(service, status); } io.grpc.services.HealthServiceImpl#setStatus void setStatus(String service, ServingStatus status) { synchronized (watchLock) { if (terminal) { return; } setStatusInternal(service, status); } } io.grpc.services.HealthServiceImpl#setStatusInternal 为 service 设置状态，当状态发生变化时，通过 Stream 发送响应给客户端，通知状态变化\nprivate void setStatusInternal(String service, ServingStatus status) { // 设置新的状态 ServingStatus prevStatus = statusMap.put(service, status); // 如果状态不一样，则通知状态变化 if (prevStatus != status) { notifyWatchers(service, status); } } io.grpc.services.HealthServiceImpl#notifyWatchers 如果有客户端 Stream，则将状态变化通知给所有的监听该服务的客户端\nprivate void notifyWatchers(String service, @Nullable ServingStatus status) { // 构建结果 HealthCheckResponse response = getResponseForWatch(status); IdentityHashMap\u003cStreamObserver\u003cHealthCheckResponse\u003e, Boolean\u003e serviceWatchers = watchers.get(service); // 如果有监听，则遍历所有的监听，发送结果 if (serviceWatchers != null) { for (StreamObserver\u003cHealthCheckResponse\u003e responseObserver : serviceWatchers.keySet()) { responseObserver.onNext(response); } } } 处理健康检查 单次请求 单次健康检查请求通过 io.grpc.services.HealthServiceImpl#check 处理，会根据当前的状态返回\nio.grpc.services.HealthServiceImpl#check public void check(HealthCheckRequest request, StreamObserver\u003cHealthCheckResponse\u003e responseObserver) { // 根据请求中的服务名获取状态 ServingStatus status = statusMap.get(request.getService()); // 如果状态是 null，则返回 NOT_FOUND 错误 if (status == null) { responseObserver.onError(new StatusException(Status.NOT_FOUND.withDescription(\"unknown service \" + request.getService()))); } else { // 根据状态构造响应 HealthCheckResponse response = HealthCheckResponse.newBuilder().setStatus(status).build(); responseObserver.onNext(response); responseObserver.onCompleted(); } } Stream 请求 对于 Stream 请求，是通过 io.grpc.services.HealthServiceImpl#watch 处理 当接收到请求后，会从 Map 中获取服务状态，然后生成响应返回给客户端； 然后将该 StreamObserver 保存到 Service 对应的 Map 中，当 Service 状态发生变化时，通知相应的 Client 同时添加了监听器，当客户端关闭时，从 Map 中移除该 StreamObserver\nio.grpc.services.HealthServiceImpl#watch public void watch(HealthCheckRequest request, final StreamObserver\u003cHealthCheckResponse\u003e responseObserver) { final String service = request.getService(); // 加锁 synchronized (watchLock) { // 根据服务获取状态，构建结果，并发送出去 ServingStatus status = statusMap.get(service); responseObserver.onNext(getResponseForWatch(status)); // 从 watcher 中获取服务名的 map，如果不存在，则创建一个 IdentityHashMap\u003cStreamObserver\u003cHealthCheckResponse\u003e, Boolean\u003e serviceWatchers = watchers.get(service); if (serviceWatchers == null) { serviceWatchers = new IdentityHashMap\u003c\u003e(); watchers.put(service, serviceWatchers); } // 如果存在，则将 responseObserver 添加到 map 中 serviceWatchers.put(responseObserver, Boolean.TRUE); } Context.current().addListener( new CancellationListener() { @Override // Called when the client has closed the stream public void cancelled(Context context) { synchronized (watchLock) { // 当客户端关闭时，从 map 中移除方法对应的数据 IdentityHashMap\u003cStreamObserver\u003cHealthCheckResponse\u003e, Boolean\u003e serviceWatchers = watchers.get(service); if (serviceWatchers != null) { serviceWatchers.remove(responseObserver); if (serviceWatchers.isEmpty()) { watchers.remove(service); } } } } }, MoreExecutors.directExecutor()); } ","wordCount":"1112","inLanguage":"en","datePublished":"2020-09-20T22:37:34Z","dateModified":"2020-09-20T22:37:34Z","author":{"@type":"Person","name":"HelloWood"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.hellowood.dev/posts/grpc-%E5%81%A5%E5%BA%B7%E6%A3%80%E6%9F%A5/"},"publisher":{"@type":"Organization","name":"HelloWood","logo":{"@type":"ImageObject","url":"https://blog.hellowood.dev/favicon.ico"}}}</script><link rel=icon href=/images/avatar.png sizes=16x16><link rel=apple-touch-icon href=/images/avatar.png><link rel=manifest href=/images/avatar.png><link rel=stylesheet href=https://cdn.staticfile.org/lxgw-wenkai-webfont/1.6.0/style.css><link rel=stylesheet href=/css/main.min.ff1bc260fafbfb440e10194d7d06d57eb5e85eed11d12d06255581262664204e.css integrity="sha256-/xvCYPr7+0QOEBlNfQbVfrXoXu0R0S0GJVWBJiZkIE4=" crossorigin=anonymous media=screen><link rel=stylesheet href=/scss/highlight/github-dark.min.min.66034289ee9a113219a2c4aae0a8bd2095ab255c832a42efcf5863f10814e7a1.css><script src=/js/highlight.min.min.c607d6febd16934a82eb61d3a896ed9d869f54373cc63ce95864ed5488fe3128.js></script><script>hljs.highlightAll()</script><script>(()=>{var t=window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches,e=localStorage.getItem("theme");t&&e===null&&(localStorage.setItem("theme","dark"),document.documentElement.setAttribute("data-dark-mode","")),t&&e==="dark"&&document.documentElement.setAttribute("data-dark-mode",""),e==="dark"&&document.documentElement.setAttribute("data-dark-mode","")})()</script><meta name=google-adsense-account content="ca-pub-3401351766168985"><script type=text/javascript>(function(e,t,n,s,o,i,a){e[n]=e[n]||function(){(e[n].q=e[n].q||[]).push(arguments)},i=t.createElement(s),i.async=1,i.src="https://www.clarity.ms/tag/"+o,a=t.getElementsByTagName(s)[0],a.parentNode.insertBefore(i,a)})(window,document,"clarity","script","jtbhx98g62")</script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3401351766168985" crossorigin=anonymous></script></head><body><main class=wrapper><nav class=navigation><section class=container><a class=navigation-brand data-umami-event=navigation-brand href=/>HOME
</a><input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><span></span><span></span><span></span></label><ul class=navigation-list id=navigation-list><li class="navigation-item navigation-menu"><a class=navigation-link data-umami-event=Blog href=/posts>Blog</a></li><li class="navigation-item navigation-menu"><a class=navigation-link data-umami-event=Tags href=/tags>Tags</a></li><li class="navigation-item navigation-menu"><a class=navigation-link data-umami-event=Archive href=/archives>Archive</a></li><li class="navigation-item navigation-menu"><a class=navigation-link data-umami-event=Dashboard href=https://umami.hellowood.dev/share/lab/Blog>Dashboard</a></li><li class="navigation-item menu-separator"><span>|</span></li><li class="navigation-item navigation-social"><a class=navigation-link data-umami-event=navigation-social href=https://github.com/helloworlde><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a></li><li class="navigation-item navigation-dark"><button id=mode type=button data-umami-event=toggle-theme aria-label="toggle user light or dark theme">
<span class=toggle-dark><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-moon"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg></span>
<span class=toggle-light><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-sun"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></span></button></li></ul></section></nav><div id=content><article class=blog-single><header class=blog-title><h1>gRPC 健康检查</h1></header><p><small>September 20, 2020&nbsp;· 1112 words&nbsp;· 6 min</small><p><div class=blog-toc><nav id=TableOfContents><ul><li><a href=#使用>使用</a><ul><li><a href=#server-端>Server 端</a></li><li><a href=#客户端>客户端</a></li></ul></li><li><a href=#实现>实现</a><ul><li><a href=#定义>定义</a></li><li><a href=#客户端-1>客户端</a></li><li><a href=#server-端-1>Server 端</a></li></ul></li></ul></nav></div><section class=blog-content><h1 id=grpc--健康检查>gRPC 健康检查</h1><p>在 gRPC 中使用健康检查，在负载均衡前通过健康检查，只对健康的 Subchannel 发起请求，保证请求的成功率</p><h2 id=使用>使用</h2><h3 id=server-端>Server 端</h3><p>健康检查是一个独立的 Service，需要在 Server 端显式添加健康检查服务</p><p>健康检查定义了两个方法，一个适用于单次请求的 <code>check</code> 方法，另一个是适用于 Stream 流的 <code>watch</code> 方法</p><p>Server 端的健康检查由 <code>io.grpc.services.HealthStatusManager</code>控制，抽象类是 <code>io.grpc.health.v1.HealthGrpc.HealthImplBase</code>，具体实现是通过 <code>io.grpc.services.HealthServiceImpl</code></p><ul><li>在 Server 端添加健康检查服务</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>HealthStatusManager healthStatusManager <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> HealthStatusManager();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Server server <span style=color:#f92672>=</span> ServerBuilder.<span style=color:#a6e22e>forPort</span>(1234)
</span></span><span style=display:flex><span>                             .<span style=color:#a6e22e>addService</span>(healthStatusManager.<span style=color:#a6e22e>getHealthService</span>())
</span></span><span style=display:flex><span>                             .<span style=color:#a6e22e>addService</span>(<span style=color:#66d9ef>new</span> HelloServiceImpl())
</span></span><span style=display:flex><span>                             .<span style=color:#a6e22e>build</span>();
</span></span></code></pre></div><p>这样，当 Server 端启动之后，就可以通过访问 <code>grpc.health.v1.Health</code>服务获取当前的 Server 端的状态</p><h3 id=客户端>客户端</h3><ol><li>添加配置</li></ol><p>客户端开启健康检查有两个条件：</p><ul><li>配置了健康检查参数，配置的名称是 <code>healthCheckConfig</code>，通过指定 <code>serviceName</code> 的方式配置</li><li>使用了支持健康检查的 LB (如 round_robin)</li></ul><p>需要注意，这里的 <code>serviceName</code>可以是组件名称，或者服务名称；服务端默认为 <code>""</code>， 如果想检查某个组件，需要自己实现健康检查的逻辑；配置中的 <code>serviceName</code>只有在 NameReovler 解析到新的配置，且发生变化时才会更新，所以设置 <code>serviceName</code> 意义不大</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>Map<span style=color:#f92672>&lt;</span>String, Object<span style=color:#f92672>&gt;</span> configMap <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> HashMap<span style=color:#f92672>&lt;</span>String, Object<span style=color:#f92672>&gt;</span>() {{
</span></span><span style=display:flex><span>    put(<span style=color:#e6db74>&#34;healthCheckConfig&#34;</span>, <span style=color:#66d9ef>new</span> HashMap<span style=color:#f92672>&lt;</span>String, Object<span style=color:#f92672>&gt;</span>() {{
</span></span><span style=display:flex><span>        put(<span style=color:#e6db74>&#34;serviceName&#34;</span>, <span style=color:#e6db74>&#34;&#34;</span>);
</span></span><span style=display:flex><span>    }});
</span></span><span style=display:flex><span>}};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>channel</span> <span style=color:#f92672>=</span> ManagedChannelBuilder
</span></span><span style=display:flex><span>        .<span style=color:#a6e22e>forTarget</span>(<span style=color:#e6db74>&#34;server&#34;</span>)
</span></span><span style=display:flex><span>        .<span style=color:#a6e22e>usePlaintext</span>()
</span></span><span style=display:flex><span>        .<span style=color:#a6e22e>defaultServiceConfig</span>(configMap)
</span></span><span style=display:flex><span>        .<span style=color:#a6e22e>defaultLoadBalancingPolicy</span>(<span style=color:#e6db74>&#34;round_robin&#34;</span>)
</span></span><span style=display:flex><span>        .<span style=color:#a6e22e>build</span>()
</span></span></code></pre></div><ol start=2><li>执行健康检查</li></ol><p>在发起请求前，会先使用 Service 的名称请求服务端健康检查服务，检查服务是否处于 <code>SERVING</code> 状态，如果状态正常，则发起请求，否则将会失败</p><ul><li>调整日志级别</li></ul><p>将<code>io.grpc.ChannelLogger</code>的日志级别调整到 <code>ALL</code>，用于观察日志</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>Logger logger <span style=color:#f92672>=</span> Logger.<span style=color:#a6e22e>getLogger</span>(<span style=color:#e6db74>&#34;io.grpc.ChannelLogger&#34;</span>);
</span></span><span style=display:flex><span>logger.<span style=color:#a6e22e>setLevel</span>(Level.<span style=color:#a6e22e>ALL</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>ConsoleHandler handler <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ConsoleHandler();
</span></span><span style=display:flex><span>handler.<span style=color:#a6e22e>setLevel</span>(Level.<span style=color:#a6e22e>ALL</span>);
</span></span><span style=display:flex><span>logger.<span style=color:#a6e22e>addHandler</span>(handler);
</span></span></code></pre></div><ul><li>当健康检查成功时输出成功日志</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>非常详细: <span style=color:#f92672>[</span>Subchannel<span style=color:#f92672>&lt;</span>3<span style=color:#f92672>&gt;</span>: (server)<span style=color:#f92672>]</span> CONNECTING: Starting health<span style=color:#f92672>-</span>check <span style=color:#66d9ef>for</span> <span style=color:#e6db74>&#34;io.github.helloworlde.HelloService&#34;</span>
</span></span><span style=display:flex><span>非常详细: <span style=color:#f92672>[</span>Subchannel<span style=color:#f92672>&lt;</span>3<span style=color:#f92672>&gt;</span>: (server)<span style=color:#f92672>]</span> READY: health<span style=color:#f92672>-</span>check responded SERVING
</span></span><span style=display:flex><span>非常详细: <span style=color:#f92672>[</span>Channel<span style=color:#f92672>&lt;</span>1<span style=color:#f92672>&gt;</span>: (server)<span style=color:#f92672>]</span> Entering READY state with picker: ReadyPicker{list<span style=color:#f92672>=[</span>SubchannelImpl{delegate<span style=color:#f92672>=</span>Subchannel<span style=color:#f92672>&lt;</span>3<span style=color:#f92672>&gt;</span>: (server)}<span style=color:#f92672>]</span>}
</span></span></code></pre></div><ul><li>当健康检查失败时输出错误日志</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>非常详细: <span style=color:#f92672>[</span>Subchannel<span style=color:#f92672>&lt;</span>3<span style=color:#f92672>&gt;</span>: (server)<span style=color:#f92672>]</span> READY
</span></span><span style=display:flex><span>非常详细: <span style=color:#f92672>[</span>Subchannel<span style=color:#f92672>&lt;</span>3<span style=color:#f92672>&gt;</span>: (server)<span style=color:#f92672>]</span> CONNECTING: Starting health<span style=color:#f92672>-</span>check <span style=color:#66d9ef>for</span> <span style=color:#e6db74>&#34;io.github.helloworlde.HelloService&#34;</span>
</span></span><span style=display:flex><span>非常详细: <span style=color:#f92672>[</span>Subchannel<span style=color:#f92672>&lt;</span>3<span style=color:#f92672>&gt;</span>: (server)<span style=color:#f92672>]</span> TRANSIENT_FAILURE: health<span style=color:#f92672>-</span>check responded NOT_SERVING
</span></span><span style=display:flex><span>非常详细: <span style=color:#f92672>[</span>Channel<span style=color:#f92672>&lt;</span>1<span style=color:#f92672>&gt;</span>: (server)<span style=color:#f92672>]</span> Entering TRANSIENT_FAILURE state with picker: EmptyPicker{status<span style=color:#f92672>=</span>Status{code<span style=color:#f92672>=</span>UNAVAILABLE, description<span style=color:#f92672>=</span>Health<span style=color:#f92672>-</span>check service responded NOT_SERVING <span style=color:#66d9ef>for</span> <span style=color:#960050;background-color:#1e0010>&#39;</span>io.<span style=color:#a6e22e>github</span>.<span style=color:#a6e22e>helloworlde</span>.<span style=color:#a6e22e>HelloService</span><span style=color:#960050;background-color:#1e0010>&#39;</span>, cause<span style=color:#f92672>=</span><span style=color:#66d9ef>null</span>}}
</span></span><span style=display:flex><span>Exception in thread <span style=color:#e6db74>&#34;main&#34;</span> io.<span style=color:#a6e22e>grpc</span>.<span style=color:#a6e22e>StatusRuntimeException</span>: UNAVAILABLE: Health<span style=color:#f92672>-</span>check service responded NOT_SERVING <span style=color:#66d9ef>for</span> <span style=color:#960050;background-color:#1e0010>&#39;</span>io.<span style=color:#a6e22e>github</span>.<span style=color:#a6e22e>helloworlde</span>.<span style=color:#a6e22e>HelloService</span><span style=color:#960050;background-color:#1e0010>&#39;</span>
</span></span><span style=display:flex><span>	at io.<span style=color:#a6e22e>grpc</span>.<span style=color:#a6e22e>stub</span>.<span style=color:#a6e22e>ClientCalls</span>.<span style=color:#a6e22e>toStatusRuntimeException</span>(ClientCalls.<span style=color:#a6e22e>java</span>:274)
</span></span><span style=display:flex><span>	at io.<span style=color:#a6e22e>grpc</span>.<span style=color:#a6e22e>stub</span>.<span style=color:#a6e22e>ClientCalls</span>.<span style=color:#a6e22e>getUnchecked</span>(ClientCalls.<span style=color:#a6e22e>java</span>:255)
</span></span><span style=display:flex><span>	at io.<span style=color:#a6e22e>grpc</span>.<span style=color:#a6e22e>stub</span>.<span style=color:#a6e22e>ClientCalls</span>.<span style=color:#a6e22e>blockingUnaryCall</span>(ClientCalls.<span style=color:#a6e22e>java</span>:166)
</span></span><span style=display:flex><span>	at io.<span style=color:#a6e22e>github</span>.<span style=color:#a6e22e>helloworlde</span>.<span style=color:#a6e22e>HelloServiceGrpc$HelloServiceBlockingStub</span>.<span style=color:#a6e22e>howAreYou</span>(HelloServiceGrpc.<span style=color:#a6e22e>java</span>:157)
</span></span><span style=display:flex><span>	at io.<span style=color:#a6e22e>github</span>.<span style=color:#a6e22e>helloworlde</span>.<span style=color:#a6e22e>CustomClient</span>.<span style=color:#a6e22e>howAreYou</span>(CustomClient.<span style=color:#a6e22e>java</span>:74)
</span></span><span style=display:flex><span>	at io.<span style=color:#a6e22e>github</span>.<span style=color:#a6e22e>helloworlde</span>.<span style=color:#a6e22e>CustomClient</span>.<span style=color:#a6e22e>main</span>(CustomClient.<span style=color:#a6e22e>java</span>:66)
</span></span></code></pre></div><h2 id=实现>实现</h2><h3 id=定义>定义</h3><p>健康检查通过 <code>health.proto</code> 文件定义</p><ul><li>health.proto</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-protobuf data-lang=protobuf><span style=display:flex><span>syntax <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;proto3&#34;</span>;<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#f92672>package</span> grpc<span style=color:#f92672>.</span>health.v1;<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>option</span> csharp_namespace <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;Grpc.Health.V1&#34;</span>;<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>option</span> go_package <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;google.golang.org/grpc/health/grpc_health_v1&#34;</span>;<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>option</span> java_multiple_files <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>option</span> java_outer_classname <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;HealthProto&#34;</span>;<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>option</span> java_package <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;io.grpc.health.v1&#34;</span>;<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>message</span> <span style=color:#a6e22e>HealthCheckRequest</span> {<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>  <span style=color:#66d9ef>string</span> <span style=color:#66d9ef>service</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>}<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>message</span> <span style=color:#a6e22e>HealthCheckResponse</span> {<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>  <span style=color:#66d9ef>enum</span> ServingStatus {<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>    UNKNOWN <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>    SERVING <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>    NOT_SERVING <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>;<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>    SERVICE_UNKNOWN <span style=color:#f92672>=</span> <span style=color:#ae81ff>3</span>;<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>  }<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>  ServingStatus status <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>}<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>service</span> Health {<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>  <span style=color:#75715e>// 单次健康检查
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>rpc</span> Check(HealthCheckRequest) <span style=color:#66d9ef>returns</span> (HealthCheckResponse);<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>  <span style=color:#75715e>// 流式健康检查
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>rpc</span> Watch(HealthCheckRequest) <span style=color:#66d9ef>returns</span> (stream HealthCheckResponse);<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>}<span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div><h3 id=客户端-1>客户端</h3><h4 id=执行检查>执行检查</h4><h5 id=发起检查>发起检查</h5><ol><li>获取配置</li></ol><p>在 <code>NameResolver</code> 解析后，调用 <code>io.grpc.internal.ManagedChannelImpl.NameResolverListener#onResult</code> 时检查是否有健康检查的配置，如果有则将配置添加到 <code>Attributes</code> 中</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// 获取属性</span>
</span></span><span style=display:flex><span>Attributes effectiveAttrs <span style=color:#f92672>=</span> resolutionResult.<span style=color:#a6e22e>getAttributes</span>();
</span></span><span style=display:flex><span><span style=color:#75715e>// 如果服务发现没有关闭</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> (NameResolverListener.<span style=color:#a6e22e>this</span>.<span style=color:#a6e22e>helper</span> <span style=color:#f92672>==</span> ManagedChannelImpl.<span style=color:#a6e22e>this</span>.<span style=color:#a6e22e>lbHelper</span>) {
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 获取健康检查</span>
</span></span><span style=display:flex><span>  Map<span style=color:#f92672>&lt;</span>String, <span style=color:#f92672>?&gt;</span> healthCheckingConfig <span style=color:#f92672>=</span> effectiveServiceConfig.<span style=color:#a6e22e>getHealthCheckingConfig</span>();
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 构建健康检查配置</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (healthCheckingConfig <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>    effectiveAttrs <span style=color:#f92672>=</span> effectiveAttrs.<span style=color:#a6e22e>toBuilder</span>()
</span></span><span style=display:flex><span>                                   .<span style=color:#a6e22e>set</span>(LoadBalancer.<span style=color:#a6e22e>ATTR_HEALTH_CHECKING_CONFIG</span>, healthCheckingConfig)
</span></span><span style=display:flex><span>                                   .<span style=color:#a6e22e>build</span>();
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 更新负载均衡算法，处理未处理的请求</span>
</span></span><span style=display:flex><span>  Status handleResult <span style=color:#f92672>=</span> helper.<span style=color:#a6e22e>lb</span>.<span style=color:#a6e22e>tryHandleResolvedAddresses</span>(
</span></span><span style=display:flex><span>          ResolvedAddresses.<span style=color:#a6e22e>newBuilder</span>()
</span></span><span style=display:flex><span>                           .<span style=color:#a6e22e>setAddresses</span>(servers)
</span></span><span style=display:flex><span>                           .<span style=color:#a6e22e>setAttributes</span>(effectiveAttrs)
</span></span><span style=display:flex><span>                           .<span style=color:#a6e22e>setLoadBalancingPolicyConfig</span>(effectiveServiceConfig.<span style=color:#a6e22e>getLoadBalancingConfig</span>())
</span></span><span style=display:flex><span>                           .<span style=color:#a6e22e>build</span>());
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ol start=2><li>为 <code>Subchannel</code> 配置健康检查</li></ol><p>通过代理调用 <code>io.grpc.util.RoundRobinLoadBalancer#handleResolvedAddresses</code>方法，然后调用 <code>io.grpc.services.HealthCheckingLoadBalancerFactory.HelperImpl#createSubchannel</code> 方法创建 <code>Subchannel</code>；创建用于健康检查的 <code>SubchannelStateListener</code>的实例 <code>HealthCheckState</code></p><ul><li><code>io.grpc.services.HealthCheckingLoadBalancerFactory.HelperImpl#createSubchannel</code></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>HealthCheckState hcState <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> HealthCheckState(<span style=color:#66d9ef>this</span>, originalSubchannel, syncContext, delegate.<span style=color:#a6e22e>getScheduledExecutorService</span>());
</span></span></code></pre></div><ol start=3><li>添加健康检查</li></ol><p>如果有设置健康检查，则将健康检查添加到 <code>Subchannel</code>健康检查集合中；然后调用 <code>io.grpc.services.HealthCheckingLoadBalancerFactory.HealthCheckState#setServiceName</code> 方法执行</p><ul><li><code>io.grpc.services.HealthCheckingLoadBalancerFactory.HealthCheckState#setServiceName</code></li></ul><p>如果此时有已经提交的请求，则取消，并发送健康检查请求；当第一次执行的时候，如果状态是 <code>IDLE</code>s，则会跳出不执行，直到状态变为<code>READY</code>时执行</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>setServiceName</span>(<span style=color:#a6e22e>@Nullable</span> String newServiceName) {
</span></span><span style=display:flex><span>    serviceName <span style=color:#f92672>=</span> newServiceName;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 如果在 RPC 请求期间服务名称更改，请取消该服务，以便用新名称进行新的调用</span>
</span></span><span style=display:flex><span>    String cancelMsg <span style=color:#f92672>=</span> serviceName <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span> <span style=color:#f92672>?</span> <span style=color:#e6db74>&#34;Health check disabled by service config&#34;</span>
</span></span><span style=display:flex><span>            : <span style=color:#e6db74>&#34;Switching to new service name: &#34;</span> <span style=color:#f92672>+</span> newServiceName;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 停止调用</span>
</span></span><span style=display:flex><span>    stopRpc(cancelMsg);
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 调整健康检查</span>
</span></span><span style=display:flex><span>    adjustHealthCheck();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li><code>io.grpc.internal.InternalSubchannel.TransportListener#transportReady</code></li></ul><p>当 <code>Transport</code> 状态是<code>READY</code> 的时候，开始健康检查</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>transportReady</span>() {
</span></span><span style=display:flex><span>      syncContext.<span style=color:#a6e22e>execute</span>(<span style=color:#66d9ef>new</span> Runnable() {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>run</span>() {
</span></span><span style=display:flex><span>          reconnectPolicy <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>if</span> (shutdownReason <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>            Preconditions.<span style=color:#a6e22e>checkState</span>(activeTransport <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>, <span style=color:#e6db74>&#34;Unexpected non-null activeTransport&#34;</span>);
</span></span><span style=display:flex><span>            transport.<span style=color:#a6e22e>shutdown</span>(shutdownReason);
</span></span><span style=display:flex><span>          } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (pendingTransport <span style=color:#f92672>==</span> transport) {
</span></span><span style=display:flex><span>            activeTransport <span style=color:#f92672>=</span> transport;
</span></span><span style=display:flex><span>            pendingTransport <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>            gotoNonErrorState(READY);
</span></span><span style=display:flex><span>          }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>      });
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><ul><li><code>io.grpc.internal.InternalSubchannel#gotoState</code>
将状态变为 <code>READY</code> 状态，</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>  <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>gotoState</span>(<span style=color:#66d9ef>final</span> ConnectivityStateInfo newState) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (state.<span style=color:#a6e22e>getState</span>() <span style=color:#f92672>!=</span> newState.<span style=color:#a6e22e>getState</span>()) {
</span></span><span style=display:flex><span>      Preconditions.<span style=color:#a6e22e>checkState</span>(state.<span style=color:#a6e22e>getState</span>() <span style=color:#f92672>!=</span> SHUTDOWN,
</span></span><span style=display:flex><span>          <span style=color:#e6db74>&#34;Cannot transition out of SHUTDOWN to &#34;</span> <span style=color:#f92672>+</span> newState);
</span></span><span style=display:flex><span>      state <span style=color:#f92672>=</span> newState;
</span></span><span style=display:flex><span>      callback.<span style=color:#a6e22e>onStateChange</span>(InternalSubchannel.<span style=color:#a6e22e>this</span>, newState);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span></code></pre></div><ul><li><code>ManagedInternalSubchannelCallback#onStateChange</code></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>onStateChange</span>(InternalSubchannel is, ConnectivityStateInfo newState) {
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 调用服务发现，重新解析</span>
</span></span><span style=display:flex><span>  handleInternalSubchannelState(newState);
</span></span><span style=display:flex><span>  checkState(listener <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>, <span style=color:#e6db74>&#34;listener is null&#34;</span>);
</span></span><span style=display:flex><span>  listener.<span style=color:#a6e22e>onSubchannelState</span>(newState);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li><code>io.grpc.services.HealthCheckingLoadBalancerFactory.HealthCheckState#onSubchannelState</code></li></ul><p>当 <code>Subchannel</code> 状态发生变化时执行健康检查</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>onSubchannelState</span>(ConnectivityStateInfo rawState) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 如果当前的状态是 READY，且新的状态不是 READY，则更新 disabled 为 false</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (Objects.<span style=color:#a6e22e>equal</span>(<span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>rawState</span>.<span style=color:#a6e22e>getState</span>(), READY)
</span></span><span style=display:flex><span>            <span style=color:#f92672>&amp;&amp;</span> <span style=color:#f92672>!</span>Objects.<span style=color:#a6e22e>equal</span>(rawState.<span style=color:#a6e22e>getState</span>(), READY)) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 断开连接，将重置已禁用标志，因为健康检查在新连接上可能可用</span>
</span></span><span style=display:flex><span>        disabled <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 如果是 SHUTDOWN，则移除</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (Objects.<span style=color:#a6e22e>equal</span>(rawState.<span style=color:#a6e22e>getState</span>(), SHUTDOWN)) {
</span></span><span style=display:flex><span>        helperImpl.<span style=color:#a6e22e>hcStates</span>.<span style=color:#a6e22e>remove</span>(<span style=color:#66d9ef>this</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>rawState</span> <span style=color:#f92672>=</span> rawState;
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 调整健康检查状态</span>
</span></span><span style=display:flex><span>    adjustHealthCheck();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li><code>io.grpc.services.HealthCheckingLoadBalancerFactory.HealthCheckState#adjustHealthCheck</code></li></ul><p>当没有禁止，且服务名不为空，且连接状态是 READY，则发送健康检查的请求</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>adjustHealthCheck</span>() {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 如果没有禁止，且服务名不为空，且连接状态是 READY</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>disabled <span style=color:#f92672>&amp;&amp;</span> serviceName <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span> <span style=color:#f92672>&amp;&amp;</span> Objects.<span style=color:#a6e22e>equal</span>(rawState.<span style=color:#a6e22e>getState</span>(), READY)) {
</span></span><span style=display:flex><span>        running <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 如果没有活跃的 RPC，且重试计时器没有等待，则开始 RPC</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (activeRpc <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#f92672>!</span>isRetryTimerPending()) {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 执行健康检查，并根据结果发送请求</span>
</span></span><span style=display:flex><span>            startRpc();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        running <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>        stopRpc(<span style=color:#e6db74>&#34;Client stops health check&#34;</span>);
</span></span><span style=display:flex><span>        backoffPolicy <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>        gotoState(rawState);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li><code>io.grpc.services.HealthCheckingLoadBalancerFactory.HealthCheckState#startRpc</code></li></ul><p>在开始健康检查之前，将连接状态由 <code>READY</code> 改为 <code>CONNECTING</code>；
创建新的 <code>ClientCall.Listener</code>实例 <code>HcStream</code>，并调用 <code>start</code> 方法，发起请求</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>startRpc</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>Objects.<span style=color:#a6e22e>equal</span>(concludedState.<span style=color:#a6e22e>getState</span>(), READY)) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 修改连接状态</span>
</span></span><span style=display:flex><span>        gotoState(ConnectivityStateInfo.<span style=color:#a6e22e>forNonError</span>(CONNECTING));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 创建新的 ClientCall.Listener</span>
</span></span><span style=display:flex><span>    activeRpc <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> HcStream();
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 开始调用，发出请求</span>
</span></span><span style=display:flex><span>    activeRpc.<span style=color:#a6e22e>start</span>();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li><code>io.grpc.services.HealthCheckingLoadBalancerFactory.HealthCheckState.HcStream#HcStream</code></li></ul><p>在 <code>HcStream</code> 构造方法中，创建新的 Stream 请求</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>HcStream() {
</span></span><span style=display:flex><span>    stopwatch <span style=color:#f92672>=</span> stopwatchSupplier.<span style=color:#a6e22e>get</span>().<span style=color:#a6e22e>start</span>();
</span></span><span style=display:flex><span>    callServiceName <span style=color:#f92672>=</span> serviceName;
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 开始新的调用</span>
</span></span><span style=display:flex><span>    call <span style=color:#f92672>=</span> subchannel.<span style=color:#a6e22e>asChannel</span>().<span style=color:#a6e22e>newCall</span>(HealthGrpc.<span style=color:#a6e22e>getWatchMethod</span>(), CallOptions.<span style=color:#a6e22e>DEFAULT</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li><code>io.grpc.internal.SubchannelChannel#newCall</code></li></ul><p>发起一个 <code>SERVER_STREAMING</code> 请求</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#f92672>&lt;</span>RequestT, ResponseT<span style=color:#f92672>&gt;</span> ClientCall<span style=color:#f92672>&lt;</span>RequestT, ResponseT<span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>newCall</span>(MethodDescriptor<span style=color:#f92672>&lt;</span>RequestT, ResponseT<span style=color:#f92672>&gt;</span> methodDescriptor, CallOptions callOptions) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>final</span> Executor effectiveExecutor <span style=color:#f92672>=</span> callOptions.<span style=color:#a6e22e>getExecutor</span>() <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span> <span style=color:#f92672>?</span> executor : callOptions.<span style=color:#a6e22e>getExecutor</span>();
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> ClientCallImpl<span style=color:#f92672>&lt;&gt;</span>(methodDescriptor,
</span></span><span style=display:flex><span>        effectiveExecutor,
</span></span><span style=display:flex><span>        callOptions.<span style=color:#a6e22e>withOption</span>(GrpcUtil.<span style=color:#a6e22e>CALL_OPTIONS_RPC_OWNED_BY_BALANCER</span>, Boolean.<span style=color:#a6e22e>TRUE</span>),
</span></span><span style=display:flex><span>        transportProvider, deadlineCancellationExecutor, callsTracer, <span style=color:#66d9ef>false</span> <span style=color:#75715e>/* retryEnabled */</span>);
</span></span><span style=display:flex><span>  }
</span></span></code></pre></div><ul><li><code>io.grpc.services.HealthCheckingLoadBalancerFactory.HealthCheckState.HcStream#start</code></li></ul><p>开始调用，使用服务名作为健康检查的参数，向服务端发起健康检查请求
此时服务端接收到健康检查请求，根据请求的参数进行检查，然后返回结果</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>start</span>() {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 开始调用</span>
</span></span><span style=display:flex><span>    call.<span style=color:#a6e22e>start</span>(<span style=color:#66d9ef>this</span>, <span style=color:#66d9ef>new</span> Metadata());
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 发送服务健康检查消息</span>
</span></span><span style=display:flex><span>    call.<span style=color:#a6e22e>sendMessage</span>(HealthCheckRequest.<span style=color:#a6e22e>newBuilder</span>().<span style=color:#a6e22e>setService</span>(serviceName).<span style=color:#a6e22e>build</span>());
</span></span><span style=display:flex><span>    call.<span style=color:#a6e22e>halfClose</span>();
</span></span><span style=display:flex><span>    call.<span style=color:#a6e22e>request</span>(1);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h5 id=处理结果>处理结果</h5><ul><li><code>io.grpc.services.HealthCheckingLoadBalancerFactory.HealthCheckState.HcStream#onMessage</code></li></ul><p>监听响应结果，如果是当前 <code>Subchannel</code>的请求响应，则进行处理</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>onMessage</span>(<span style=color:#66d9ef>final</span> HealthCheckResponse response) {
</span></span><span style=display:flex><span>    syncContext.<span style=color:#a6e22e>execute</span>(<span style=color:#66d9ef>new</span> Runnable() {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>run</span>() {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 如果是当前的请求，则进行处理</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (activeRpc <span style=color:#f92672>==</span> HcStream.<span style=color:#a6e22e>this</span>) {
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 根据响应更新连接状态</span>
</span></span><span style=display:flex><span>                handleResponse(response);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    });
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>根据响应结果处理连接状态</li></ul><p>在 <code>io.grpc.services.HealthCheckingLoadBalancerFactory.HealthCheckState.HcStream#handleResponse</code> 方法中处理响应结果；如果是 <code>SERVING</code>状态，则将连接状态改为 <code>READY</code>，否则将状态改为 <code>UNAVAILABLE</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>handleResponse</span>(HealthCheckResponse response) {
</span></span><span style=display:flex><span>    callHasResponded <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>    backoffPolicy <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 获取返回的状态</span>
</span></span><span style=display:flex><span>    ServingStatus status <span style=color:#f92672>=</span> response.<span style=color:#a6e22e>getStatus</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 如果是服务中，则更新连接状态为 READY</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (Objects.<span style=color:#a6e22e>equal</span>(status, ServingStatus.<span style=color:#a6e22e>SERVING</span>)) {
</span></span><span style=display:flex><span>        gotoState(ConnectivityStateInfo.<span style=color:#a6e22e>forNonError</span>(READY));
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 更新连接状态为 UNAVAILABLE</span>
</span></span><span style=display:flex><span>        gotoState(ConnectivityStateInfo.<span style=color:#a6e22e>forTransientFailure</span>(Status.<span style=color:#a6e22e>UNAVAILABLE</span>.<span style=color:#a6e22e>withDescription</span>(<span style=color:#e6db74>&#34;Health-check service responded &#34;</span> <span style=color:#f92672>+</span> status <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34; for &#39;&#34;</span> <span style=color:#f92672>+</span> callServiceName <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;&#39;&#34;</span>)));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    call.<span style=color:#a6e22e>request</span>(1);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>也会将 LB 状态也改为 <code>READY</code>，此时 Picker 变为 <code>ReadyPicker</code>，至此，完成健康检查</p><h3 id=server-端-1>Server 端</h3><h4 id=设置服务状态>设置服务状态</h4><h5 id=默认服务>默认服务</h5><p><code>io.grpc.services.HealthServiceImpl#HealthServiceImpl</code> 内有一个 Map，用于存放各个服务的状态；默认含有一个 key 为 <code>""</code>, value 为 <code>SERVING</code>的键值对，当请求参数中没有 seviceName 时直接返回 <code>SERVING</code> 状态</p><h5 id=其他服务>其他服务</h5><p>其他服务需要 Server 主动设置状态，具体的逻辑由自己实现，当服务状态发生变化时，通过调用 <code>io.grpc.services.HealthStatusManager#setStatus</code> 进行设置</p><ul><li><code>io.grpc.services.HealthStatusManager#setStatus</code></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>setStatus</span>(String service, ServingStatus status) {
</span></span><span style=display:flex><span>    checkNotNull(status, <span style=color:#e6db74>&#34;status&#34;</span>);
</span></span><span style=display:flex><span>    healthService.<span style=color:#a6e22e>setStatus</span>(service, status);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li><code>io.grpc.services.HealthServiceImpl#setStatus</code></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>setStatus</span>(String service, ServingStatus status) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>synchronized</span> (watchLock) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (terminal) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        setStatusInternal(service, status);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li><code>io.grpc.services.HealthServiceImpl#setStatusInternal</code></li></ul><p>为 service 设置状态，当状态发生变化时，通过 Stream 发送响应给客户端，通知状态变化</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>setStatusInternal</span>(String service, ServingStatus status) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 设置新的状态</span>
</span></span><span style=display:flex><span>    ServingStatus prevStatus <span style=color:#f92672>=</span> statusMap.<span style=color:#a6e22e>put</span>(service, status);
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 如果状态不一样，则通知状态变化</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (prevStatus <span style=color:#f92672>!=</span> status) {
</span></span><span style=display:flex><span>        notifyWatchers(service, status);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li><code>io.grpc.services.HealthServiceImpl#notifyWatchers</code></li></ul><p>如果有客户端 Stream，则将状态变化通知给所有的监听该服务的客户端</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>notifyWatchers</span>(String service, <span style=color:#a6e22e>@Nullable</span> ServingStatus status) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 构建结果</span>
</span></span><span style=display:flex><span>    HealthCheckResponse response <span style=color:#f92672>=</span> getResponseForWatch(status);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    IdentityHashMap<span style=color:#f92672>&lt;</span>StreamObserver<span style=color:#f92672>&lt;</span>HealthCheckResponse<span style=color:#f92672>&gt;</span>, Boolean<span style=color:#f92672>&gt;</span> serviceWatchers <span style=color:#f92672>=</span> watchers.<span style=color:#a6e22e>get</span>(service);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 如果有监听，则遍历所有的监听，发送结果</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (serviceWatchers <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (StreamObserver<span style=color:#f92672>&lt;</span>HealthCheckResponse<span style=color:#f92672>&gt;</span> responseObserver : serviceWatchers.<span style=color:#a6e22e>keySet</span>()) {
</span></span><span style=display:flex><span>            responseObserver.<span style=color:#a6e22e>onNext</span>(response);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=处理健康检查>处理健康检查</h4><h5 id=单次请求>单次请求</h5><p>单次健康检查请求通过 <code>io.grpc.services.HealthServiceImpl#check</code> 处理，会根据当前的状态返回</p><ul><li><code>io.grpc.services.HealthServiceImpl#check</code></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>check</span>(HealthCheckRequest request,
</span></span><span style=display:flex><span>                  StreamObserver<span style=color:#f92672>&lt;</span>HealthCheckResponse<span style=color:#f92672>&gt;</span> responseObserver) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 根据请求中的服务名获取状态</span>
</span></span><span style=display:flex><span>    ServingStatus status <span style=color:#f92672>=</span> statusMap.<span style=color:#a6e22e>get</span>(request.<span style=color:#a6e22e>getService</span>());
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 如果状态是 null，则返回 NOT_FOUND 错误</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (status <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>        responseObserver.<span style=color:#a6e22e>onError</span>(<span style=color:#66d9ef>new</span> StatusException(Status.<span style=color:#a6e22e>NOT_FOUND</span>.<span style=color:#a6e22e>withDescription</span>(<span style=color:#e6db74>&#34;unknown service &#34;</span> <span style=color:#f92672>+</span> request.<span style=color:#a6e22e>getService</span>())));
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 根据状态构造响应</span>
</span></span><span style=display:flex><span>        HealthCheckResponse response <span style=color:#f92672>=</span> HealthCheckResponse.<span style=color:#a6e22e>newBuilder</span>().<span style=color:#a6e22e>setStatus</span>(status).<span style=color:#a6e22e>build</span>();
</span></span><span style=display:flex><span>        responseObserver.<span style=color:#a6e22e>onNext</span>(response);
</span></span><span style=display:flex><span>        responseObserver.<span style=color:#a6e22e>onCompleted</span>();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h5 id=stream-请求>Stream 请求</h5><p>对于 Stream 请求，是通过 <code>io.grpc.services.HealthServiceImpl#watch</code> 处理
当接收到请求后，会从 Map 中获取服务状态，然后生成响应返回给客户端；
然后将该 <code>StreamObserver</code> 保存到 Service 对应的 Map 中，当 Service 状态发生变化时，通知相应的 Client
同时添加了监听器，当客户端关闭时，从 Map 中移除该 <code>StreamObserver</code></p><ul><li><code>io.grpc.services.HealthServiceImpl#watch</code></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>watch</span>(HealthCheckRequest request,
</span></span><span style=display:flex><span>                  <span style=color:#66d9ef>final</span> StreamObserver<span style=color:#f92672>&lt;</span>HealthCheckResponse<span style=color:#f92672>&gt;</span> responseObserver) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>final</span> String service <span style=color:#f92672>=</span> request.<span style=color:#a6e22e>getService</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 加锁</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>synchronized</span> (watchLock) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 根据服务获取状态，构建结果，并发送出去</span>
</span></span><span style=display:flex><span>        ServingStatus status <span style=color:#f92672>=</span> statusMap.<span style=color:#a6e22e>get</span>(service);
</span></span><span style=display:flex><span>        responseObserver.<span style=color:#a6e22e>onNext</span>(getResponseForWatch(status));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 从 watcher 中获取服务名的 map，如果不存在，则创建一个</span>
</span></span><span style=display:flex><span>        IdentityHashMap<span style=color:#f92672>&lt;</span>StreamObserver<span style=color:#f92672>&lt;</span>HealthCheckResponse<span style=color:#f92672>&gt;</span>, Boolean<span style=color:#f92672>&gt;</span> serviceWatchers <span style=color:#f92672>=</span> watchers.<span style=color:#a6e22e>get</span>(service);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (serviceWatchers <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>            serviceWatchers <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> IdentityHashMap<span style=color:#f92672>&lt;&gt;</span>();
</span></span><span style=display:flex><span>            watchers.<span style=color:#a6e22e>put</span>(service, serviceWatchers);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 如果存在，则将 responseObserver 添加到 map 中</span>
</span></span><span style=display:flex><span>        serviceWatchers.<span style=color:#a6e22e>put</span>(responseObserver, Boolean.<span style=color:#a6e22e>TRUE</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    Context.<span style=color:#a6e22e>current</span>().<span style=color:#a6e22e>addListener</span>(
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>new</span> CancellationListener() {
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// Called when the client has closed the stream</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>cancelled</span>(Context context) {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>synchronized</span> (watchLock) {
</span></span><span style=display:flex><span>                        <span style=color:#75715e>// 当客户端关闭时，从 map 中移除方法对应的数据</span>
</span></span><span style=display:flex><span>                        IdentityHashMap<span style=color:#f92672>&lt;</span>StreamObserver<span style=color:#f92672>&lt;</span>HealthCheckResponse<span style=color:#f92672>&gt;</span>, Boolean<span style=color:#f92672>&gt;</span> serviceWatchers <span style=color:#f92672>=</span> watchers.<span style=color:#a6e22e>get</span>(service);
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>if</span> (serviceWatchers <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>                            serviceWatchers.<span style=color:#a6e22e>remove</span>(responseObserver);
</span></span><span style=display:flex><span>                            <span style=color:#66d9ef>if</span> (serviceWatchers.<span style=color:#a6e22e>isEmpty</span>()) {
</span></span><span style=display:flex><span>                                watchers.<span style=color:#a6e22e>remove</span>(service);
</span></span><span style=display:flex><span>                            }
</span></span><span style=display:flex><span>                        }
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            },
</span></span><span style=display:flex><span>            MoreExecutors.<span style=color:#a6e22e>directExecutor</span>());
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></section><div class=paginator><a class=prev href=https://blog.hellowood.dev/posts/grpc-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%81%A5%E5%BA%B7%E6%A3%80%E6%9F%A5/><svg class="icon" width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M3.77086 21.1546C11.0491 22.698 21.4339 21.7773 21.4339 16.3608V4.63375c0-.69413-.075800000000001-1.3284-.2422-1.86588M3.77086 21.1546C1.9934 20.7777.973585 18.7264 1.08749 16.688c.17931-3.209.06972-7.25665-.08236-10.47293C.87809 3.52811 3.12891 1.16316 5.51029 1.25008c4.25565.15534 9.86671-.04779 13.28091-.24466 1.2952-.074686 2.0494.62843 2.4005 1.76245M3.77086 21.1546C4.56586 21.4723 5.49168 21.7879 6.5 22.0658M21.1917 2.76787c1.918 1.4143 1.9383 9.65123 1.7087 13.59293-2.0526 7.6586-10.5943 7.3054-16.4004 5.705M21.1917 2.76787C21.7612 4.51192 22.7203 9.67216 22 16.3608 21.2797 23.0494 11.3665 22.9511 6.5 22.0658M9.94496 9C9.28897 9.61644 7.63215 10.997 6.04814 11.7966 5.98257 11.8297 5.98456 11.9753 6.05061 12.0063c1.00435.4716 2.8788 1.9201 3.89435 2.9937M6.44444 11.9667C8.86549 12.0608 14 12 16 11" stroke="currentcolor" stroke-linecap="round"/></svg>
<span>gRPC 自定义健康检查</span></a>
<a class=next href=https://blog.hellowood.dev/posts/grpc-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/><span>gRPC 负载均衡</span><svg class="icon" width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M3.77086 21.1546C11.0491 22.698 21.4339 21.7773 21.4339 16.3608V4.63375c0-.69413-.075800000000001-1.3284-.2422-1.86588M3.77086 21.1546C1.9934 20.7777.973585 18.7264 1.08749 16.688c.17931-3.209.06972-7.25665-.08236-10.47293C.87809 3.52811 3.12891 1.16316 5.51029 1.25008c4.25565.15534 9.86671-.04779 13.28091-.24466 1.2952-.074686 2.0494.62843 2.4005 1.76245M3.77086 21.1546C4.56586 21.4723 5.49168 21.7879 6.5 22.0658M21.1917 2.76787c1.918 1.4143 1.9383 9.65123 1.7087 13.59293-2.0526 7.6586-10.5943 7.3054-16.4004 5.705M21.1917 2.76787C21.7612 4.51192 22.7203 9.67216 22 16.3608 21.2797 23.0494 11.3665 22.9511 6.5 22.0658M12.055 9C12.711 9.61644 14.3679 10.997 15.9519 11.7966 16.0174 11.8297 16.0154 11.9753 15.9494 12.0063 14.945 12.4779 13.0706 13.9264 12.055 15m3.5006-3.0333C13.1345 12.0608 8 12 6 11" stroke="currentcolor" stroke-linecap="round"/></svg></a></div></article></div><footer class=footer><p>&copy; 2024 <a href=https://blog.hellowood.dev/>HelloWood</a>
Powered by
<a href=https://gohugo.io/ rel=noopener target=_blank data-umami-event=to-hugo>Hugo️️</a>
<a href=https://github.com/guangzhengli/hugo-theme-ladder rel=noopener target=_blank data-umami-event=to-ladder>Ladder</a>
️</p></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g data-umami-event=top-link><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M10.5376 22.7916C11.0152 22.7207 22.5795 21.1781 22.0978 10.4211 22.0536 9.43274 21.9303 8.53367 21.7387 7.71865M10.5376 22.7916C16.876 22.3728 20.0969 19.8899 21.5383 16.9142M10.5376 22.7916C9.7707 22.9055 8.97982 22.8964 8.19743 22.7725M21.7387 7.71865C21.4988 6.69828 21.1518 5.80967 20.7188 5.04257m1.0199 2.67608C22.6022 10.1105 23.0542 13.7848 21.5383 16.9142M20.7188 5.04257c-3.5504-6.28886-12.88753-4.410077-16.44303.0C2.88063 6.77451-.0433281 11.1668 1.38159 16.6571c.89322 3.4417 3.7911 5.6365 6.81584 6.1154M20.7188 5.04257c1.3509 1.89783 3.3111 6.34223 1.6353 10.37273M21.5383 16.9142C21.8737 16.4251 22.1428 15.9235 22.3541 15.4153M8.19743 22.7725C12.1971 23.4683 20.6281 22.971 22.3541 15.4153M14 10.945C13.3836 10.289 12.003 8.63215 11.2034 7.04814 11.1703 6.98257 11.0247 6.98456 10.9937 7.05061 10.5221 8.05496 9.07362 9.92941 8 10.945m3.0333-3.50056C10.9392 9.86549 11 15 12 17" stroke="currentcolor" stroke-linecap="round"/></svg>
</a><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const s=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="Copy";function n(){t.innerHTML="Copied",setTimeout(()=>{t.innerHTML="Copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),n();return}const s=document.createRange();s.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(s);try{document.execCommand("copy"),n()}catch{}o.removeRange(s)}),e.parentNode.appendChild(t)})</script></main></body><script src=https://cdnjs.cloudflare.com/ajax/libs/medium-zoom/1.0.6/medium-zoom.min.js integrity="sha512-N9IJRoc3LaP3NDoiGkcPa4gG94kapGpaA5Zq9/Dr04uf5TbLFU5q0o8AbRhLKUUlp8QFS2u7S+Yti0U7QtuZvQ==" crossorigin=anonymous referrerpolicy=no-referrer></script><script>const images=Array.from(document.querySelectorAll(".blog-content img"));images.forEach(e=>{mediumZoom(e,{margin:10,scrollOffset:40,container:null,template:null,background:"rgba(0, 0, 0, 0.5)"})})</script><script src=/main.min.6bb26b69159420159c74dc9e097b06a578ed2b68c701466a91a44a9632d851bd0af167a1b30012387b4c512b48ad9ad4d3394e04d77ae38d57e1920fe4ed34fe.js integrity="sha512-a7JraRWUIBWcdNyeCXsGpXjtK2jHAUZqkaRKljLYUb0K8WehswASOHtMUStIrZrU0zlOBNd6441X4ZIP5O00/g==" crossorigin=anonymous defer></script></html>