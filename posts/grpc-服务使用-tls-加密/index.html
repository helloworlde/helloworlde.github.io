<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><style>:root{--accent-color:#FF4D4D}</style><title>gRPC 服务使用 TLS 加密</title>
<meta name=description content="Copy Paste Worker"><meta name=keywords content='blog,hugo,gRPC'><meta property="og:url" content="https://blog.hellowood.dev/posts/grpc-%E6%9C%8D%E5%8A%A1%E4%BD%BF%E7%94%A8-tls-%E5%8A%A0%E5%AF%86/"><meta property="og:type" content="website"><meta property="og:title" content="gRPC 服务使用 TLS 加密"><meta property="og:description" content="Copy Paste Worker"><meta property="og:image" content="https://blog.hellowood.dev/images/avatar.png"><meta property="og:image:secure_url" content="https://blog.hellowood.dev/images/avatar.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:title content="gRPC 服务使用 TLS 加密"><meta name=twitter:description content="Copy Paste Worker"><meta property="twitter:domain" content="https://blog.hellowood.dev/posts/grpc-%E6%9C%8D%E5%8A%A1%E4%BD%BF%E7%94%A8-tls-%E5%8A%A0%E5%AF%86/"><meta property="twitter:url" content="https://blog.hellowood.dev/posts/grpc-%E6%9C%8D%E5%8A%A1%E4%BD%BF%E7%94%A8-tls-%E5%8A%A0%E5%AF%86/"><meta name=twitter:image content="https://blog.hellowood.dev/images/avatar.png"><link rel=canonical href=https://blog.hellowood.dev/posts/grpc-%E6%9C%8D%E5%8A%A1%E4%BD%BF%E7%94%A8-tls-%E5%8A%A0%E5%AF%86/><link rel=stylesheet type=text/css href=/css/normalize.min.css media=print><link rel=stylesheet type=text/css href=/css/main.min.css><link id=dark-theme rel=stylesheet href=/css/dark.min.css><script src=/js/bundle.min.9a920d7dabdbad8363b6a0a94e29a9dfebdb7ee64cfcb193a0145e512ef2bdab.js integrity="sha256-mpINfavbrYNjtqCpTimp3+vbfuZM/LGToBReUS7yvas="></script><meta name=google-adsense-account content="ca-pub-3401351766168985"><script defer src=https://umami.hellowood.dev/script.js data-website-id=7a9034de-0ce7-4756-942a-829e6cd22301></script><script defer src=https://static.cloudflareinsights.com/beacon.min.js data-cf-beacon='{"token": "b2e481d136dc428c8c96c8673e2a04cf"}'></script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3401351766168985" crossorigin=anonymous></script><script defer src=https://analytics.us.umami.is/script.js data-website-id=73ff1c8c-9938-43cf-81af-e77e26b0cca3></script><script type=text/javascript>(function(e,t,n,s,o,i,a){e[n]=e[n]||function(){(e[n].q=e[n].q||[]).push(arguments)},i=t.createElement(s),i.async=1,i.src="https://www.clarity.ms/tag/"+o,a=t.getElementsByTagName(s)[0],a.parentNode.insertBefore(i,a)})(window,document,"clarity","script","jtbhx98g62")</script></head><body><script>setThemeByUserPref()</script><header class=header><nav class=header-nav><div class=avatar><a href=https://blog.hellowood.dev/><img src=/images/avatar.png alt=avatar></a></div><div class=nav-title><a class=nav-brand href=https://blog.hellowood.dev/>HelloWood</a></div><div class=nav-links><div class=nav-link><a href=https://blog.hellowood.dev/><span data-feather=home></span> Home</a></div><div class=nav-link><a href=https://blog.hellowood.dev/posts/><span data-feather=book></span> Posts</a></div><div class=nav-link><a href=https://blog.hellowood.dev/tags/><span data-feather=tag></span> Tags</a></div><div class=nav-link><a href=https://github.com/helloworlde><span data-feather=github></span></a></div><div class=nav-link><a href=https://umami.hellowood.dev/share/lab/Blog><span data-feather=pie-chart></span></a></div><div class=nav-link><a href=https://blog.hellowood.dev/index.xml><span data-feather=rss></span></a></div><span class=nav-icons-divider></span><div class="nav-link dark-theme-toggle"><span class="sr-only dark-theme-toggle-screen-reader-target"></span>
<a><span class=theme-toggle-icon data-feather=moon></span></a></div><div class=nav-link id=hamburger-menu-toggle><span class="sr-only hamburger-menu-toggle-screen-reader-target">menu</span>
<a><span data-feather=menu></span></a></div><ul class="nav-hamburger-list visibility-hidden"><li class=nav-item><a href=https://blog.hellowood.dev/><span data-feather=home></span> Home</a></li><li class=nav-item><a href=https://blog.hellowood.dev/posts/><span data-feather=book></span> Posts</a></li><li class=nav-item><a href=https://blog.hellowood.dev/tags/><span data-feather=tag></span> Tags</a></li><li class=nav-item><a href=https://github.com/helloworlde><span data-feather=github></span></a></li><li class=nav-item><a href=https://umami.hellowood.dev/share/lab/Blog><span data-feather=pie-chart></span></a></li><li class=nav-item><a href=https://blog.hellowood.dev/index.xml><span data-feather=rss></span></a></li><li class="nav-item dark-theme-toggle"><span class="sr-only dark-theme-toggle-screen-reader-target">theme</span>
<a><span class=theme-toggle-icon data-feather=moon></span></a></li></ul></div></nav></header><main id=content><div class="post container"><div class=post-header-section><h1>gRPC 服务使用 TLS 加密</h1><small role=doc-subtitle></small><p class=post-date>2021-01-01</p><ul class=post-tags><li class=post-tag><a href=https://blog.hellowood.dev/tags/grpc>gRPC</a></li></ul></div><div class=post-content><h1 id=grpc-服务使用-tls-加密>gRPC 服务使用 TLS 加密</h1><p>gRPC 支持使用 TLS 对请求进行加密</p><blockquote><p>SSL(Secure Socket Layer，安全套接字)，是面向连接的网络层和应用层协议之间的一种协议层；SSL 通过互相认证、使用数字签名确保完整性、使用加密确保隐私性，以实现客户端和服务端之间的安全通讯</p><p>TLS(Transport Layer Security, 传输层安全协议)，用于两个应用程序之间提供保密性和数据完整性</p><p>SSL是基于 HTTP 之下 TCP 之上的一个协议层，在SSL更新到3.0时，IETF对SSL3.0进行了标准化，并添加了少数机制(但是几乎和SSL3.0无差异)，标准化后的IETF更名为TLS1.0(Transport Layer Security 安全传输层协议)，可以说TLS就是SSL的新版本3.1</p></blockquote><p>相关项目参考 <a href=https://github.com/helloworlde/grpc-java-sample>github.com/helloworlde/grpc-java-sample</a></p><h2 id=生成证书>生成证书</h2><p>可以通过 openssl 生成一个自签名的证书，用于加密</p><ol><li>添加配置</li></ol><p>指定证书的配置，其中 <code>CN</code> 指定了访问的域名，如果实际域名与证书域名不一致，会导致连接失败</p><ul><li>certificate.conf</li></ul><pre tabindex=0><code>[req]
default_bits = 4096
prompt = no
default_md = sha256
req_extensions = req_ext
distinguished_name = dn
[dn]
C = CN
ST = BJ
O = helloworlde
CN = localhost
[req_ext]
subjectAltName = @alt_names
[alt_names]
DNS.1 = localhost
IP.1 = ::1
IP.2 = 127.0.0.1
</code></pre><ol start=2><li>生成证书</li></ol><p>生成自签名的证书，因为 Netty 的 <code>SslContextBuilder</code> 和 <code>SslContext</code> 仅支持 <code>PKCS8</code> 格式的 key，所以需要将其他格式的 key 转换为 <code>PKCS8</code> 格式</p><div class=highlight><pre tabindex=0 style=color:#b0c4de;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>openssl genrsa -out ca.key <span style=color:#d19a66>4096</span> 
</span></span><span style=display:flex><span>openssl req -new -x509 -key ca.key -sha256 -subj <span style=color:#63c381>&#34;/C=US/ST=NJ/O=CA, Inc.&#34;</span> -days <span style=color:#d19a66>3650</span> -out ca.cert 
</span></span><span style=display:flex><span>openssl genrsa -out private.key <span style=color:#d19a66>4096</span> 
</span></span><span style=display:flex><span>openssl req -new -key private.key -out private.csr -config certificate.conf 
</span></span><span style=display:flex><span>openssl x509 -req -in private.csr -CA ca.cert -CAkey ca.key -CAcreateserial -out server.pem -days <span style=color:#d19a66>3650</span> -sha256 -extfile certificate.conf -extensions req_ext 
</span></span><span style=display:flex><span>openssl pkcs8 -topk8 -nocrypt -in private.key -out server.key
</span></span></code></pre></div><p>执行命名后，会生成多个文件，其中 Server 端需要私钥 <code>server.key</code> 以及证书 <code>server.pem</code>，客户端需要证书 <code>server.pem</code></p><h2 id=server-端>Server 端</h2><ul><li>配置 SSL</li></ul><div class=highlight><pre tabindex=0 style=color:#b0c4de;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff><span style=display:flex><span><span style=color:#a2cbff>@Slf4j
</span></span></span><span style=display:flex><span><span style=color:#a2cbff></span>public class TlsServer {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    @SneakyThrows
</span></span><span style=display:flex><span>    public static void main(String[] args) {
</span></span><span style=display:flex><span>        // 初始化 SSL 上下文
</span></span><span style=display:flex><span><span style=color:#a6e22e>+       File keyCertChainFile = new File(&#34;tls/src/main/resources/cert/server.pem&#34;);
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+       File keyFile = new File(&#34;tls/src/main/resources/cert/server.key&#34;);
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+       SslContextBuilder builder = SslContextBuilder.forServer(keyCertChainFile, keyFile);
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+       SslContext sslContext = GrpcSslContexts.configure(builder).build();
</span></span></span><span style=display:flex><span><span style=color:#a6e22e></span>
</span></span><span style=display:flex><span>        // 构建 Server
</span></span><span style=display:flex><span>        Server server = NettyServerBuilder.forAddress(new InetSocketAddress(9090))
</span></span><span style=display:flex><span>                                          // 添加服务
</span></span><span style=display:flex><span>                                          .addService(new HelloServiceImpl())
</span></span><span style=display:flex><span><span style=color:#a6e22e>+                                         .sslContext(sslContext)
</span></span></span><span style=display:flex><span><span style=color:#a6e22e></span>                                          .build();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        // 启动 Server
</span></span><span style=display:flex><span>        server.start();
</span></span><span style=display:flex><span>        log.info(&#34;服务端启动成功&#34;);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        Runtime.getRuntime().addShutdownHook(new Thread(() -&gt; {
</span></span><span style=display:flex><span>            try {
</span></span><span style=display:flex><span>                server.awaitTermination(10, TimeUnit.SECONDS);
</span></span><span style=display:flex><span>            } catch (InterruptedException e) {
</span></span><span style=display:flex><span>                e.printStackTrace();
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        // 保持运行
</span></span><span style=display:flex><span>        server.awaitTermination();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=client-端>Client 端</h2><ul><li>配置 SSL</li></ul><p>为 Channel 指定了 SSL 上下文配置，并且覆盖了 <code>authority</code>，要和证书中的配置一致，用于建立连接时校验</p><div class=highlight><pre tabindex=0 style=color:#b0c4de;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff><span style=display:flex><span><span style=color:#a2cbff>@Slf4j
</span></span></span><span style=display:flex><span><span style=color:#a2cbff></span>public class TlsClient {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    @SneakyThrows
</span></span><span style=display:flex><span>    public static void main(String[] args) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>+       File trustCertCollectionFile = new File(&#34;tls/src/main/resources/cert/server.pem&#34;);
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+       SslContextBuilder builder = GrpcSslContexts.forClient();
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+       SslContext sslContext = builder.trustManager(trustCertCollectionFile).build();
</span></span></span><span style=display:flex><span><span style=color:#a6e22e></span>
</span></span><span style=display:flex><span>        // 构建 Channel
</span></span><span style=display:flex><span>        ManagedChannel channel = NettyChannelBuilder.forAddress(&#34;127.0.0.1&#34;, 9090)
</span></span><span style=display:flex><span><span style=color:#a6e22e>+                                                   .overrideAuthority(&#34;localhost&#34;)
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                                                   .sslContext(sslContext)
</span></span></span><span style=display:flex><span><span style=color:#a6e22e></span>                                                    .build();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        // 使用 Channel 构建 BlockingStub
</span></span><span style=display:flex><span>        HelloServiceGrpc.HelloServiceBlockingStub blockingStub = HelloServiceGrpc.newBlockingStub(channel);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        // 构建消息
</span></span><span style=display:flex><span>        HelloMessage message = HelloMessage.newBuilder()
</span></span><span style=display:flex><span>                                           .setMessage(&#34;TLS&#34;)
</span></span><span style=display:flex><span>                                           .build();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        // 发送消息，并返回响应
</span></span><span style=display:flex><span>        HelloResponse helloResponse = blockingStub.sayHello(message);
</span></span><span style=display:flex><span>        log.info(helloResponse.getMessage());
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        // 等待终止
</span></span><span style=display:flex><span>        channel.awaitTermination(5, TimeUnit.SECONDS);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=测试>测试</h2><ol><li>调整日志级别</li></ol><div class=highlight><pre tabindex=0 style=color:#b0c4de;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>    <span style=color:#c1abea>setLogger</span>(<span style=color:#98c379>&#34;io.grpc&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#c678dd>private</span> <span style=color:#c678dd>static</span> <span style=color:#ef8383>void</span> <span style=color:#00b1f7>setLogger</span>(<span style=color:#c1abea>String</span> <span style=color:#c1abea>className</span>) {
</span></span><span style=display:flex><span>        <span style=color:#c1abea>Logger</span> <span style=color:#c1abea>logger</span> <span style=color:#c7bf54>=</span> <span style=color:#c1abea>Logger</span>.<span style=color:#b3d23c>getLogger</span>(<span style=color:#c1abea>className</span>);
</span></span><span style=display:flex><span>        <span style=color:#c1abea>logger</span>.<span style=color:#b3d23c>setLevel</span>(<span style=color:#c1abea>Level</span>.<span style=color:#b3d23c>ALL</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#c1abea>ConsoleHandler</span> <span style=color:#c1abea>handler</span> <span style=color:#c7bf54>=</span> <span style=color:#c678dd>new</span> <span style=color:#c1abea>ConsoleHandler</span>();
</span></span><span style=display:flex><span>        <span style=color:#c1abea>handler</span>.<span style=color:#b3d23c>setLevel</span>(<span style=color:#c1abea>Level</span>.<span style=color:#b3d23c>ALL</span>);
</span></span><span style=display:flex><span>        <span style=color:#c1abea>logger</span>.<span style=color:#b3d23c>addHandler</span>(<span style=color:#c1abea>handler</span>);
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><ol start=2><li><p>启动 Serve 端</p></li><li><p>启动 Client 端，发起请求</p></li></ol><pre tabindex=0><code>一月 05, 2021 5:22:21 下午 io.grpc.netty.ProtocolNegotiators logSslEngineDetails
较详细: TLS negotiation succeeded.
SSLEngine Details: [
    JDK9 ALPN
    TLS Protocol: TLSv1.2
    Application Protocol: h2
    Need Client Auth: false
    Want Client Auth: false
    Supported protocols=[SSLv2Hello, SSLv3, TLSv1, TLSv1.1, TLSv1.2]
    Enabled protocols=[TLSv1, TLSv1.1, TLSv1.2]
    Supported ciphers=[TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384, TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384, TLS_RSA_WITH_AES_256_CBC_SHA256, TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384, TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384, TLS_DHE_RSA_WITH_AES_256_CBC_SHA256, TLS_DHE_DSS_WITH_AES_256_CBC_SHA256, TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA, TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA, TLS_RSA_WITH_AES_256_CBC_SHA, TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA, TLS_ECDH_RSA_WITH_AES_256_CBC_SHA, TLS_DHE_RSA_WITH_AES_256_CBC_SHA, TLS_DHE_DSS_WITH_AES_256_CBC_SHA, TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256, TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256, TLS_RSA_WITH_AES_128_CBC_SHA256, TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256, TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256, TLS_DHE_RSA_WITH_AES_128_CBC_SHA256, TLS_DHE_DSS_WITH_AES_128_CBC_SHA256, TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA, TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA, TLS_RSA_WITH_AES_128_CBC_SHA, TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA, TLS_ECDH_RSA_WITH_AES_128_CBC_SHA, TLS_DHE_RSA_WITH_AES_128_CBC_SHA, TLS_DHE_DSS_WITH_AES_128_CBC_SHA, TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384, TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256, TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384, TLS_RSA_WITH_AES_256_GCM_SHA384, TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384, TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384, TLS_DHE_RSA_WITH_AES_256_GCM_SHA384, TLS_DHE_DSS_WITH_AES_256_GCM_SHA384, TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256, TLS_RSA_WITH_AES_128_GCM_SHA256, TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256, TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256, TLS_DHE_RSA_WITH_AES_128_GCM_SHA256, TLS_DHE_DSS_WITH_AES_128_GCM_SHA256, TLS_EMPTY_RENEGOTIATION_INFO_SCSV]
    Enabled ciphers=[TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384, TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384, TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256, TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256]
]
一月 05, 2021 5:22:21 下午 io.grpc.ChannelLogger log
非常详细: [NettyClientTransport&lt;4&gt;: (/127.0.0.1:9090)] ClientTls completed
</code></pre><h2 id=参考文档>参考文档</h2><ul><li><a href=https://grpc.io/docs/guides/auth/>Authentication</a></li><li><a href=https://github.com/grpc/grpc-java/blob/master/SECURITY.md>Authentication</a></li><li><a href=http://www.metools.info/code/c84.html>在线RSA PKCS#1、PKCS#8格式转换工具</a></li><li><a href=https://netty.io/wiki/sslcontextbuilder-and-private-key.html>SslContextBuilder and Private Key</a></li><li><a href=https://opendocs.alipay.com/open/common/104740>配置密钥</a></li><li><a href=https://github.com/nleiva/grpc-tls>grpc-tls</a></li><li><a href=https://www.jianshu.com/p/1fc7130eb2c2>TLS详解</a></li></ul></div><div class=prev-next></div><svg id="btt-button" class="arrow-logo" height="1em" viewBox="0 0 384 512" onclick="scrollToTop()" title="Go to top"><path d="M177 159.7l136 136c9.4 9.4 9.4 24.6.0 33.9l-22.6 22.6c-9.4 9.4-24.6 9.4-33.9.0L160 255.9l-96.4 96.4c-9.4 9.4-24.6 9.4-33.9.0L7 329.7c-9.4-9.4-9.4-24.6.0-33.9l136-136c9.4-9.5 24.6-9.5 34-.1z"/></svg>
<script>let backToTopButton=document.getElementById("btt-button");window.onscroll=function(){scrollFunction()};function scrollFunction(){document.body.scrollTop>20||document.documentElement.scrollTop>20?backToTopButton.style.display="block":backToTopButton.style.display="none"}function scrollToTop(){window.scrollTo(0,0)}</script><div id=comments><script src=https://utteranc.es/client.js repo=helloworlde/helloworlde.github.io issue-term=title theme=github-dark crossorigin=anonymous async></script></div></div></main><footer class=footer><span>&copy; 2024 hellowood.dev</span>
<span>Made with &#10084;&#65039; using <a target=_blank href=https://github.com/526avijitgupta/gokarna>Gokarna</a></span></footer></body></html>