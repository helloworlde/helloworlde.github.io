<!doctype html><html lang=en><head><meta name=viewport content="width=device-width,initial-scale=1"><title>gRPC 负载均衡</title>
<meta charset=utf-8><meta name=description content="Ladder@gRPC 负载均衡 gRPC 内定义了 LoadBalancer 接口，用于负载均衡
LoadBalancer 中的主要方法
handleResolvedAddress：处理 NameResolver 解析的地址，用于创建 Subchannel handleNameResolutionError: 处理命名解析失败，会销毁已经存在的 Suchannel requestConnection: 创建连接，会为 Subchannel 初始化 Transport，并建立连接 LoadBalancer 接口有多个实现类，如用于代理的 ForwardingLoadBalancer；基于策略的 RoundRobinLoadBalancer,PickFirstLoadBalancer, GrpclbLoadBalancer等；支持扩展功能的HealthCheckingLoadBalancer, GracefulSwitchLoadBalancer 等
LoadBalancer 有多个内部类，用于实现负载均衡
Factory: 用于创建 LoadBalancer，通过 LoadBalancerProvider 实现 Subchannel: 逻辑连接，一个 Subchannel 内可能包含多个 IP:PORT Helper: 用于创建 LoadBalancer、Subchannel 等 SubchannelPicker: Subchannel 选择器，根据不同的策略使用不同的选择方式 SubchannelStateListener: Subchannel 状态监听器，当 Subchannel 状态发生变化时及时更新 LoadBalancer 的工作流程是：
使用 LoadBalancerRegistry 或者 SPI 的方式注册 LoadBalancerProvider 调用 Channel Builder 的 defaultLoadBalancingPolicy 设置负载均衡策略 在 ManagedChannelImpl 的构造方法中，创建 Factory 在 ManagedChannelImpl#exitIdleMode 中创建 LoadBalancer 实例 将创建的实例作为参数传递给 NameResolverListener 当 NameResolver 解析服务名称后，最终调用 handleResolvedAddresses 方法，根据不同的策略进行处理 LoadBalancer 根据解析的地址创建 Subchannel Subchannel调用 requestConnection 方法建立连接 创建 LoadBalancer 创建 Channel 前注册 Provider LoadBalancerRegistry."><meta name=author content="HelloWood"><link rel=canonical href=https://blog.hellowood.dev/posts/grpc-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/><meta name=google-site-verification content="G-3MSGPYTHPZ"><link rel=alternate type=application/rss+xml href=https://blog.hellowood.dev//index.xml title=HelloWood><script async src="https://www.googletagmanager.com/gtag/js?id=G-3MSGPYTHPZ"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-3MSGPYTHPZ")}</script><script async defer data-website-id=7a9034de-0ce7-4756-942a-829e6cd22301 src=https://umami.hellowood.dev/script.js></script><script defer data-cf-beacon='{"token": "b2e481d136dc428c8c96c8673e2a04cf"}' src=https://static.cloudflareinsights.com/beacon.min.js></script><meta property="og:url" content="https://blog.hellowood.dev/posts/grpc-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"><meta property="og:site_name" content="HelloWood"><meta property="og:title" content="gRPC  负载均衡"><meta property="og:description" content="gRPC 负载均衡 gRPC 内定义了 LoadBalancer 接口，用于负载均衡
LoadBalancer 中的主要方法
handleResolvedAddress：处理 NameResolver 解析的地址，用于创建 Subchannel handleNameResolutionError: 处理命名解析失败，会销毁已经存在的 Suchannel requestConnection: 创建连接，会为 Subchannel 初始化 Transport，并建立连接 LoadBalancer 接口有多个实现类，如用于代理的 ForwardingLoadBalancer；基于策略的 RoundRobinLoadBalancer,PickFirstLoadBalancer, GrpclbLoadBalancer等；支持扩展功能的HealthCheckingLoadBalancer, GracefulSwitchLoadBalancer 等
LoadBalancer 有多个内部类，用于实现负载均衡
Factory: 用于创建 LoadBalancer，通过 LoadBalancerProvider 实现 Subchannel: 逻辑连接，一个 Subchannel 内可能包含多个 IP:PORT Helper: 用于创建 LoadBalancer、Subchannel 等 SubchannelPicker: Subchannel 选择器，根据不同的策略使用不同的选择方式 SubchannelStateListener: Subchannel 状态监听器，当 Subchannel 状态发生变化时及时更新 LoadBalancer 的工作流程是：
使用 LoadBalancerRegistry 或者 SPI 的方式注册 LoadBalancerProvider 调用 Channel Builder 的 defaultLoadBalancingPolicy 设置负载均衡策略 在 ManagedChannelImpl 的构造方法中，创建 Factory 在 ManagedChannelImpl#exitIdleMode 中创建 LoadBalancer 实例 将创建的实例作为参数传递给 NameResolverListener 当 NameResolver 解析服务名称后，最终调用 handleResolvedAddresses 方法，根据不同的策略进行处理 LoadBalancer 根据解析的地址创建 Subchannel Subchannel调用 requestConnection 方法建立连接 创建 LoadBalancer 创建 Channel 前注册 Provider LoadBalancerRegistry."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-09-20T22:36:58+00:00"><meta property="article:modified_time" content="2020-09-20T22:36:58+00:00"><meta property="article:tag" content="GRPC"><meta name=twitter:card content="summary"><meta name=twitter:title content="gRPC  负载均衡"><meta name=twitter:description content="gRPC 负载均衡 gRPC 内定义了 LoadBalancer 接口，用于负载均衡
LoadBalancer 中的主要方法
handleResolvedAddress：处理 NameResolver 解析的地址，用于创建 Subchannel handleNameResolutionError: 处理命名解析失败，会销毁已经存在的 Suchannel requestConnection: 创建连接，会为 Subchannel 初始化 Transport，并建立连接 LoadBalancer 接口有多个实现类，如用于代理的 ForwardingLoadBalancer；基于策略的 RoundRobinLoadBalancer,PickFirstLoadBalancer, GrpclbLoadBalancer等；支持扩展功能的HealthCheckingLoadBalancer, GracefulSwitchLoadBalancer 等
LoadBalancer 有多个内部类，用于实现负载均衡
Factory: 用于创建 LoadBalancer，通过 LoadBalancerProvider 实现 Subchannel: 逻辑连接，一个 Subchannel 内可能包含多个 IP:PORT Helper: 用于创建 LoadBalancer、Subchannel 等 SubchannelPicker: Subchannel 选择器，根据不同的策略使用不同的选择方式 SubchannelStateListener: Subchannel 状态监听器，当 Subchannel 状态发生变化时及时更新 LoadBalancer 的工作流程是：
使用 LoadBalancerRegistry 或者 SPI 的方式注册 LoadBalancerProvider 调用 Channel Builder 的 defaultLoadBalancingPolicy 设置负载均衡策略 在 ManagedChannelImpl 的构造方法中，创建 Factory 在 ManagedChannelImpl#exitIdleMode 中创建 LoadBalancer 实例 将创建的实例作为参数传递给 NameResolverListener 当 NameResolver 解析服务名称后，最终调用 handleResolvedAddresses 方法，根据不同的策略进行处理 LoadBalancer 根据解析的地址创建 Subchannel Subchannel调用 requestConnection 方法建立连接 创建 LoadBalancer 创建 Channel 前注册 Provider LoadBalancerRegistry."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.hellowood.dev/posts/"},{"@type":"ListItem","position":2,"name":"gRPC  负载均衡","item":"https://blog.hellowood.dev/posts/grpc-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"gRPC  负载均衡","name":"gRPC  负载均衡","description":"gRPC 负载均衡 gRPC 内定义了 LoadBalancer 接口，用于负载均衡\nLoadBalancer 中的主要方法\nhandleResolvedAddress：处理 NameResolver 解析的地址，用于创建 Subchannel handleNameResolutionError: 处理命名解析失败，会销毁已经存在的 Suchannel requestConnection: 创建连接，会为 Subchannel 初始化 Transport，并建立连接 LoadBalancer 接口有多个实现类，如用于代理的 ForwardingLoadBalancer；基于策略的 RoundRobinLoadBalancer,PickFirstLoadBalancer, GrpclbLoadBalancer等；支持扩展功能的HealthCheckingLoadBalancer, GracefulSwitchLoadBalancer 等\nLoadBalancer 有多个内部类，用于实现负载均衡\nFactory: 用于创建 LoadBalancer，通过 LoadBalancerProvider 实现 Subchannel: 逻辑连接，一个 Subchannel 内可能包含多个 IP:PORT Helper: 用于创建 LoadBalancer、Subchannel 等 SubchannelPicker: Subchannel 选择器，根据不同的策略使用不同的选择方式 SubchannelStateListener: Subchannel 状态监听器，当 Subchannel 状态发生变化时及时更新 LoadBalancer 的工作流程是：\n使用 LoadBalancerRegistry 或者 SPI 的方式注册 LoadBalancerProvider 调用 Channel Builder 的 defaultLoadBalancingPolicy 设置负载均衡策略 在 ManagedChannelImpl 的构造方法中，创建 Factory 在 ManagedChannelImpl#exitIdleMode 中创建 LoadBalancer 实例 将创建的实例作为参数传递给 NameResolverListener 当 NameResolver 解析服务名称后，最终调用 handleResolvedAddresses 方法，根据不同的策略进行处理 LoadBalancer 根据解析的地址创建 Subchannel Subchannel调用 requestConnection 方法建立连接 创建 LoadBalancer 创建 Channel 前注册 Provider LoadBalancerRegistry.","keywords":["gRPC"],"articleBody":"gRPC 负载均衡 gRPC 内定义了 LoadBalancer 接口，用于负载均衡\nLoadBalancer 中的主要方法\nhandleResolvedAddress：处理 NameResolver 解析的地址，用于创建 Subchannel handleNameResolutionError: 处理命名解析失败，会销毁已经存在的 Suchannel requestConnection: 创建连接，会为 Subchannel 初始化 Transport，并建立连接 LoadBalancer 接口有多个实现类，如用于代理的 ForwardingLoadBalancer；基于策略的 RoundRobinLoadBalancer,PickFirstLoadBalancer, GrpclbLoadBalancer等；支持扩展功能的HealthCheckingLoadBalancer, GracefulSwitchLoadBalancer 等\nLoadBalancer 有多个内部类，用于实现负载均衡\nFactory: 用于创建 LoadBalancer，通过 LoadBalancerProvider 实现 Subchannel: 逻辑连接，一个 Subchannel 内可能包含多个 IP:PORT Helper: 用于创建 LoadBalancer、Subchannel 等 SubchannelPicker: Subchannel 选择器，根据不同的策略使用不同的选择方式 SubchannelStateListener: Subchannel 状态监听器，当 Subchannel 状态发生变化时及时更新 LoadBalancer 的工作流程是：\n使用 LoadBalancerRegistry 或者 SPI 的方式注册 LoadBalancerProvider 调用 Channel Builder 的 defaultLoadBalancingPolicy 设置负载均衡策略 在 ManagedChannelImpl 的构造方法中，创建 Factory 在 ManagedChannelImpl#exitIdleMode 中创建 LoadBalancer 实例 将创建的实例作为参数传递给 NameResolverListener 当 NameResolver 解析服务名称后，最终调用 handleResolvedAddresses 方法，根据不同的策略进行处理 LoadBalancer 根据解析的地址创建 Subchannel Subchannel调用 requestConnection 方法建立连接 创建 LoadBalancer 创建 Channel 前注册 Provider LoadBalancerRegistry.getDefaultRegistry().register(new HealthCheckingRoundRobinLoadBalancerProvider()); 创建 Channel 时设置负载均衡策略 ManagedChannelBuilder.forTarget(\"server\") .defaultLoadBalancingPolicy(\"round_robin\") .build(); 在 io.grpc.internal.ManagedChannelImpl#ManagedChannelImpl 构造方法中初始化 Factory Factory 的实现类是 AutoConfiguredLoadBalancerFactory\nthis.loadBalancerFactory = new AutoConfiguredLoadBalancerFactory(builder.defaultLbPolicy); 在 io.grpc.internal.ManagedChannelImpl#exitIdleMode时创建 LoadBalancer 实例 // 构建新的 lbHelper LbHelperImpl lbHelper = new LbHelperImpl(); // 自动配置负载均衡 lbHelper.lb = loadBalancerFactory.newLoadBalancer(lbHelper); this.lbHelper = lbHelper; 创建 LoadBalancer 实例 AutoConfiguredLoadBalancer public AutoConfiguredLoadBalancer newLoadBalancer(Helper helper) { return new AutoConfiguredLoadBalancer(helper); } AutoConfiguredLoadBalancer(Helper helper) { this.helper = helper; // 从注册器中获取默认的负载均衡策略提供器 delegateProvider = registry.getProvider(defaultPolicy); if (delegateProvider == null) { throw new IllegalStateException(\"Could not find policy '\" + defaultPolicy + \"'. Make sure its implementation is either registered to LoadBalancerRegistry or\" + \" included in META-INF/services/io.grpc.LoadBalancerProvider from your jar files.\"); } // 创建新的 delegate = delegateProvider.newLoadBalancer(helper); } 实现类 io.grpc.services.internal.HealthCheckingRoundRobinLoadBalancerProvider#newLoadBalancer public LoadBalancer newLoadBalancer(Helper helper) { return HealthCheckingLoadBalancerUtil.newHealthCheckingLoadBalancer(rrProvider, helper); } io.grpc.services.HealthCheckingLoadBalancerUtil#newHealthCheckingLoadBalancer public static LoadBalancer newHealthCheckingLoadBalancer(Factory factory, Helper helper) { // 创建工厂 HealthCheckingLoadBalancerFactory hcFactory = new HealthCheckingLoadBalancerFactory(factory, new ExponentialBackoffPolicy.Provider(), GrpcUtil.STOPWATCH_SUPPLIER); // 使用工厂创建 LoadBalancer return hcFactory.newLoadBalancer(helper); } io.grpc.services.HealthCheckingLoadBalancerFactory#newLoadBalancer public LoadBalancer newLoadBalancer(Helper helper) { // 代理 Helper HelperImpl wrappedHelper = new HelperImpl(helper); // 创建 LoadBalancer LoadBalancer delegateBalancer = delegateFactory.newLoadBalancer(wrappedHelper); return new HealthCheckingLoadBalancer(wrappedHelper, delegateBalancer); } 将 LoadBalancer 实例作为参数传递给 NameResolverListener io.grpc.internal.ManagedChannelImpl#exitIdleMode // 服务发现监听器 NameResolverListener listener = new NameResolverListener(lbHelper, nameResolver); nameResolver.start(listener); 负载均衡 根据 NameResolver 解析的地址，创建相应的 Subchannel，在 RPC 请求时根据策略和状态选择其中的一个发起请求\n处理解析的地址 io.grpc.internal.ManagedChannelImpl.NameResolverListener#onResult 根据解析的结果，获取配置，如果有配置健康检查，则添加健康检查的属性，用于 LB 在连接前进行检查\n然后构建参数，调用 io.grpc.internal.AutoConfiguredLoadBalancerFactory.AutoConfiguredLoadBalancer#tryHandleResolvedAddresses 方法处理地址\npublic void run() { List\u003cEquivalentAddressGroup\u003e servers = resolutionResult.getAddresses(); nameResolverBackoffPolicy = null; // ... ManagedChannelServiceConfig effectiveServiceConfig; effectiveServiceConfig = defaultServiceConfig == null ? EMPTY_SERVICE_CONFIG : defaultServiceConfig; // 获取属性 Attributes effectiveAttrs = resolutionResult.getAttributes(); // 如果服务发现没有关闭 if (NameResolverListener.this.helper == ManagedChannelImpl.this.lbHelper) { // 获取健康检查 Map\u003cString, ?\u003e healthCheckingConfig = effectiveServiceConfig.getHealthCheckingConfig(); // 构建健康检查配置 if (healthCheckingConfig != null) { effectiveAttrs = effectiveAttrs.toBuilder() .set(LoadBalancer.ATTR_HEALTH_CHECKING_CONFIG, healthCheckingConfig) .build(); } // 更新负载均衡算法，处理未处理的请求 Status handleResult = helper.lb.tryHandleResolvedAddresses( ResolvedAddresses.newBuilder() .setAddresses(servers) .setAttributes(effectiveAttrs) .setLoadBalancingPolicyConfig(effectiveServiceConfig.getLoadBalancingConfig()) .build()); if (!handleResult.isOk()) { handleErrorInSyncContext(handleResult.augmentDescription(resolver + \" was used\")); } } } 由 LB 处理地址 io.grpc.internal.AutoConfiguredLoadBalancerFactory.AutoConfiguredLoadBalancer#tryHandleResolvedAddresses 先从解析的结果中获取 LoadBalancerProvider，如果不存在，则使用默认的的； 然后获取被代理的 LoadBalancer，调用 handleResolvedAddresses 方法，由具体的 LB 进行处理\nStatus tryHandleResolvedAddresses(ResolvedAddresses resolvedAddresses) { List\u003cEquivalentAddressGroup\u003e servers = resolvedAddresses.getAddresses(); Attributes attributes = resolvedAddresses.getAttributes(); // 负载均衡选择 PolicySelection policySelection = (PolicySelection) resolvedAddresses.getLoadBalancingPolicyConfig(); if (policySelection == null) { LoadBalancerProvider defaultProvider; // 更新负载均衡提供器 defaultProvider = getProviderOrThrow(defaultPolicy, \"using default policy\"); policySelection = new PolicySelection(defaultProvider, null, null); } Object lbConfig = policySelection.config; // 设置负载均衡算法参数 if (lbConfig != null) { attributes = attributes.toBuilder() .set(ATTR_LOAD_BALANCING_CONFIG, policySelection.rawConfig) .build(); } // 负载均衡器 LoadBalancer delegate = getDelegate(); // 如果地址是空的，或者处理失败，则返回错误 if (resolvedAddresses.getAddresses().isEmpty() \u0026\u0026 !delegate.canHandleEmptyAddressListFromNameResolution()) { return Status.UNAVAILABLE.withDescription(\"NameResolver returned no usable address. addrs=\" + servers + \", attrs=\" + attributes); } else { // 返回处理成功 delegate.handleResolvedAddresses( ResolvedAddresses.newBuilder() .setAddresses(resolvedAddresses.getAddresses()) .setAttributes(attributes) .setLoadBalancingPolicyConfig(lbConfig) .build()); return Status.OK; } } io.grpc.services.HealthCheckingLoadBalancerFactory.HealthCheckingLoadBalancer#handleResolvedAddresses 根据配置，获取健康检查的服务名称，然后遍历进行检查 然后调用 io.grpc.util.RoundRobinLoadBalancer#handleResolvedAddresses 进行处理\npublic void handleResolvedAddresses(ResolvedAddresses resolvedAddresses) { // 获取健康检查配置 Map\u003cString, ?\u003e healthCheckingConfig = resolvedAddresses.getAttributes() .get(LoadBalancer.ATTR_HEALTH_CHECKING_CONFIG); // 获取服务的健康检查配置 String serviceName = ServiceConfigUtil.getHealthCheckedServiceName(healthCheckingConfig); // 配置服务健康检查 helper.setHealthCheckedService(serviceName); // 调用被代理的类处理地址 super.handleResolvedAddresses(resolvedAddresses); } io.grpc.util.RoundRobinLoadBalancer#handleResolvedAddresses 在处理地址时，根据现有的地址和新的地址，筛选出需要移除的地址； 然后遍历有效的地址，判断是否已经存在，如果存在，则更新地址集合；如果不存，则调用 io.grpc.services.HealthCheckingLoadBalancerFactory.HelperImpl#createSubchannel 创建 Subchannel，启动 SubchannelStateListener，监听 Subchannel 状态变化；并调用 io.grpc.internal.ManagedChannelImpl.SubchannelImpl#requestConnection要求建立连接\n将需要移除的 Subchannel 从集合中移除，更新 LB 状态，并关闭要移除的 Subchannel\npublic void handleResolvedAddresses(ResolvedAddresses resolvedAddresses) { // 获取地址列表 List\u003cEquivalentAddressGroup\u003e servers = resolvedAddresses.getAddresses(); // 当前的地址 Set\u003cEquivalentAddressGroup\u003e currentAddrs = subchannels.keySet(); // 将地址 List 转为 Map Map\u003cEquivalentAddressGroup, EquivalentAddressGroup\u003e latestAddrs = stripAttrs(servers); // 根据当前的地址，获取需要移除的地址，返回的地址是现有地址中有，新的地址中没有的 Set\u003cEquivalentAddressGroup\u003e removedAddrs = setsDifference(currentAddrs, latestAddrs.keySet()); for (Map.Entry\u003cEquivalentAddressGroup, EquivalentAddressGroup\u003e latestEntry : latestAddrs.entrySet()) { // 不含 Attributes 的 EquivalentAddressGroup EquivalentAddressGroup strippedAddressGroup = latestEntry.getKey(); // 包含 Attributes 的 EquivalentAddressGroup EquivalentAddressGroup originalAddressGroup = latestEntry.getValue(); // 根据地址获取对应的已经存在的 Subchannel Subchannel existingSubchannel = subchannels.get(strippedAddressGroup); // 如果存在已有的 Subchannel，则更新地址并跳出 if (existingSubchannel != null) { // EAG's Attributes may have changed. // 更新地址 existingSubchannel.updateAddresses(Collections.singletonList(originalAddressGroup)); continue; } // 根据地址创建新的 Subchannel // Create new subchannels for new addresses. // 设置新的连接状态是 IDLE Attributes.Builder subchannelAttrs = Attributes.newBuilder() .set(STATE_INFO, new Ref\u003c\u003e(ConnectivityStateInfo.forNonError(IDLE))); // 创建新 Subchannel final Subchannel subchannel = checkNotNull(helper.createSubchannel(CreateSubchannelArgs.newBuilder() .setAddresses(originalAddressGroup) .setAttributes(subchannelAttrs.build()) .build()), \"subchannel\"); // 启动 Subchannel 状态监听器 subchannel.start(new SubchannelStateListener() { @Override public void onSubchannelState(ConnectivityStateInfo state) { // 处理状态变化 processSubchannelState(subchannel, state); } }); // 将新创建的 Subchannel 放在 Subchannel 的 Map 中 subchannels.put(strippedAddressGroup, subchannel); // 要求建立连接 subchannel.requestConnection(); } // 移除不包含的地址 ArrayList\u003cSubchannel\u003e removedSubchannels = new ArrayList\u003c\u003e(); for (EquivalentAddressGroup addressGroup : removedAddrs) { removedSubchannels.add(subchannels.remove(addressGroup)); } // 在关闭 Subchannel 之前更新 picker，减少关闭期间的风险 updateBalancingState(); // 关闭被移除的 Subchannel for (Subchannel removedSubchannel : removedSubchannels) { shutdownSubchannel(removedSubchannel); } } 在请求时做负载均衡 io.grpc.internal.ClientCallImpl#startInternal 在执行 RPC 请求时，调用 io.grpc.internal.ClientCallImpl#start，在获取 ClientTransport 时，创建 PickSubchannelArgsImpl，通过选择 Subchannel 获取 Transport\nClientTransport transport = clientTransportProvider.get(new PickSubchannelArgsImpl(method, headers, callOptions)); io.grpc.internal.ManagedChannelImpl.ChannelTransportProvider#get 这个方法里，根据状态获取 Transport，如果当前的状态是关闭，则直接返回延迟执行的 Transport； 如果 Picker 是空的，则说明还没有执行过，则调用 exitIdleMode 退出空闲模式，并返回延迟执行的Transport; 如果 Picker 已经初始化了，则调用 io.grpc.util.RoundRobinLoadBalancer.ReadyPicker#pickSubchannel选择 Subchannel\npublic ClientTransport get(PickSubchannelArgs args) { SubchannelPicker pickerCopy = subchannelPicker; // 如果是关闭状态，则停止调用 if (shutdown.get()) { return delayedTransport; } // 如果是 SubchannelPicker 是空的，则退出 idle 模模式，返回 delayedTransport if (pickerCopy == null) { final class ExitIdleModeForTransport implements Runnable { @Override public void run() { // 退出 idle 模式，将会创建 LoadBalancer,NameResovler exitIdleMode(); } } syncContext.execute(new ExitIdleModeForTransport()); return delayedTransport; } // 选择某个 SubChannel 发起调用，即选择某个服务端 PickResult pickResult = pickerCopy.pickSubchannel(args); ClientTransport transport = GrpcUtil.getTransportFromPickResult(pickResult, args.getCallOptions().isWaitForReady()); // 如果有 Transport，则返回 if (transport != null) { return transport; } return delayedTransport; } io.grpc.util.RoundRobinLoadBalancer.ReadyPicker#pickSubchannel 获取下一个 Subchannel 并返回\npublic PickResult pickSubchannel(PickSubchannelArgs args) { return PickResult.withSubchannel(nextSubchannel()); } io.grpc.util.RoundRobinLoadBalancer.ReadyPicker#nextSubchannel 通过轮询的算法获取下一个 Subchannel\nprivate Subchannel nextSubchannel() { int size = list.size(); int i = indexUpdater.incrementAndGet(this); if (i \u003e= size) { int oldi = i; i %= size; indexUpdater.compareAndSet(this, oldi, i); } return list.get(i); } ","wordCount":"871","inLanguage":"en","datePublished":"2020-09-20T22:36:58Z","dateModified":"2020-09-20T22:36:58Z","author":{"@type":"Person","name":"HelloWood"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.hellowood.dev/posts/grpc-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"},"publisher":{"@type":"Organization","name":"HelloWood","logo":{"@type":"ImageObject","url":"https://blog.hellowood.dev/favicon.ico"}}}</script><link rel=icon href=/images/avatar.png sizes=16x16><link rel=apple-touch-icon href=/images/avatar.png><link rel=manifest href=/images/avatar.png><link rel=stylesheet href=https://cdn.staticfile.org/lxgw-wenkai-webfont/1.6.0/style.css><link rel=stylesheet href=/css/main.min.7f82854fa0e999ec07c4835d3029de9f484030e254b80d470b3ca48eb934720e.css integrity="sha256-f4KFT6DpmewHxINdMCnen0hAMOJUuA1HCzykjrk0cg4=" crossorigin=anonymous media=screen><link rel=stylesheet href=/scss/highlight/github-dark.min.min.66034289ee9a113219a2c4aae0a8bd2095ab255c832a42efcf5863f10814e7a1.css><script src=/js/highlight.min.min.c607d6febd16934a82eb61d3a896ed9d869f54373cc63ce95864ed5488fe3128.js></script><script>hljs.highlightAll()</script><script>(()=>{var t=window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches,e=localStorage.getItem("theme");t&&e===null&&(localStorage.setItem("theme","dark"),document.documentElement.setAttribute("data-dark-mode","")),t&&e==="dark"&&document.documentElement.setAttribute("data-dark-mode",""),e==="dark"&&document.documentElement.setAttribute("data-dark-mode","")})()</script><meta name=google-adsense-account content="ca-pub-3401351766168985"><script type=text/javascript>(function(e,t,n,s,o,i,a){e[n]=e[n]||function(){(e[n].q=e[n].q||[]).push(arguments)},i=t.createElement(s),i.async=1,i.src="https://www.clarity.ms/tag/"+o,a=t.getElementsByTagName(s)[0],a.parentNode.insertBefore(i,a)})(window,document,"clarity","script","jtbhx98g62")</script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3401351766168985" crossorigin=anonymous></script><script defer src=https://analytics.us.umami.is/script.js data-website-id=73ff1c8c-9938-43cf-81af-e77e26b0cca3></script></head><body><main class=wrapper><nav class=navigation><section class=container><a class=navigation-brand data-umami-event=navigation-brand href=/>HOME
</a><input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><span></span><span></span><span></span></label><ul class=navigation-list id=navigation-list><li class="navigation-item navigation-menu"><a class=navigation-link data-umami-event=Blog href=/posts>Blog</a></li><li class="navigation-item navigation-menu"><a class=navigation-link data-umami-event=Tags href=/tags>Tags</a></li><li class="navigation-item navigation-menu"><a class=navigation-link data-umami-event=Archive href=/archives>Archive</a></li><li class="navigation-item navigation-menu"><a class=navigation-link data-umami-event=Dashboard href=https://umami.hellowood.dev/share/lab/Blog>Dashboard</a></li><li class="navigation-item menu-separator"><span>|</span></li><li class="navigation-item navigation-social"><a class=navigation-link data-umami-event=navigation-social href=https://github.com/helloworlde><svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a></li><li class="navigation-item navigation-dark"><button id=mode type=button data-umami-event=toggle-theme aria-label="toggle user light or dark theme">
<span class=toggle-dark><svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-moon"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg></span>
<span class=toggle-light><svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-sun"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></span></button></li></ul></section></nav><div id=content><article class=blog-single><header class=blog-title><h1>gRPC 负载均衡</h1></header><p><small>September 20, 2020&nbsp;· 871 words&nbsp;· 5 min</small><p><div class=blog-toc><nav id=TableOfContents><ul><li><a href=#创建-loadbalancer>创建 LoadBalancer</a></li><li><a href=#负载均衡>负载均衡</a><ul><li><a href=#处理解析的地址>处理解析的地址</a></li><li><a href=#由-lb-处理地址>由 LB 处理地址</a></li><li><a href=#在请求时做负载均衡>在请求时做负载均衡</a></li></ul></li></ul></nav></div><section class=blog-content><h1 id=grpc--负载均衡>gRPC 负载均衡</h1><p>gRPC 内定义了 LoadBalancer 接口，用于负载均衡</p><p><img alt=grpc-source-code-loadbalancer-methods.png src=https://img.hellowood.dev/picture/grpc-source-code-loadbalancer-methods.png></p><p>LoadBalancer 中的主要方法</p><ul><li><code>handleResolvedAddress</code>：处理 <code>NameResolver</code> 解析的地址，用于创建 <code>Subchannel</code></li><li><code>handleNameResolutionError</code>: 处理命名解析失败，会销毁已经存在的 <code>Suchannel</code></li><li><code>requestConnection</code>: 创建连接，会为 <code>Subchannel</code> 初始化 <code>Transport</code>，并建立连接</li></ul><p><img alt=grpc-source-code-loadbalancer-sub-class.png src=https://img.hellowood.dev/picture/grpc-source-code-loadbalancer-sub-class.png></p><p>LoadBalancer 接口有多个实现类，如用于代理的 <code>ForwardingLoadBalancer</code>；基于策略的 <code>RoundRobinLoadBalancer</code>,<code>PickFirstLoadBalancer</code>, <code>GrpclbLoadBalancer</code>等；支持扩展功能的<code>HealthCheckingLoadBalancer</code>, <code>GracefulSwitchLoadBalancer</code> 等</p><p><img alt=grpc-source-code-loadbalancer-class-diagram.png src=https://img.hellowood.dev/picture/grpc-source-code-loadbalancer-class-diagram.png></p><p>LoadBalancer 有多个内部类，用于实现负载均衡</p><ul><li><code>Factory</code>: 用于创建 <code>LoadBalancer</code>，通过 <code>LoadBalancerProvider</code> 实现</li><li><code>Subchannel</code>: 逻辑连接，一个 <code>Subchannel</code> 内可能包含多个 <code>IP:PORT</code></li><li><code>Helper</code>: 用于创建 <code>LoadBalancer</code>、<code>Subchannel</code> 等</li><li><code>SubchannelPicker</code>: <code>Subchannel</code> 选择器，根据不同的策略使用不同的选择方式</li><li><code>SubchannelStateListener</code>: <code>Subchannel</code> 状态监听器，当 <code>Subchannel</code> 状态发生变化时及时更新</li></ul><p>LoadBalancer 的工作流程是：</p><ol><li>使用 <code>LoadBalancerRegistry</code> 或者 SPI 的方式注册 <code>LoadBalancerProvider</code></li><li>调用 Channel Builder 的 <code>defaultLoadBalancingPolicy</code> 设置负载均衡策略</li><li>在 <code>ManagedChannelImpl</code> 的构造方法中，创建 <code>Factory</code></li><li>在 <code>ManagedChannelImpl#exitIdleMode</code> 中创建 <code>LoadBalancer</code> 实例</li><li>将创建的实例作为参数传递给 <code>NameResolverListener</code></li><li>当 <code>NameResolver</code> 解析服务名称后，最终调用 <code>handleResolvedAddresses </code>方法，根据不同的策略进行处理</li><li><code>LoadBalancer</code> 根据解析的地址创建 <code>Subchannel</code></li><li><code>Subchannel</code>调用 <code>requestConnection</code> 方法建立连接</li></ol><h2 id=创建-loadbalancer>创建 LoadBalancer</h2><ol><li>创建 Channel 前注册 Provider</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>LoadBalancerRegistry.<span style=color:#a6e22e>getDefaultRegistry</span>().<span style=color:#a6e22e>register</span>(<span style=color:#66d9ef>new</span> HealthCheckingRoundRobinLoadBalancerProvider());
</span></span></code></pre></div><ol start=2><li>创建 Channel 时设置负载均衡策略</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>ManagedChannelBuilder.<span style=color:#a6e22e>forTarget</span>(<span style=color:#e6db74>&#34;server&#34;</span>)
</span></span><span style=display:flex><span>                     .<span style=color:#a6e22e>defaultLoadBalancingPolicy</span>(<span style=color:#e6db74>&#34;round_robin&#34;</span>)
</span></span><span style=display:flex><span>                     .<span style=color:#a6e22e>build</span>();
</span></span></code></pre></div><ol start=3><li>在 <code>io.grpc.internal.ManagedChannelImpl#ManagedChannelImpl</code> 构造方法中初始化 Factory</li></ol><p>Factory 的实现类是 <code>AutoConfiguredLoadBalancerFactory</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>loadBalancerFactory</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> AutoConfiguredLoadBalancerFactory(builder.<span style=color:#a6e22e>defaultLbPolicy</span>);
</span></span></code></pre></div><ol start=4><li>在 <code>io.grpc.internal.ManagedChannelImpl#exitIdleMode</code>时创建 <code>LoadBalancer</code> 实例</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// 构建新的 lbHelper</span>
</span></span><span style=display:flex><span>LbHelperImpl lbHelper <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> LbHelperImpl();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 自动配置负载均衡</span>
</span></span><span style=display:flex><span>lbHelper.<span style=color:#a6e22e>lb</span> <span style=color:#f92672>=</span> loadBalancerFactory.<span style=color:#a6e22e>newLoadBalancer</span>(lbHelper);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>lbHelper</span> <span style=color:#f92672>=</span> lbHelper;
</span></span></code></pre></div><ol start=5><li>创建 <code>LoadBalancer</code> 实例</li></ol><ul><li><code>AutoConfiguredLoadBalancer</code></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>    <span style=color:#66d9ef>public</span> AutoConfiguredLoadBalancer <span style=color:#a6e22e>newLoadBalancer</span>(Helper helper) {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> AutoConfiguredLoadBalancer(helper);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    AutoConfiguredLoadBalancer(Helper helper) {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>helper</span> <span style=color:#f92672>=</span> helper;
</span></span><span style=display:flex><span>      <span style=color:#75715e>// 从注册器中获取默认的负载均衡策略提供器</span>
</span></span><span style=display:flex><span>      delegateProvider <span style=color:#f92672>=</span> registry.<span style=color:#a6e22e>getProvider</span>(defaultPolicy);
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> (delegateProvider <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> IllegalStateException(<span style=color:#e6db74>&#34;Could not find policy &#39;&#34;</span> <span style=color:#f92672>+</span> defaultPolicy
</span></span><span style=display:flex><span>                <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;&#39;. Make sure its implementation is either registered to LoadBalancerRegistry or&#34;</span>
</span></span><span style=display:flex><span>                <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34; included in META-INF/services/io.grpc.LoadBalancerProvider from your jar files.&#34;</span>);
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>      <span style=color:#75715e>// 创建新的</span>
</span></span><span style=display:flex><span>      delegate <span style=color:#f92672>=</span> delegateProvider.<span style=color:#a6e22e>newLoadBalancer</span>(helper);
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><ul><li>实现类 <code>io.grpc.services.internal.HealthCheckingRoundRobinLoadBalancerProvider#newLoadBalancer</code></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>    <span style=color:#66d9ef>public</span> LoadBalancer <span style=color:#a6e22e>newLoadBalancer</span>(Helper helper) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> HealthCheckingLoadBalancerUtil.<span style=color:#a6e22e>newHealthCheckingLoadBalancer</span>(rrProvider, helper);
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><ul><li><code>io.grpc.services.HealthCheckingLoadBalancerUtil#newHealthCheckingLoadBalancer</code></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> LoadBalancer <span style=color:#a6e22e>newHealthCheckingLoadBalancer</span>(Factory factory, Helper helper) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 创建工厂</span>
</span></span><span style=display:flex><span>        HealthCheckingLoadBalancerFactory hcFactory <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> HealthCheckingLoadBalancerFactory(factory,
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>new</span> ExponentialBackoffPolicy.<span style=color:#a6e22e>Provider</span>(),
</span></span><span style=display:flex><span>                GrpcUtil.<span style=color:#a6e22e>STOPWATCH_SUPPLIER</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 使用工厂创建 LoadBalancer</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> hcFactory.<span style=color:#a6e22e>newLoadBalancer</span>(helper);
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><ul><li><code>io.grpc.services.HealthCheckingLoadBalancerFactory#newLoadBalancer</code></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>    <span style=color:#66d9ef>public</span> LoadBalancer <span style=color:#a6e22e>newLoadBalancer</span>(Helper helper) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 代理 Helper</span>
</span></span><span style=display:flex><span>        HelperImpl wrappedHelper <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> HelperImpl(helper);
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 创建 LoadBalancer</span>
</span></span><span style=display:flex><span>        LoadBalancer delegateBalancer <span style=color:#f92672>=</span> delegateFactory.<span style=color:#a6e22e>newLoadBalancer</span>(wrappedHelper);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> HealthCheckingLoadBalancer(wrappedHelper, delegateBalancer);
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><ol start=6><li>将 <code>LoadBalancer</code> 实例作为参数传递给 <code>NameResolverListener</code></li></ol><ul><li><code>io.grpc.internal.ManagedChannelImpl#exitIdleMode</code></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// 服务发现监听器</span>
</span></span><span style=display:flex><span>NameResolverListener listener <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> NameResolverListener(lbHelper, nameResolver);
</span></span><span style=display:flex><span>nameResolver.<span style=color:#a6e22e>start</span>(listener);
</span></span></code></pre></div><h2 id=负载均衡>负载均衡</h2><p>根据 <code>NameResolver</code> 解析的地址，创建相应的 <code>Subchannel</code>，在 RPC 请求时根据策略和状态选择其中的一个发起请求</p><h3 id=处理解析的地址>处理解析的地址</h3><ul><li><code>io.grpc.internal.ManagedChannelImpl.NameResolverListener#onResult</code></li></ul><p>根据解析的结果，获取配置，如果有配置健康检查，则添加健康检查的属性，用于 LB 在连接前进行检查</p><p>然后构建参数，调用 <code>io.grpc.internal.AutoConfiguredLoadBalancerFactory.AutoConfiguredLoadBalancer#tryHandleResolvedAddresses</code> 方法处理地址</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>run</span>() {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  List<span style=color:#f92672>&lt;</span>EquivalentAddressGroup<span style=color:#f92672>&gt;</span> servers <span style=color:#f92672>=</span> resolutionResult.<span style=color:#a6e22e>getAddresses</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  nameResolverBackoffPolicy <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>  <span style=color:#75715e>// ...</span>
</span></span><span style=display:flex><span>  ManagedChannelServiceConfig effectiveServiceConfig;
</span></span><span style=display:flex><span>    effectiveServiceConfig <span style=color:#f92672>=</span> defaultServiceConfig <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span> <span style=color:#f92672>?</span> EMPTY_SERVICE_CONFIG : defaultServiceConfig;
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 获取属性</span>
</span></span><span style=display:flex><span>  Attributes effectiveAttrs <span style=color:#f92672>=</span> resolutionResult.<span style=color:#a6e22e>getAttributes</span>();
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 如果服务发现没有关闭</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (NameResolverListener.<span style=color:#a6e22e>this</span>.<span style=color:#a6e22e>helper</span> <span style=color:#f92672>==</span> ManagedChannelImpl.<span style=color:#a6e22e>this</span>.<span style=color:#a6e22e>lbHelper</span>) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 获取健康检查</span>
</span></span><span style=display:flex><span>    Map<span style=color:#f92672>&lt;</span>String, <span style=color:#f92672>?&gt;</span> healthCheckingConfig <span style=color:#f92672>=</span> effectiveServiceConfig.<span style=color:#a6e22e>getHealthCheckingConfig</span>();
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 构建健康检查配置</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (healthCheckingConfig <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>      effectiveAttrs <span style=color:#f92672>=</span> effectiveAttrs.<span style=color:#a6e22e>toBuilder</span>()
</span></span><span style=display:flex><span>                                     .<span style=color:#a6e22e>set</span>(LoadBalancer.<span style=color:#a6e22e>ATTR_HEALTH_CHECKING_CONFIG</span>, healthCheckingConfig)
</span></span><span style=display:flex><span>                                     .<span style=color:#a6e22e>build</span>();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 更新负载均衡算法，处理未处理的请求</span>
</span></span><span style=display:flex><span>    Status handleResult <span style=color:#f92672>=</span> helper.<span style=color:#a6e22e>lb</span>.<span style=color:#a6e22e>tryHandleResolvedAddresses</span>(
</span></span><span style=display:flex><span>            ResolvedAddresses.<span style=color:#a6e22e>newBuilder</span>()
</span></span><span style=display:flex><span>                             .<span style=color:#a6e22e>setAddresses</span>(servers)
</span></span><span style=display:flex><span>                             .<span style=color:#a6e22e>setAttributes</span>(effectiveAttrs)
</span></span><span style=display:flex><span>                             .<span style=color:#a6e22e>setLoadBalancingPolicyConfig</span>(effectiveServiceConfig.<span style=color:#a6e22e>getLoadBalancingConfig</span>())
</span></span><span style=display:flex><span>                             .<span style=color:#a6e22e>build</span>());
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>handleResult.<span style=color:#a6e22e>isOk</span>()) {
</span></span><span style=display:flex><span>      handleErrorInSyncContext(handleResult.<span style=color:#a6e22e>augmentDescription</span>(resolver <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34; was used&#34;</span>));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=由-lb-处理地址>由 LB 处理地址</h3><ul><li><code>io.grpc.internal.AutoConfiguredLoadBalancerFactory.AutoConfiguredLoadBalancer#tryHandleResolvedAddresses</code></li></ul><p>先从解析的结果中获取 <code>LoadBalancerProvider</code>，如果不存在，则使用默认的的；
然后获取被代理的 <code>LoadBalancer</code>，调用 <code>handleResolvedAddresses</code> 方法，由具体的 LB 进行处理</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>    Status <span style=color:#a6e22e>tryHandleResolvedAddresses</span>(ResolvedAddresses resolvedAddresses) {
</span></span><span style=display:flex><span>      List<span style=color:#f92672>&lt;</span>EquivalentAddressGroup<span style=color:#f92672>&gt;</span> servers <span style=color:#f92672>=</span> resolvedAddresses.<span style=color:#a6e22e>getAddresses</span>();
</span></span><span style=display:flex><span>      Attributes attributes <span style=color:#f92672>=</span> resolvedAddresses.<span style=color:#a6e22e>getAttributes</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#75715e>// 负载均衡选择</span>
</span></span><span style=display:flex><span>      PolicySelection policySelection <span style=color:#f92672>=</span> (PolicySelection) resolvedAddresses.<span style=color:#a6e22e>getLoadBalancingPolicyConfig</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> (policySelection <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>        LoadBalancerProvider defaultProvider;
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 更新负载均衡提供器</span>
</span></span><span style=display:flex><span>        defaultProvider <span style=color:#f92672>=</span> getProviderOrThrow(defaultPolicy, <span style=color:#e6db74>&#34;using default policy&#34;</span>);
</span></span><span style=display:flex><span>        policySelection <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> PolicySelection(defaultProvider, <span style=color:#66d9ef>null</span>, <span style=color:#66d9ef>null</span>);
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      Object lbConfig <span style=color:#f92672>=</span> policySelection.<span style=color:#a6e22e>config</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#75715e>// 设置负载均衡算法参数</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> (lbConfig <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>        attributes <span style=color:#f92672>=</span> attributes.<span style=color:#a6e22e>toBuilder</span>()
</span></span><span style=display:flex><span>                               .<span style=color:#a6e22e>set</span>(ATTR_LOAD_BALANCING_CONFIG, policySelection.<span style=color:#a6e22e>rawConfig</span>)
</span></span><span style=display:flex><span>                               .<span style=color:#a6e22e>build</span>();
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#75715e>// 负载均衡器</span>
</span></span><span style=display:flex><span>      LoadBalancer delegate <span style=color:#f92672>=</span> getDelegate();
</span></span><span style=display:flex><span>      <span style=color:#75715e>// 如果地址是空的，或者处理失败，则返回错误</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> (resolvedAddresses.<span style=color:#a6e22e>getAddresses</span>().<span style=color:#a6e22e>isEmpty</span>() <span style=color:#f92672>&amp;&amp;</span> <span style=color:#f92672>!</span>delegate.<span style=color:#a6e22e>canHandleEmptyAddressListFromNameResolution</span>()) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> Status.<span style=color:#a6e22e>UNAVAILABLE</span>.<span style=color:#a6e22e>withDescription</span>(<span style=color:#e6db74>&#34;NameResolver returned no usable address. addrs=&#34;</span> <span style=color:#f92672>+</span> servers <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;, attrs=&#34;</span> <span style=color:#f92672>+</span> attributes);
</span></span><span style=display:flex><span>      } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 返回处理成功</span>
</span></span><span style=display:flex><span>        delegate.<span style=color:#a6e22e>handleResolvedAddresses</span>(
</span></span><span style=display:flex><span>                ResolvedAddresses.<span style=color:#a6e22e>newBuilder</span>()
</span></span><span style=display:flex><span>                                 .<span style=color:#a6e22e>setAddresses</span>(resolvedAddresses.<span style=color:#a6e22e>getAddresses</span>())
</span></span><span style=display:flex><span>                                 .<span style=color:#a6e22e>setAttributes</span>(attributes)
</span></span><span style=display:flex><span>                                 .<span style=color:#a6e22e>setLoadBalancingPolicyConfig</span>(lbConfig)
</span></span><span style=display:flex><span>                                 .<span style=color:#a6e22e>build</span>());
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> Status.<span style=color:#a6e22e>OK</span>;
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><ul><li><code>io.grpc.services.HealthCheckingLoadBalancerFactory.HealthCheckingLoadBalancer#handleResolvedAddresses</code></li></ul><p>根据配置，获取健康检查的服务名称，然后遍历进行检查
然后调用 <code>io.grpc.util.RoundRobinLoadBalancer#handleResolvedAddresses</code> 进行处理</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>handleResolvedAddresses</span>(ResolvedAddresses resolvedAddresses) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 获取健康检查配置</span>
</span></span><span style=display:flex><span>    Map<span style=color:#f92672>&lt;</span>String, <span style=color:#f92672>?&gt;</span> healthCheckingConfig <span style=color:#f92672>=</span> resolvedAddresses.<span style=color:#a6e22e>getAttributes</span>()
</span></span><span style=display:flex><span>                                                           .<span style=color:#a6e22e>get</span>(LoadBalancer.<span style=color:#a6e22e>ATTR_HEALTH_CHECKING_CONFIG</span>);
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 获取服务的健康检查配置</span>
</span></span><span style=display:flex><span>    String serviceName <span style=color:#f92672>=</span> ServiceConfigUtil.<span style=color:#a6e22e>getHealthCheckedServiceName</span>(healthCheckingConfig);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 配置服务健康检查</span>
</span></span><span style=display:flex><span>    helper.<span style=color:#a6e22e>setHealthCheckedService</span>(serviceName);
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 调用被代理的类处理地址</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>super</span>.<span style=color:#a6e22e>handleResolvedAddresses</span>(resolvedAddresses);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li><code>io.grpc.util.RoundRobinLoadBalancer#handleResolvedAddresses</code></li></ul><p>在处理地址时，根据现有的地址和新的地址，筛选出需要移除的地址；
然后遍历有效的地址，判断是否已经存在，如果存在，则更新地址集合；如果不存，则调用 <code>io.grpc.services.HealthCheckingLoadBalancerFactory.HelperImpl#createSubchannel</code> 创建 Subchannel，启动 <code>SubchannelStateListener</code>，监听 Subchannel 状态变化；并调用 <code>io.grpc.internal.ManagedChannelImpl.SubchannelImpl#requestConnection</code>要求建立连接</p><p>将需要移除的 Subchannel 从集合中移除，更新 LB 状态，并关闭要移除的 Subchannel</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>handleResolvedAddresses</span>(ResolvedAddresses resolvedAddresses) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 获取地址列表</span>
</span></span><span style=display:flex><span>    List<span style=color:#f92672>&lt;</span>EquivalentAddressGroup<span style=color:#f92672>&gt;</span> servers <span style=color:#f92672>=</span> resolvedAddresses.<span style=color:#a6e22e>getAddresses</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 当前的地址</span>
</span></span><span style=display:flex><span>    Set<span style=color:#f92672>&lt;</span>EquivalentAddressGroup<span style=color:#f92672>&gt;</span> currentAddrs <span style=color:#f92672>=</span> subchannels.<span style=color:#a6e22e>keySet</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 将地址 List 转为 Map</span>
</span></span><span style=display:flex><span>    Map<span style=color:#f92672>&lt;</span>EquivalentAddressGroup, EquivalentAddressGroup<span style=color:#f92672>&gt;</span> latestAddrs <span style=color:#f92672>=</span> stripAttrs(servers);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 根据当前的地址，获取需要移除的地址，返回的地址是现有地址中有，新的地址中没有的</span>
</span></span><span style=display:flex><span>    Set<span style=color:#f92672>&lt;</span>EquivalentAddressGroup<span style=color:#f92672>&gt;</span> removedAddrs <span style=color:#f92672>=</span> setsDifference(currentAddrs, latestAddrs.<span style=color:#a6e22e>keySet</span>());
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (Map.<span style=color:#a6e22e>Entry</span><span style=color:#f92672>&lt;</span>EquivalentAddressGroup, EquivalentAddressGroup<span style=color:#f92672>&gt;</span> latestEntry : latestAddrs.<span style=color:#a6e22e>entrySet</span>()) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 不含 Attributes 的 EquivalentAddressGroup</span>
</span></span><span style=display:flex><span>        EquivalentAddressGroup strippedAddressGroup <span style=color:#f92672>=</span> latestEntry.<span style=color:#a6e22e>getKey</span>();
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 包含 Attributes 的 EquivalentAddressGroup</span>
</span></span><span style=display:flex><span>        EquivalentAddressGroup originalAddressGroup <span style=color:#f92672>=</span> latestEntry.<span style=color:#a6e22e>getValue</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 根据地址获取对应的已经存在的 Subchannel</span>
</span></span><span style=display:flex><span>        Subchannel existingSubchannel <span style=color:#f92672>=</span> subchannels.<span style=color:#a6e22e>get</span>(strippedAddressGroup);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 如果存在已有的 Subchannel，则更新地址并跳出</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (existingSubchannel <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// EAG&#39;s Attributes may have changed.</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 更新地址</span>
</span></span><span style=display:flex><span>            existingSubchannel.<span style=color:#a6e22e>updateAddresses</span>(Collections.<span style=color:#a6e22e>singletonList</span>(originalAddressGroup));
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 根据地址创建新的 Subchannel</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Create new subchannels for new addresses.</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 设置新的连接状态是 IDLE</span>
</span></span><span style=display:flex><span>        Attributes.<span style=color:#a6e22e>Builder</span> subchannelAttrs <span style=color:#f92672>=</span> Attributes.<span style=color:#a6e22e>newBuilder</span>()
</span></span><span style=display:flex><span>                                                       .<span style=color:#a6e22e>set</span>(STATE_INFO, <span style=color:#66d9ef>new</span> Ref<span style=color:#f92672>&lt;&gt;</span>(ConnectivityStateInfo.<span style=color:#a6e22e>forNonError</span>(IDLE)));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 创建新 Subchannel</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>final</span> Subchannel subchannel <span style=color:#f92672>=</span> checkNotNull(helper.<span style=color:#a6e22e>createSubchannel</span>(CreateSubchannelArgs.<span style=color:#a6e22e>newBuilder</span>()
</span></span><span style=display:flex><span>                                                                                               .<span style=color:#a6e22e>setAddresses</span>(originalAddressGroup)
</span></span><span style=display:flex><span>                                                                                               .<span style=color:#a6e22e>setAttributes</span>(subchannelAttrs.<span style=color:#a6e22e>build</span>())
</span></span><span style=display:flex><span>                                                                                               .<span style=color:#a6e22e>build</span>()),
</span></span><span style=display:flex><span>                <span style=color:#e6db74>&#34;subchannel&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 启动 Subchannel 状态监听器</span>
</span></span><span style=display:flex><span>        subchannel.<span style=color:#a6e22e>start</span>(<span style=color:#66d9ef>new</span> SubchannelStateListener() {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>onSubchannelState</span>(ConnectivityStateInfo state) {
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 处理状态变化</span>
</span></span><span style=display:flex><span>                processSubchannelState(subchannel, state);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        });
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 将新创建的 Subchannel 放在 Subchannel 的 Map 中</span>
</span></span><span style=display:flex><span>        subchannels.<span style=color:#a6e22e>put</span>(strippedAddressGroup, subchannel);
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 要求建立连接</span>
</span></span><span style=display:flex><span>        subchannel.<span style=color:#a6e22e>requestConnection</span>();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 移除不包含的地址</span>
</span></span><span style=display:flex><span>    ArrayList<span style=color:#f92672>&lt;</span>Subchannel<span style=color:#f92672>&gt;</span> removedSubchannels <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ArrayList<span style=color:#f92672>&lt;&gt;</span>();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (EquivalentAddressGroup addressGroup : removedAddrs) {
</span></span><span style=display:flex><span>        removedSubchannels.<span style=color:#a6e22e>add</span>(subchannels.<span style=color:#a6e22e>remove</span>(addressGroup));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 在关闭 Subchannel 之前更新 picker，减少关闭期间的风险</span>
</span></span><span style=display:flex><span>    updateBalancingState();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 关闭被移除的 Subchannel</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (Subchannel removedSubchannel : removedSubchannels) {
</span></span><span style=display:flex><span>        shutdownSubchannel(removedSubchannel);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=在请求时做负载均衡>在请求时做负载均衡</h3><ul><li><code>io.grpc.internal.ClientCallImpl#startInternal</code></li></ul><p>在执行 RPC 请求时，调用 <code>io.grpc.internal.ClientCallImpl#start</code>，在获取 ClientTransport 时，创建 <code>PickSubchannelArgsImpl</code>，通过选择 <code>Subchannel</code> 获取 <code>Transport</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>ClientTransport transport <span style=color:#f92672>=</span> clientTransportProvider.<span style=color:#a6e22e>get</span>(<span style=color:#66d9ef>new</span> PickSubchannelArgsImpl(method, headers, callOptions));
</span></span></code></pre></div><ul><li><code>io.grpc.internal.ManagedChannelImpl.ChannelTransportProvider#get</code></li></ul><p>这个方法里，根据状态获取 <code>Transport</code>，如果当前的状态是关闭，则直接返回延迟执行的 <code>Transport</code>；
如果 Picker 是空的，则说明还没有执行过，则调用 <code>exitIdleMode</code> 退出空闲模式，并返回延迟执行的<code>Transport</code>;
如果 Picker 已经初始化了，则调用 <code>io.grpc.util.RoundRobinLoadBalancer.ReadyPicker#pickSubchannel</code>选择 Subchannel</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>    <span style=color:#66d9ef>public</span> ClientTransport <span style=color:#a6e22e>get</span>(PickSubchannelArgs args) {
</span></span><span style=display:flex><span>      SubchannelPicker pickerCopy <span style=color:#f92672>=</span> subchannelPicker;
</span></span><span style=display:flex><span>      <span style=color:#75715e>// 如果是关闭状态，则停止调用</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> (shutdown.<span style=color:#a6e22e>get</span>()) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> delayedTransport;
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>      
</span></span><span style=display:flex><span>      <span style=color:#75715e>// 如果是 SubchannelPicker 是空的，则退出 idle 模模式，返回 delayedTransport</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> (pickerCopy <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ExitIdleModeForTransport</span> <span style=color:#66d9ef>implements</span> Runnable {
</span></span><span style=display:flex><span>          <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>run</span>() {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 退出 idle 模式，将会创建 LoadBalancer,NameResovler</span>
</span></span><span style=display:flex><span>            exitIdleMode();
</span></span><span style=display:flex><span>          }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        syncContext.<span style=color:#a6e22e>execute</span>(<span style=color:#66d9ef>new</span> ExitIdleModeForTransport());
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> delayedTransport;
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>      <span style=color:#75715e>// 选择某个 SubChannel 发起调用，即选择某个服务端</span>
</span></span><span style=display:flex><span>      PickResult pickResult <span style=color:#f92672>=</span> pickerCopy.<span style=color:#a6e22e>pickSubchannel</span>(args);
</span></span><span style=display:flex><span>      ClientTransport transport <span style=color:#f92672>=</span> GrpcUtil.<span style=color:#a6e22e>getTransportFromPickResult</span>(pickResult, args.<span style=color:#a6e22e>getCallOptions</span>().<span style=color:#a6e22e>isWaitForReady</span>());
</span></span><span style=display:flex><span>      <span style=color:#75715e>// 如果有 Transport，则返回</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> (transport <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> transport;
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>return</span> delayedTransport;
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><ul><li><code>io.grpc.util.RoundRobinLoadBalancer.ReadyPicker#pickSubchannel</code></li></ul><p>获取下一个 Subchannel 并返回</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> PickResult <span style=color:#a6e22e>pickSubchannel</span>(PickSubchannelArgs args) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> PickResult.<span style=color:#a6e22e>withSubchannel</span>(nextSubchannel());
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li><code>io.grpc.util.RoundRobinLoadBalancer.ReadyPicker#nextSubchannel</code></li></ul><p>通过轮询的算法获取下一个 Subchannel</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>private</span> Subchannel <span style=color:#a6e22e>nextSubchannel</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> size <span style=color:#f92672>=</span> list.<span style=color:#a6e22e>size</span>();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> indexUpdater.<span style=color:#a6e22e>incrementAndGet</span>(<span style=color:#66d9ef>this</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (i <span style=color:#f92672>&gt;=</span> size) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> oldi <span style=color:#f92672>=</span> i;
</span></span><span style=display:flex><span>        i <span style=color:#f92672>%=</span> size;
</span></span><span style=display:flex><span>        indexUpdater.<span style=color:#a6e22e>compareAndSet</span>(<span style=color:#66d9ef>this</span>, oldi, i);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> list.<span style=color:#a6e22e>get</span>(i);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></section><div class=paginator><a class=prev href=https://blog.hellowood.dev/posts/grpc-%E5%81%A5%E5%BA%B7%E6%A3%80%E6%9F%A5/><svg class="icon" width="24" height="24" viewBox="0 0 24 24" fill="none"><path d="M3.77086 21.1546C11.0491 22.698 21.4339 21.7773 21.4339 16.3608V4.63375c0-.69413-.075800000000001-1.3284-.2422-1.86588M3.77086 21.1546C1.9934 20.7777.973585 18.7264 1.08749 16.688c.17931-3.209.06972-7.25665-.08236-10.47293C.87809 3.52811 3.12891 1.16316 5.51029 1.25008c4.25565.15534 9.86671-.04779 13.28091-.24466 1.2952-.074686 2.0494.62843 2.4005 1.76245M3.77086 21.1546C4.56586 21.4723 5.49168 21.7879 6.5 22.0658M21.1917 2.76787c1.918 1.4143 1.9383 9.65123 1.7087 13.59293-2.0526 7.6586-10.5943 7.3054-16.4004 5.705M21.1917 2.76787C21.7612 4.51192 22.7203 9.67216 22 16.3608 21.2797 23.0494 11.3665 22.9511 6.5 22.0658M9.94496 9C9.28897 9.61644 7.63215 10.997 6.04814 11.7966 5.98257 11.8297 5.98456 11.9753 6.05061 12.0063c1.00435.4716 2.8788 1.9201 3.89435 2.9937M6.44444 11.9667C8.86549 12.0608 14 12 16 11" stroke="currentcolor" stroke-linecap="round"/></svg>
<span>gRPC 健康检查</span></a>
<a class=next href=https://blog.hellowood.dev/posts/hpa-%E4%BD%BF%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9A%84%E6%8C%87%E6%A0%87%E8%87%AA%E5%8A%A8%E6%89%A9%E7%BC%A9%E5%AE%B9/><span>HPA 使用自定义的指标自动扩缩容</span><svg class="icon" width="24" height="24" viewBox="0 0 24 24" fill="none"><path d="M3.77086 21.1546C11.0491 22.698 21.4339 21.7773 21.4339 16.3608V4.63375c0-.69413-.075800000000001-1.3284-.2422-1.86588M3.77086 21.1546C1.9934 20.7777.973585 18.7264 1.08749 16.688c.17931-3.209.06972-7.25665-.08236-10.47293C.87809 3.52811 3.12891 1.16316 5.51029 1.25008c4.25565.15534 9.86671-.04779 13.28091-.24466 1.2952-.074686 2.0494.62843 2.4005 1.76245M3.77086 21.1546C4.56586 21.4723 5.49168 21.7879 6.5 22.0658M21.1917 2.76787c1.918 1.4143 1.9383 9.65123 1.7087 13.59293-2.0526 7.6586-10.5943 7.3054-16.4004 5.705M21.1917 2.76787C21.7612 4.51192 22.7203 9.67216 22 16.3608 21.2797 23.0494 11.3665 22.9511 6.5 22.0658M12.055 9C12.711 9.61644 14.3679 10.997 15.9519 11.7966 16.0174 11.8297 16.0154 11.9753 15.9494 12.0063 14.945 12.4779 13.0706 13.9264 12.055 15m3.5006-3.0333C13.1345 12.0608 8 12 6 11" stroke="currentcolor" stroke-linecap="round"/></svg></a></div></article></div><footer class=footer><p>&copy; 2024 <a href=https://blog.hellowood.dev/>HelloWood</a>
Powered by
<a href=https://gohugo.io/ rel=noopener target=_blank data-umami-event=to-hugo>Hugo️️</a>
<a href=https://github.com/guangzhengli/hugo-theme-ladder rel=noopener target=_blank data-umami-event=to-ladder>Ladder</a>
️</p></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g data-umami-event=top-link><svg width="24" height="24" viewBox="0 0 24 24" fill="none"><path d="M10.5376 22.7916C11.0152 22.7207 22.5795 21.1781 22.0978 10.4211 22.0536 9.43274 21.9303 8.53367 21.7387 7.71865M10.5376 22.7916C16.876 22.3728 20.0969 19.8899 21.5383 16.9142M10.5376 22.7916C9.7707 22.9055 8.97982 22.8964 8.19743 22.7725M21.7387 7.71865C21.4988 6.69828 21.1518 5.80967 20.7188 5.04257m1.0199 2.67608C22.6022 10.1105 23.0542 13.7848 21.5383 16.9142M20.7188 5.04257c-3.5504-6.28886-12.88753-4.410077-16.44303.0C2.88063 6.77451-.0433281 11.1668 1.38159 16.6571c.89322 3.4417 3.7911 5.6365 6.81584 6.1154M20.7188 5.04257c1.3509 1.89783 3.3111 6.34223 1.6353 10.37273M21.5383 16.9142C21.8737 16.4251 22.1428 15.9235 22.3541 15.4153M8.19743 22.7725C12.1971 23.4683 20.6281 22.971 22.3541 15.4153M14 10.945C13.3836 10.289 12.003 8.63215 11.2034 7.04814 11.1703 6.98257 11.0247 6.98456 10.9937 7.05061 10.5221 8.05496 9.07362 9.92941 8 10.945m3.0333-3.50056C10.9392 9.86549 11 15 12 17" stroke="currentcolor" stroke-linecap="round"/></svg>
</a><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const s=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="Copy";function n(){t.innerHTML="Copied",setTimeout(()=>{t.innerHTML="Copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),n();return}const s=document.createRange();s.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(s);try{document.execCommand("copy"),n()}catch{}o.removeRange(s)}),e.parentNode.appendChild(t)})</script></main></body><script src=https://cdnjs.cloudflare.com/ajax/libs/medium-zoom/1.0.6/medium-zoom.min.js integrity="sha512-N9IJRoc3LaP3NDoiGkcPa4gG94kapGpaA5Zq9/Dr04uf5TbLFU5q0o8AbRhLKUUlp8QFS2u7S+Yti0U7QtuZvQ==" crossorigin=anonymous referrerpolicy=no-referrer></script><script>const images=Array.from(document.querySelectorAll(".blog-content img"));images.forEach(e=>{mediumZoom(e,{margin:10,scrollOffset:40,container:null,template:null,background:"rgba(0, 0, 0, 0.5)"})})</script><script src=/main.min.6bb26b69159420159c74dc9e097b06a578ed2b68c701466a91a44a9632d851bd0af167a1b30012387b4c512b48ad9ad4d3394e04d77ae38d57e1920fe4ed34fe.js integrity="sha512-a7JraRWUIBWcdNyeCXsGpXjtK2jHAUZqkaRKljLYUb0K8WehswASOHtMUStIrZrU0zlOBNd6441X4ZIP5O00/g==" crossorigin=anonymous defer></script></html>