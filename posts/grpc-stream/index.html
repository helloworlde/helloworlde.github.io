<!doctype html><html lang=en><head><meta name=viewport content="width=device-width,initial-scale=1"><title>gRPC Stream</title>
<meta charset=utf-8><meta name=description content="Ladder@gRPC Stream Stream 在 gRPC 中代表一个真正的请求，包含要发送的 消息；Stream 分为 ClientStream 和 ServerStream
ClientStream ClientStream 接口继承 Stream 接口，有多个实现类或抽象实现类：
ForwardingClientStream: 用于转发的 ClientStream，支持代理真正的流，可以用于触发一些动作，如统计等 NoopClientStream: 不做任何操作的 ClientStream，用于空实现 FailingClientStream: 用于失败的 ClientStream，处理请求失败的场景 InProcessClientStream: 进程内的 ClientStream，用于测试，不会发出实际请求 AbstractClientStream: ClientStream 的抽象实现类，实现了部分基础操作，如发送header，写入消息，半关闭等 NettyClientStream: 基于 Netty 实现的 ClientStream，实现了基于 Netty 的帧操作等 OkHttpClientStream: 基于 OkHttp 实现的 ClientStream，实现了基于 OkHttp 的帧操作等 方法 start 开始一个新的流，对于每一个流，只能调用一次
void start(ClientStreamListener listener); halfClose 从客户端关闭流，当关闭后，不能发送更多的消息，但是可以接收消息，只能调用一次
void halfClose(); cancel 异常终止流，当调用后不会再发送和接收消息，只有在 start 之后才可以被调用
void cancel(Status reason); setDeadline 设置请求有效截止时间，过了这个时间之后就会终止请求执行
void setDeadline(@Nonnull Deadline deadline); getAttributes 获取流的属性"><meta name=author content="HelloWood"><link rel=canonical href=https://blog.hellowood.dev/posts/grpc-stream/><meta name=google-site-verification content="G-3MSGPYTHPZ"><link rel=alternate type=application/rss+xml href=https://blog.hellowood.dev//index.xml title=HelloWood><script async src="https://www.googletagmanager.com/gtag/js?id=G-3MSGPYTHPZ"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-3MSGPYTHPZ")}</script><script async defer data-website-id=7a9034de-0ce7-4756-942a-829e6cd22301 src=https://umami.hellowood.dev/script.js></script><script defer data-cf-beacon='{"token": "b2e481d136dc428c8c96c8673e2a04cf"}' src=https://static.cloudflareinsights.com/beacon.min.js></script><meta property="og:url" content="https://blog.hellowood.dev/posts/grpc-stream/"><meta property="og:site_name" content="HelloWood"><meta property="og:title" content="gRPC Stream"><meta property="og:description" content="gRPC Stream Stream 在 gRPC 中代表一个真正的请求，包含要发送的 消息；Stream 分为 ClientStream 和 ServerStream
ClientStream ClientStream 接口继承 Stream 接口，有多个实现类或抽象实现类：
ForwardingClientStream: 用于转发的 ClientStream，支持代理真正的流，可以用于触发一些动作，如统计等 NoopClientStream: 不做任何操作的 ClientStream，用于空实现 FailingClientStream: 用于失败的 ClientStream，处理请求失败的场景 InProcessClientStream: 进程内的 ClientStream，用于测试，不会发出实际请求 AbstractClientStream: ClientStream 的抽象实现类，实现了部分基础操作，如发送header，写入消息，半关闭等 NettyClientStream: 基于 Netty 实现的 ClientStream，实现了基于 Netty 的帧操作等 OkHttpClientStream: 基于 OkHttp 实现的 ClientStream，实现了基于 OkHttp 的帧操作等 方法 start 开始一个新的流，对于每一个流，只能调用一次
void start(ClientStreamListener listener); halfClose 从客户端关闭流，当关闭后，不能发送更多的消息，但是可以接收消息，只能调用一次
void halfClose(); cancel 异常终止流，当调用后不会再发送和接收消息，只有在 start 之后才可以被调用
void cancel(Status reason); setDeadline 设置请求有效截止时间，过了这个时间之后就会终止请求执行
void setDeadline(@Nonnull Deadline deadline); getAttributes 获取流的属性"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-11-08T22:34:46+00:00"><meta property="article:modified_time" content="2020-11-08T22:34:46+00:00"><meta property="article:tag" content="GRPC"><meta name=twitter:card content="summary"><meta name=twitter:title content="gRPC Stream"><meta name=twitter:description content="gRPC Stream Stream 在 gRPC 中代表一个真正的请求，包含要发送的 消息；Stream 分为 ClientStream 和 ServerStream
ClientStream ClientStream 接口继承 Stream 接口，有多个实现类或抽象实现类：
ForwardingClientStream: 用于转发的 ClientStream，支持代理真正的流，可以用于触发一些动作，如统计等 NoopClientStream: 不做任何操作的 ClientStream，用于空实现 FailingClientStream: 用于失败的 ClientStream，处理请求失败的场景 InProcessClientStream: 进程内的 ClientStream，用于测试，不会发出实际请求 AbstractClientStream: ClientStream 的抽象实现类，实现了部分基础操作，如发送header，写入消息，半关闭等 NettyClientStream: 基于 Netty 实现的 ClientStream，实现了基于 Netty 的帧操作等 OkHttpClientStream: 基于 OkHttp 实现的 ClientStream，实现了基于 OkHttp 的帧操作等 方法 start 开始一个新的流，对于每一个流，只能调用一次
void start(ClientStreamListener listener); halfClose 从客户端关闭流，当关闭后，不能发送更多的消息，但是可以接收消息，只能调用一次
void halfClose(); cancel 异常终止流，当调用后不会再发送和接收消息，只有在 start 之后才可以被调用
void cancel(Status reason); setDeadline 设置请求有效截止时间，过了这个时间之后就会终止请求执行
void setDeadline(@Nonnull Deadline deadline); getAttributes 获取流的属性"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.hellowood.dev/posts/"},{"@type":"ListItem","position":2,"name":"gRPC Stream","item":"https://blog.hellowood.dev/posts/grpc-stream/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"gRPC Stream","name":"gRPC Stream","description":"gRPC Stream Stream 在 gRPC 中代表一个真正的请求，包含要发送的 消息；Stream 分为 ClientStream 和 ServerStream\nClientStream ClientStream 接口继承 Stream 接口，有多个实现类或抽象实现类：\nForwardingClientStream: 用于转发的 ClientStream，支持代理真正的流，可以用于触发一些动作，如统计等 NoopClientStream: 不做任何操作的 ClientStream，用于空实现 FailingClientStream: 用于失败的 ClientStream，处理请求失败的场景 InProcessClientStream: 进程内的 ClientStream，用于测试，不会发出实际请求 AbstractClientStream: ClientStream 的抽象实现类，实现了部分基础操作，如发送header，写入消息，半关闭等 NettyClientStream: 基于 Netty 实现的 ClientStream，实现了基于 Netty 的帧操作等 OkHttpClientStream: 基于 OkHttp 实现的 ClientStream，实现了基于 OkHttp 的帧操作等 方法 start 开始一个新的流，对于每一个流，只能调用一次\nvoid start(ClientStreamListener listener); halfClose 从客户端关闭流，当关闭后，不能发送更多的消息，但是可以接收消息，只能调用一次\nvoid halfClose(); cancel 异常终止流，当调用后不会再发送和接收消息，只有在 start 之后才可以被调用\nvoid cancel(Status reason); setDeadline 设置请求有效截止时间，过了这个时间之后就会终止请求执行\nvoid setDeadline(@Nonnull Deadline deadline); getAttributes 获取流的属性","keywords":["gRPC"],"articleBody":"gRPC Stream Stream 在 gRPC 中代表一个真正的请求，包含要发送的 消息；Stream 分为 ClientStream 和 ServerStream\nClientStream ClientStream 接口继承 Stream 接口，有多个实现类或抽象实现类：\nForwardingClientStream: 用于转发的 ClientStream，支持代理真正的流，可以用于触发一些动作，如统计等 NoopClientStream: 不做任何操作的 ClientStream，用于空实现 FailingClientStream: 用于失败的 ClientStream，处理请求失败的场景 InProcessClientStream: 进程内的 ClientStream，用于测试，不会发出实际请求 AbstractClientStream: ClientStream 的抽象实现类，实现了部分基础操作，如发送header，写入消息，半关闭等 NettyClientStream: 基于 Netty 实现的 ClientStream，实现了基于 Netty 的帧操作等 OkHttpClientStream: 基于 OkHttp 实现的 ClientStream，实现了基于 OkHttp 的帧操作等 方法 start 开始一个新的流，对于每一个流，只能调用一次\nvoid start(ClientStreamListener listener); halfClose 从客户端关闭流，当关闭后，不能发送更多的消息，但是可以接收消息，只能调用一次\nvoid halfClose(); cancel 异常终止流，当调用后不会再发送和接收消息，只有在 start 之后才可以被调用\nvoid cancel(Status reason); setDeadline 设置请求有效截止时间，过了这个时间之后就会终止请求执行\nvoid setDeadline(@Nonnull Deadline deadline); getAttributes 获取流的属性\nAttributes getAttributes(); 监听器 ClientStreamListener 用于监听客户端流的事件\nonReady 当接收得此事件说明 Transport 已经准备好发送附加消息了\nvoid onReady(); messagesAvailable 当远程端点接收到消息时调用\nvoid messagesAvailable(MessageProducer producer); headersRead 当收到服务端返回的 header 时调用，如果没有 header 返回，则这个方法不会被调用\nvoid headersRead(Metadata headers); closed 当流被关闭时调用\nvoid closed(Status status, Metadata trailers); void closed(Status status, RpcProgress rpcProgress, Metadata trailers); ClientStream 流程 发起请求 生成的代码中通过 blockingUnaryCall 开始发起请求\nio.grpc.stub.ClientCalls#blockingUnaryCall public static \u003cReqT, RespT\u003e RespT blockingUnaryCall(Channel channel, MethodDescriptor\u003cReqT, RespT\u003e method, CallOptions callOptions, ReqT req) { // 构建任务队列和单线程的线程池 ThreadlessExecutor executor = new ThreadlessExecutor(); boolean interrupt = false; // 创建新的调用的 ClientCall，指定了调用类型和执行器 ClientCall\u003cReqT, RespT\u003e call = channel.newCall(method, callOptions.withOption(ClientCalls.STUB_TYPE_OPTION, StubType.BLOCKING) .withExecutor(executor)); try { // 执行调用，发出请求 ListenableFuture\u003cRespT\u003e responseFuture = futureUnaryCall(call, req); while (!responseFuture.isDone()) { try { executor.waitAndDrain(); } catch (InterruptedException e) { interrupt = true; call.cancel(\"Thread interrupted\", e); } } return getUnchecked(responseFuture); } catch (RuntimeException e) { throw cancelThrow(call, e); } catch (Error e) { throw cancelThrow(call, e); } finally { if (interrupt) { Thread.currentThread().interrupt(); } } } 创建 ClientCall 后调用 futureUnaryCall 开始发起请求，并返回用于获取结果的 ListenableFuture\npublic static \u003cReqT, RespT\u003e ListenableFuture\u003cRespT\u003e futureUnaryCall(ClientCall\u003cReqT, RespT\u003e call, ReqT req) { // 初始化 GrpcFuture GrpcFuture\u003cRespT\u003e responseFuture = new GrpcFuture\u003c\u003e(call); // 将 GrpcFuture 包装为继承了 Listener 的 UnaryStreamToFuture，提交任务 asyncUnaryRequestCall(call, req, new UnaryStreamToFuture\u003c\u003e(responseFuture)); return responseFuture; } io.grpc.stub.ClientCalls#asyncUnaryRequestCall private static \u003cReqT, RespT\u003e void asyncUnaryRequestCall(ClientCall\u003cReqT, RespT\u003e call, ReqT req, StartableListener\u003cRespT\u003e responseListener) { // 开始调用 startCall(call, responseListener); try { // 发送消息，提交 BufferEntry 任务 call.sendMessage(req); // 从客户端关闭流 call.halfClose(); } catch (RuntimeException e) { throw cancelThrow(call, e); } catch (Error e) { throw cancelThrow(call, e); } } 创建 ClientStream 当调用了 io.grpc.internal.ClientCallImpl#start 方法后，会创建客户端流； 如果已经过了超时时间，则会使用 DEADLINE_EXECEEDED 状态创建 FailingClientStream；如果还为超时，则根据是否开启了重试创建相应的流\nio.grpc.internal.ClientCallImpl#startInternal // 最后期限 Deadline effectiveDeadline = effectiveDeadline(); boolean deadlineExceeded = effectiveDeadline != null \u0026\u0026 effectiveDeadline.isExpired(); // 如果没有过期 if (!deadlineExceeded) { // 如果打开了重试，则创建重试流 if (retryEnabled) { stream = clientTransportProvider.newRetriableStream(method, callOptions, headers, context); } else { // 根据获取 ClientTransport ClientTransport transport = clientTransportProvider.get(new PickSubchannelArgsImpl(method, headers, callOptions)); // 创建流 stream = transport.newStream(method, headers, callOptions); } } else { // 初始化超时失败的流 stream = new FailingClientStream(DEADLINE_EXCEEDED.withDescription(\"ClientCall started after deadline exceeded: \" + effectiveDeadline)); } 然后根据不同的实现，在 Transport 内创建流\nio.grpc.netty.NettyClientTransport#newStream public ClientStream newStream(MethodDescriptor\u003c?, ?\u003e method, Metadata headers, CallOptions callOptions) { // 如果 channel 是空的，则返回失败的 ClientStream if (channel == null) { return new FailingClientStream(statusExplainingWhyTheChannelIsNull); } StatsTraceContext statsTraceCtx = StatsTraceContext.newClientContext(callOptions, getAttributes(), headers); // 创建 NettyClientStream return new NettyClientStream(/**/); } 开始流 开始流，并指定监听器\nio.grpc.internal.AbstractClientStream#start public final void start(ClientStreamListener listener) { transportState().setListener(listener); // 如果不是 GET 请求，则发送 Header if (!useGet) { abstractClientStreamSink().writeHeaders(headers, null); headers = null; } } 如果不是 GET 方法的请求，要先写入 Header\nio.grpc.netty.shaded.io.grpc.netty.NettyClientStream.Sink#writeHeaders 最终是通过创建 Netty 的指令，将 header 发送给服务端\nprivate void writeHeadersInternal(Metadata headers, byte[] requestPayload) { // 将 Header 转为 Netty 的 HTTP2 的 header // 根据方法名获取路径 AsciiString defaultPath = (AsciiString) methodDescriptorAccessor.geRawMethodName(method); // 如果路径为 null，则设置路径为方法全名 if (defaultPath == null) { defaultPath = new AsciiString(\"/\" + method.getFullMethodName()); methodDescriptorAccessor.setRawMethodName(method, defaultPath); } // 如果有 payload，则使用 GET 方法 boolean get = (requestPayload != null); AsciiString httpMethod; // 如果是 GET 方法，则将负载加到请求路径中，并设置请求方法 if (get) { // 将负载通过 base64 编码后添加到请求路径中 defaultPath = new AsciiString(defaultPath + \"?\" + BaseEncoding.base64().encode(requestPayload)); httpMethod = Utils.HTTP_GET_METHOD; } else { httpMethod = Utils.HTTP_METHOD; } // 将 Header 转为 Netty 的 HTTP2 header Http2Headers http2Headers = Utils.convertClientHeaders(headers, scheme, defaultPath, authority, httpMethod, userAgent); // 创建 ChannelFuture 的监听器 ChannelFutureListener failureListener = new ChannelFutureListener() { @Override public void operationComplete(ChannelFuture future) throws Exception { // 如果 Future 状态不是成功的 if (!future.isSuccess()) { // 流创建失败时，如果流没有关闭，则关闭流；当 Channel 关闭时， Lifecycle Manager 更了解失败， // 尤其是在判断完成之前 // 获取关闭状态 Status s = transportState().handler.getLifecycleManager().getShutdownStatus(); // 如果关闭状态是 null，则从失败的 Future 中获取失败状态 if (s == null) { s = transportState().statusFromFailedFuture(future); } // 上报 Transport 的状态 transportState().transportReportStatus(s, true, new Metadata()); } } }; // Write the command requesting the creation of the stream. // 写入创建流的请求的指令，并添加失败的 Future 监听器 writeQueue.enqueue(new CreateStreamCommand(http2Headers, transportState(), shouldBeCountedForInUse(), get), !method.getType().clientSendsOneMessage() || get) .addListener(failureListener); } 发起请求 当在 io.grpc.stub.ClientCalls#startCall中调用了responseListener.onStart()后，会开始发送请求\nio.grpc.stub.ClientCalls.UnaryStreamToFuture#onStart void onStart() { responseFuture.call.request(2); } io.grpc.internal.ClientCallImpl#request public void request(int numMessages) { stream.request(numMessages); } io.grpc.internal.AbstractStream#request public final void request(int numMessages) { transportState().requestMessagesFromDeframer(numMessages); } 然后通过 Deframer 发送\nio.grpc.internal.AbstractStream.TransportState#requestMessagesFromDeframer private void requestMessagesFromDeframer(final int numMessages) { // 如果是线程安全的解帧器，则直接执行 if (deframer instanceof ThreadOptimizedDeframer) { // 发送指定数量的消息 deframer.request(numMessages); return; } // 如果不是线程安全的解帧器，则由 Transport 的线程执行 class RequestRunnable implements Runnable { @Override public void run() { try { deframer.request(numMessages); } catch (Throwable t) { deframeFailed(t); } } } runOnTransportThread(new RequestRunnable()); } 发送消息 io.grpc.internal.ClientCallImpl#sendMessageInternal 判断是否是可重试的流，如果是，则使用可重试的流发送消息，如果不是，则使用普通的流发送消息\nprivate void sendMessageInternal(ReqT message) { try { // 如果是重试流，则通过重试流的方法发送消息 if (stream instanceof RetriableStream) { RetriableStream\u003cReqT\u003e retriableStream = (RetriableStream\u003cReqT\u003e) stream; retriableStream.sendMessage(message); } else { // 不是重试流，将消息转为流，发送 stream.writeMessage(method.streamRequest(message)); } } catch (RuntimeException e) { // 如果出错则取消请求 stream.cancel(Status.CANCELLED.withCause(e).withDescription(\"Failed to stream message\")); return; } catch (Error e) { stream.cancel(Status.CANCELLED.withDescription(\"Client sendMessage() failed with Error\")); throw e; } // 对于 unary 请求，不用flush，因为接下来就是 halfClose, 这样就可以在消息最后搭载 END_STREAM=true， // 而无需打开损坏的流 if (!unaryRequest) { stream.flush(); } } io.grpc.internal.AbstractStream#writeMessage 将消息内容转为流后，最终通过将消息传递给 Framer\npublic final void writeMessage(InputStream message) { try { if (!framer().isClosed()) { // 写入消息体 framer().writePayload(message); } } finally { GrpcUtil.closeQuietly(message); } } io.grpc.internal.AbstractClientStream#deliverFrame 将 Framer 的内容传递给 Transport\npublic final void deliverFrame(WritableBuffer frame, boolean endOfStream, boolean flush, int numMessages) { Preconditions.checkArgument(frame != null || endOfStream, \"null frame before EOS\"); // 通过 netty 写入 abstractClientStreamSink().writeFrame(frame, endOfStream, flush, numMessages); } io.grpc.netty.NettyClientStream.Sink#writeFrameInternal 最终通过 Netty 的指令，将消息内容发送给服务端\nprivate void writeFrameInternal(WritableBuffer frame, boolean endOfStream, boolean flush, final int numMessages) { // 将 frame 转换为 ByteBuf ByteBuf bytebuf = frame == null ? EMPTY_BUFFER : ((NettyWritableBuffer) frame).bytebuf().touch(); // 统计 ByteBuf 的可读字节数 final int numBytes = bytebuf.readableBytes(); // 如果字节数大于 0 if (numBytes \u003e 0) { // 将要出站的字节数添加到流控中 onSendingBytes(numBytes); // 将发送 gRPC 帧命令添加到写队列中 writeQueue.enqueue(new SendGrpcFrameCommand(transportState(), bytebuf, endOfStream), flush) .addListener(new ChannelFutureListener() { @Override public void operationComplete(ChannelFuture future) throws Exception { // 如果 future 成功，且 Transport 中的流不为 null if (future.isSuccess() \u0026\u0026 transportState().http2Stream() != null) { // 添加发送的字节数及统计 transportState().onSentBytes(numBytes); NettyClientStream.this.getTransportTracer().reportMessageSent(numMessages); } } }); } else { // 如果发送的字节为空，则不会影响流控，仅仅发送 writeQueue.enqueue(new SendGrpcFrameCommand(transportState(), bytebuf, endOfStream), flush); } } 半关闭 io.grpc.internal.AbstractClientStream#halfClose 从客户端关闭流，关闭后客户端不能再发送消息，但是可以接收\npublic final void halfClose() { if (!transportState().isOutboundClosed()) { transportState().setOutboundClosed(); // 输出已经到达消息结尾 endOfMessages(); } } io.grpc.internal.AbstractStream#endOfMessages protected final void endOfMessages() { framer().close(); } io.grpc.internal.MessageFramer#close 调用 Framer，释放缓冲区， 提交流；最终还是通过 Netty，将关闭流的帧写入，发送给服务端\npublic void close() { if (!isClosed()) { closed = true; // With the current code we don't expect readableBytes \u003e 0 to be possible here, added // defensively to prevent buffer leak issues if the framer code changes later. if (buffer != null \u0026\u0026 buffer.readableBytes() == 0) { releaseBuffer(); } commitToSink(true, true); } } 获取返回结果 在 io.grpc.stub.ClientCalls#blockingUnaryCall 方法中，调用完 futureUnaryCall 方法后，会返回 ListenableFuture用于监听返回结果\nio.grpc.stub.ClientCalls#blockingUnaryCall 会不断的循环，监听线程池返回的结果\nListenableFuture\u003cRespT\u003e responseFuture = futureUnaryCall(call, req); while (!responseFuture.isDone()) { try { executor.waitAndDrain(); } catch (InterruptedException e) { interrupt = true; call.cancel(\"Thread interrupted\", e); } } return getUnchecked(responseFuture); 当 Server 端返回响应内容时，会调用监听器的 messagesAvailable 方法，从响应的流中解析响应内容\nio.grpc.internal.ClientCallImpl.ClientStreamListenerImpl#messagesAvailable try { InputStream message; while ((message = producer.next()) != null) { try { // 将消息流解析为响应对象，并传递给 Future observer.onMessage(method.parseResponse(message)); } catch (Throwable t) { GrpcUtil.closeQuietly(message); throw t; } message.close(); } } catch (Throwable t) { GrpcUtil.closeQuietly(producer); Status status = Status.CANCELLED.withCause(t).withDescription(\"Failed to read message.\"); stream.cancel(status); close(status, new Metadata()); } io.grpc.stub.ClientCalls.UnaryStreamToFuture#onMessage 为 Future 对象设置值\npublic void onMessage(RespT value) { if (this.value != null) { throw Status.INTERNAL.withDescription(\"More than one value received for unary call\") .asRuntimeException(); } this.value = value; } io.grpc.stub.ClientCalls#getUnchecked 返回 Future 的值\nprivate static \u003cV\u003e V getUnchecked(Future\u003cV\u003e future) { try { return future.get(); } catch (InterruptedException e) { Thread.currentThread().interrupt(); throw Status.CANCELLED .withDescription(\"Thread interrupted\") .withCause(e) .asRuntimeException(); } catch (ExecutionException e) { throw toStatusRuntimeException(e.getCause()); } } ","wordCount":"1183","inLanguage":"en","datePublished":"2020-11-08T22:34:46Z","dateModified":"2020-11-08T22:34:46Z","author":{"@type":"Person","name":"HelloWood"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.hellowood.dev/posts/grpc-stream/"},"publisher":{"@type":"Organization","name":"HelloWood","logo":{"@type":"ImageObject","url":"https://blog.hellowood.dev/favicon.ico"}}}</script><link rel=icon href=/images/avatar.png sizes=16x16><link rel=apple-touch-icon href=/images/avatar.png><link rel=manifest href=/images/avatar.png><link rel=stylesheet href=https://cdn.staticfile.org/lxgw-wenkai-webfont/1.6.0/style.css><link rel=stylesheet href=/css/main.min.ff1bc260fafbfb440e10194d7d06d57eb5e85eed11d12d06255581262664204e.css integrity="sha256-/xvCYPr7+0QOEBlNfQbVfrXoXu0R0S0GJVWBJiZkIE4=" crossorigin=anonymous media=screen><link rel=stylesheet href=/scss/highlight/github-dark.min.min.66034289ee9a113219a2c4aae0a8bd2095ab255c832a42efcf5863f10814e7a1.css><script src=/js/highlight.min.min.c607d6febd16934a82eb61d3a896ed9d869f54373cc63ce95864ed5488fe3128.js></script><script>hljs.highlightAll()</script><script>(()=>{var t=window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches,e=localStorage.getItem("theme");t&&e===null&&(localStorage.setItem("theme","dark"),document.documentElement.setAttribute("data-dark-mode","")),t&&e==="dark"&&document.documentElement.setAttribute("data-dark-mode",""),e==="dark"&&document.documentElement.setAttribute("data-dark-mode","")})()</script><meta name=google-adsense-account content="ca-pub-3401351766168985"><script type=text/javascript>(function(e,t,n,s,o,i,a){e[n]=e[n]||function(){(e[n].q=e[n].q||[]).push(arguments)},i=t.createElement(s),i.async=1,i.src="https://www.clarity.ms/tag/"+o,a=t.getElementsByTagName(s)[0],a.parentNode.insertBefore(i,a)})(window,document,"clarity","script","jtbhx98g62")</script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3401351766168985" crossorigin=anonymous></script><script defer src=https://analytics.us.umami.is/script.js data-website-id=73ff1c8c-9938-43cf-81af-e77e26b0cca3></script></head><body><main class=wrapper><nav class=navigation><section class=container><a class=navigation-brand data-umami-event=navigation-brand href=/>HOME
</a><input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><span></span><span></span><span></span></label><ul class=navigation-list id=navigation-list><li class="navigation-item navigation-menu"><a class=navigation-link data-umami-event=Blog href=/posts>Blog</a></li><li class="navigation-item navigation-menu"><a class=navigation-link data-umami-event=Tags href=/tags>Tags</a></li><li class="navigation-item navigation-menu"><a class=navigation-link data-umami-event=Archive href=/archives>Archive</a></li><li class="navigation-item navigation-menu"><a class=navigation-link data-umami-event=Dashboard href=https://umami.hellowood.dev/share/lab/Blog>Dashboard</a></li><li class="navigation-item menu-separator"><span>|</span></li><li class="navigation-item navigation-social"><a class=navigation-link data-umami-event=navigation-social href=https://github.com/helloworlde><svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a></li><li class="navigation-item navigation-dark"><button id=mode type=button data-umami-event=toggle-theme aria-label="toggle user light or dark theme">
<span class=toggle-dark><svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-moon"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg></span>
<span class=toggle-light><svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-sun"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></span></button></li></ul></section></nav><div id=content><article class=blog-single><header class=blog-title><h1>gRPC Stream</h1></header><p><small>November 8, 2020&nbsp;· 1183 words&nbsp;· 6 min</small><p><div class=blog-toc><nav id=TableOfContents><ul><li><a href=#clientstream>ClientStream</a><ul><li><a href=#方法>方法</a></li><li><a href=#监听器>监听器</a></li><li><a href=#clientstream-流程>ClientStream 流程</a></li></ul></li></ul></nav></div><section class=blog-content><h1 id=grpc-stream>gRPC Stream</h1><p>Stream 在 gRPC 中代表一个真正的请求，包含要发送的 消息；Stream 分为 <code>ClientStream</code> 和 <code>ServerStream</code></p><p><img alt=grpc-source-code-stream-diagram.png src=https://img.hellowood.dev/picture/grpc-source-code-stream-diagram.png></p><h2 id=clientstream>ClientStream</h2><p><code>ClientStream</code> 接口继承 Stream 接口，有多个实现类或抽象实现类：</p><ul><li><code>ForwardingClientStream</code>: 用于转发的 <code>ClientStream</code>，支持代理真正的流，可以用于触发一些动作，如统计等</li><li><code>NoopClientStream</code>: 不做任何操作的 <code>ClientStream</code>，用于空实现<ul><li><code>FailingClientStream</code>: 用于失败的 <code>ClientStream</code>，处理请求失败的场景</li></ul></li><li><code>InProcessClientStream</code>: 进程内的 <code>ClientStream</code>，用于测试，不会发出实际请求</li><li><code>AbstractClientStream</code>: <code>ClientStream</code> 的抽象实现类，实现了部分基础操作，如发送header，写入消息，半关闭等<ul><li><code>NettyClientStream</code>: 基于 Netty 实现的 <code>ClientStream</code>，实现了基于 Netty 的帧操作等</li><li><code>OkHttpClientStream</code>: 基于 OkHttp 实现的 <code>ClientStream</code>，实现了基于 OkHttp 的帧操作等</li></ul></li></ul><h3 id=方法>方法</h3><ul><li>start</li></ul><p>开始一个新的流，对于每一个流，只能调用一次</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>start</span>(ClientStreamListener listener);
</span></span></code></pre></div><ul><li>halfClose</li></ul><p>从客户端关闭流，当关闭后，不能发送更多的消息，但是可以接收消息，只能调用一次</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>halfClose</span>();
</span></span></code></pre></div><ul><li>cancel</li></ul><p>异常终止流，当调用后不会再发送和接收消息，只有在 start 之后才可以被调用</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>cancel</span>(Status reason);
</span></span></code></pre></div><ul><li>setDeadline</li></ul><p>设置请求有效截止时间，过了这个时间之后就会终止请求执行</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>setDeadline</span>(<span style=color:#a6e22e>@Nonnull</span> Deadline deadline);
</span></span></code></pre></div><ul><li>getAttributes</li></ul><p>获取流的属性</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>Attributes <span style=color:#a6e22e>getAttributes</span>();
</span></span></code></pre></div><h3 id=监听器>监听器</h3><p>ClientStreamListener 用于监听客户端流的事件</p><ul><li>onReady</li></ul><p>当接收得此事件说明 Transport 已经准备好发送附加消息了</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>onReady</span>();
</span></span></code></pre></div><ul><li>messagesAvailable</li></ul><p>当远程端点接收到消息时调用</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>messagesAvailable</span>(MessageProducer producer);
</span></span></code></pre></div><ul><li>headersRead</li></ul><p>当收到服务端返回的 header 时调用，如果没有 header 返回，则这个方法不会被调用</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>headersRead</span>(Metadata headers);
</span></span></code></pre></div><ul><li>closed</li></ul><p>当流被关闭时调用</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>closed</span>(Status status, Metadata trailers);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>closed</span>(Status status, RpcProgress rpcProgress, Metadata trailers);
</span></span></code></pre></div><h3 id=clientstream-流程>ClientStream 流程</h3><h4 id=发起请求>发起请求</h4><p>生成的代码中通过 <code>blockingUnaryCall</code> 开始发起请求</p><ul><li>io.grpc.stub.ClientCalls#blockingUnaryCall</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#f92672>&lt;</span>ReqT, RespT<span style=color:#f92672>&gt;</span> RespT <span style=color:#a6e22e>blockingUnaryCall</span>(Channel channel,
</span></span><span style=display:flex><span>                                                    MethodDescriptor<span style=color:#f92672>&lt;</span>ReqT, RespT<span style=color:#f92672>&gt;</span> method,
</span></span><span style=display:flex><span>                                                    CallOptions callOptions,
</span></span><span style=display:flex><span>                                                    ReqT req) {
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 构建任务队列和单线程的线程池</span>
</span></span><span style=display:flex><span>  ThreadlessExecutor executor <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ThreadlessExecutor();
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>boolean</span> interrupt <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 创建新的调用的 ClientCall，指定了调用类型和执行器</span>
</span></span><span style=display:flex><span>  ClientCall<span style=color:#f92672>&lt;</span>ReqT, RespT<span style=color:#f92672>&gt;</span> call <span style=color:#f92672>=</span> channel.<span style=color:#a6e22e>newCall</span>(method, callOptions.<span style=color:#a6e22e>withOption</span>(ClientCalls.<span style=color:#a6e22e>STUB_TYPE_OPTION</span>, StubType.<span style=color:#a6e22e>BLOCKING</span>)
</span></span><span style=display:flex><span>                                                                    .<span style=color:#a6e22e>withExecutor</span>(executor));
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 执行调用，发出请求</span>
</span></span><span style=display:flex><span>    ListenableFuture<span style=color:#f92672>&lt;</span>RespT<span style=color:#f92672>&gt;</span> responseFuture <span style=color:#f92672>=</span> futureUnaryCall(call, req);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> (<span style=color:#f92672>!</span>responseFuture.<span style=color:#a6e22e>isDone</span>()) {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>        executor.<span style=color:#a6e22e>waitAndDrain</span>();
</span></span><span style=display:flex><span>      } <span style=color:#66d9ef>catch</span> (InterruptedException e) {
</span></span><span style=display:flex><span>        interrupt <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>        call.<span style=color:#a6e22e>cancel</span>(<span style=color:#e6db74>&#34;Thread interrupted&#34;</span>, e);
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> getUnchecked(responseFuture);
</span></span><span style=display:flex><span>  } <span style=color:#66d9ef>catch</span> (RuntimeException e) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>throw</span> cancelThrow(call, e);
</span></span><span style=display:flex><span>  } <span style=color:#66d9ef>catch</span> (Error e) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>throw</span> cancelThrow(call, e);
</span></span><span style=display:flex><span>  } <span style=color:#66d9ef>finally</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (interrupt) {
</span></span><span style=display:flex><span>      Thread.<span style=color:#a6e22e>currentThread</span>().<span style=color:#a6e22e>interrupt</span>();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>创建 ClientCall 后调用 <code>futureUnaryCall</code> 开始发起请求，并返回用于获取结果的 <code>ListenableFuture</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#f92672>&lt;</span>ReqT, RespT<span style=color:#f92672>&gt;</span> ListenableFuture<span style=color:#f92672>&lt;</span>RespT<span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>futureUnaryCall</span>(ClientCall<span style=color:#f92672>&lt;</span>ReqT, RespT<span style=color:#f92672>&gt;</span> call, ReqT req) {
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 初始化 GrpcFuture</span>
</span></span><span style=display:flex><span>  GrpcFuture<span style=color:#f92672>&lt;</span>RespT<span style=color:#f92672>&gt;</span> responseFuture <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> GrpcFuture<span style=color:#f92672>&lt;&gt;</span>(call);
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 将 GrpcFuture 包装为继承了 Listener 的 UnaryStreamToFuture，提交任务</span>
</span></span><span style=display:flex><span>  asyncUnaryRequestCall(call, req, <span style=color:#66d9ef>new</span> UnaryStreamToFuture<span style=color:#f92672>&lt;&gt;</span>(responseFuture));
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> responseFuture;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>io.grpc.stub.ClientCalls#asyncUnaryRequestCall</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#f92672>&lt;</span>ReqT, RespT<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>asyncUnaryRequestCall</span>(ClientCall<span style=color:#f92672>&lt;</span>ReqT, RespT<span style=color:#f92672>&gt;</span> call,
</span></span><span style=display:flex><span>                                                        ReqT req,
</span></span><span style=display:flex><span>                                                        StartableListener<span style=color:#f92672>&lt;</span>RespT<span style=color:#f92672>&gt;</span> responseListener) {
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 开始调用</span>
</span></span><span style=display:flex><span>  startCall(call, responseListener);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 发送消息，提交 BufferEntry 任务</span>
</span></span><span style=display:flex><span>    call.<span style=color:#a6e22e>sendMessage</span>(req);
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 从客户端关闭流</span>
</span></span><span style=display:flex><span>    call.<span style=color:#a6e22e>halfClose</span>();
</span></span><span style=display:flex><span>  } <span style=color:#66d9ef>catch</span> (RuntimeException e) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>throw</span> cancelThrow(call, e);
</span></span><span style=display:flex><span>  } <span style=color:#66d9ef>catch</span> (Error e) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>throw</span> cancelThrow(call, e);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=创建-clientstream>创建 ClientStream</h4><p>当调用了 <code>io.grpc.internal.ClientCallImpl#start</code> 方法后，会创建客户端流；
如果已经过了超时时间，则会使用 <code>DEADLINE_EXECEEDED</code> 状态创建 <code>FailingClientStream</code>；如果还为超时，则根据是否开启了重试创建相应的流</p><ul><li>io.grpc.internal.ClientCallImpl#startInternal</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// 最后期限</span>
</span></span><span style=display:flex><span>Deadline effectiveDeadline <span style=color:#f92672>=</span> effectiveDeadline();
</span></span><span style=display:flex><span><span style=color:#66d9ef>boolean</span> deadlineExceeded <span style=color:#f92672>=</span> effectiveDeadline <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span> <span style=color:#f92672>&amp;&amp;</span> effectiveDeadline.<span style=color:#a6e22e>isExpired</span>();
</span></span><span style=display:flex><span><span style=color:#75715e>// 如果没有过期</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>deadlineExceeded) {
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 如果打开了重试，则创建重试流</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (retryEnabled) {
</span></span><span style=display:flex><span>    stream <span style=color:#f92672>=</span> clientTransportProvider.<span style=color:#a6e22e>newRetriableStream</span>(method, callOptions, headers, context);
</span></span><span style=display:flex><span>  } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 根据获取 ClientTransport</span>
</span></span><span style=display:flex><span>    ClientTransport transport <span style=color:#f92672>=</span> clientTransportProvider.<span style=color:#a6e22e>get</span>(<span style=color:#66d9ef>new</span> PickSubchannelArgsImpl(method, headers, callOptions));
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 创建流</span>
</span></span><span style=display:flex><span>    stream <span style=color:#f92672>=</span> transport.<span style=color:#a6e22e>newStream</span>(method, headers, callOptions);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>} <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 初始化超时失败的流</span>
</span></span><span style=display:flex><span>  stream <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> FailingClientStream(DEADLINE_EXCEEDED.<span style=color:#a6e22e>withDescription</span>(<span style=color:#e6db74>&#34;ClientCall started after deadline exceeded: &#34;</span> <span style=color:#f92672>+</span> effectiveDeadline));
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>然后根据不同的实现，在 Transport 内创建流</p><ul><li>io.grpc.netty.NettyClientTransport#newStream</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> ClientStream <span style=color:#a6e22e>newStream</span>(MethodDescriptor<span style=color:#f92672>&lt;?</span>, <span style=color:#f92672>?&gt;</span> method,
</span></span><span style=display:flex><span>                              Metadata headers,
</span></span><span style=display:flex><span>                              CallOptions callOptions) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 如果 channel 是空的，则返回失败的 ClientStream</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (channel <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> FailingClientStream(statusExplainingWhyTheChannelIsNull);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    StatsTraceContext statsTraceCtx <span style=color:#f92672>=</span> StatsTraceContext.<span style=color:#a6e22e>newClientContext</span>(callOptions, getAttributes(), headers);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 创建 NettyClientStream</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> NettyClientStream(<span style=color:#75715e>/**/</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=开始流>开始流</h4><p>开始流，并指定监听器</p><ul><li>io.grpc.internal.AbstractClientStream#start</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>start</span>(ClientStreamListener listener) {
</span></span><span style=display:flex><span>    transportState().<span style=color:#a6e22e>setListener</span>(listener);
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 如果不是 GET 请求，则发送 Header</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>useGet) {
</span></span><span style=display:flex><span>        abstractClientStreamSink().<span style=color:#a6e22e>writeHeaders</span>(headers, <span style=color:#66d9ef>null</span>);
</span></span><span style=display:flex><span>        headers <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>如果不是 GET 方法的请求，要先写入 Header</p><ul><li>io.grpc.netty.shaded.io.grpc.netty.NettyClientStream.Sink#writeHeaders</li></ul><p>最终是通过创建 Netty 的指令，将 header 发送给服务端</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>writeHeadersInternal</span>(Metadata headers, <span style=color:#66d9ef>byte</span><span style=color:#f92672>[]</span> requestPayload) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 将 Header 转为 Netty 的 HTTP2 的 header</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 根据方法名获取路径</span>
</span></span><span style=display:flex><span>    AsciiString defaultPath <span style=color:#f92672>=</span> (AsciiString) methodDescriptorAccessor.<span style=color:#a6e22e>geRawMethodName</span>(method);
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 如果路径为 null，则设置路径为方法全名</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (defaultPath <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>        defaultPath <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> AsciiString(<span style=color:#e6db74>&#34;/&#34;</span> <span style=color:#f92672>+</span> method.<span style=color:#a6e22e>getFullMethodName</span>());
</span></span><span style=display:flex><span>        methodDescriptorAccessor.<span style=color:#a6e22e>setRawMethodName</span>(method, defaultPath);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 如果有 payload，则使用 GET 方法</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>boolean</span> get <span style=color:#f92672>=</span> (requestPayload <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>);
</span></span><span style=display:flex><span>    AsciiString httpMethod;
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 如果是 GET 方法，则将负载加到请求路径中，并设置请求方法</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (get) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 将负载通过 base64 编码后添加到请求路径中</span>
</span></span><span style=display:flex><span>        defaultPath <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> AsciiString(defaultPath <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;?&#34;</span> <span style=color:#f92672>+</span> BaseEncoding.<span style=color:#a6e22e>base64</span>().<span style=color:#a6e22e>encode</span>(requestPayload));
</span></span><span style=display:flex><span>        httpMethod <span style=color:#f92672>=</span> Utils.<span style=color:#a6e22e>HTTP_GET_METHOD</span>;
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        httpMethod <span style=color:#f92672>=</span> Utils.<span style=color:#a6e22e>HTTP_METHOD</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 将 Header 转为 Netty 的 HTTP2 header</span>
</span></span><span style=display:flex><span>    Http2Headers http2Headers <span style=color:#f92672>=</span> Utils.<span style=color:#a6e22e>convertClientHeaders</span>(headers, scheme, defaultPath, authority, httpMethod, userAgent);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 创建 ChannelFuture 的监听器</span>
</span></span><span style=display:flex><span>    ChannelFutureListener failureListener <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ChannelFutureListener() {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>operationComplete</span>(ChannelFuture future) <span style=color:#66d9ef>throws</span> Exception {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 如果 Future 状态不是成功的</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>future.<span style=color:#a6e22e>isSuccess</span>()) {
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 流创建失败时，如果流没有关闭，则关闭流；当 Channel 关闭时， Lifecycle Manager 更了解失败，</span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 尤其是在判断完成之前</span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 获取关闭状态</span>
</span></span><span style=display:flex><span>                Status s <span style=color:#f92672>=</span> transportState().<span style=color:#a6e22e>handler</span>.<span style=color:#a6e22e>getLifecycleManager</span>().<span style=color:#a6e22e>getShutdownStatus</span>();
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 如果关闭状态是 null，则从失败的 Future 中获取失败状态</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (s <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>                    s <span style=color:#f92672>=</span> transportState().<span style=color:#a6e22e>statusFromFailedFuture</span>(future);
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 上报 Transport 的状态</span>
</span></span><span style=display:flex><span>                transportState().<span style=color:#a6e22e>transportReportStatus</span>(s, <span style=color:#66d9ef>true</span>, <span style=color:#66d9ef>new</span> Metadata());
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Write the command requesting the creation of the stream.</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 写入创建流的请求的指令，并添加失败的 Future 监听器</span>
</span></span><span style=display:flex><span>    writeQueue.<span style=color:#a6e22e>enqueue</span>(<span style=color:#66d9ef>new</span> CreateStreamCommand(http2Headers, transportState(), shouldBeCountedForInUse(), get),
</span></span><span style=display:flex><span>            <span style=color:#f92672>!</span>method.<span style=color:#a6e22e>getType</span>().<span style=color:#a6e22e>clientSendsOneMessage</span>() <span style=color:#f92672>||</span> get)
</span></span><span style=display:flex><span>              .<span style=color:#a6e22e>addListener</span>(failureListener);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=发起请求-1>发起请求</h4><p>当在 <code>io.grpc.stub.ClientCalls#startCall</code>中调用了<code>responseListener.onStart()</code>后，会开始发送请求</p><ul><li>io.grpc.stub.ClientCalls.UnaryStreamToFuture#onStart</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>onStart</span>() {
</span></span><span style=display:flex><span>  responseFuture.<span style=color:#a6e22e>call</span>.<span style=color:#a6e22e>request</span>(2);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>io.grpc.internal.ClientCallImpl#request</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>request</span>(<span style=color:#66d9ef>int</span> numMessages) {
</span></span><span style=display:flex><span>    stream.<span style=color:#a6e22e>request</span>(numMessages);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>io.grpc.internal.AbstractStream#request</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>request</span>(<span style=color:#66d9ef>int</span> numMessages) {
</span></span><span style=display:flex><span>    transportState().<span style=color:#a6e22e>requestMessagesFromDeframer</span>(numMessages);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>然后通过 Deframer 发送</p><ul><li>io.grpc.internal.AbstractStream.TransportState#requestMessagesFromDeframer</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>requestMessagesFromDeframer</span>(<span style=color:#66d9ef>final</span> <span style=color:#66d9ef>int</span> numMessages) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 如果是线程安全的解帧器，则直接执行</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (deframer <span style=color:#66d9ef>instanceof</span> ThreadOptimizedDeframer) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 发送指定数量的消息</span>
</span></span><span style=display:flex><span>        deframer.<span style=color:#a6e22e>request</span>(numMessages);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 如果不是线程安全的解帧器，则由 Transport 的线程执行</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>RequestRunnable</span> <span style=color:#66d9ef>implements</span> Runnable {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>run</span>() {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>                deframer.<span style=color:#a6e22e>request</span>(numMessages);
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>catch</span> (Throwable t) {
</span></span><span style=display:flex><span>                deframeFailed(t);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    runOnTransportThread(<span style=color:#66d9ef>new</span> RequestRunnable());
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=发送消息>发送消息</h4><ul><li>io.grpc.internal.ClientCallImpl#sendMessageInternal</li></ul><p>判断是否是可重试的流，如果是，则使用可重试的流发送消息，如果不是，则使用普通的流发送消息</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>sendMessageInternal</span>(ReqT message) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 如果是重试流，则通过重试流的方法发送消息</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (stream <span style=color:#66d9ef>instanceof</span> RetriableStream) {
</span></span><span style=display:flex><span>      RetriableStream<span style=color:#f92672>&lt;</span>ReqT<span style=color:#f92672>&gt;</span> retriableStream <span style=color:#f92672>=</span> (RetriableStream<span style=color:#f92672>&lt;</span>ReqT<span style=color:#f92672>&gt;</span>) stream;
</span></span><span style=display:flex><span>      retriableStream.<span style=color:#a6e22e>sendMessage</span>(message);
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>      <span style=color:#75715e>// 不是重试流，将消息转为流，发送</span>
</span></span><span style=display:flex><span>      stream.<span style=color:#a6e22e>writeMessage</span>(method.<span style=color:#a6e22e>streamRequest</span>(message));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  } <span style=color:#66d9ef>catch</span> (RuntimeException e) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 如果出错则取消请求</span>
</span></span><span style=display:flex><span>    stream.<span style=color:#a6e22e>cancel</span>(Status.<span style=color:#a6e22e>CANCELLED</span>.<span style=color:#a6e22e>withCause</span>(e).<span style=color:#a6e22e>withDescription</span>(<span style=color:#e6db74>&#34;Failed to stream message&#34;</span>));
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>  } <span style=color:#66d9ef>catch</span> (Error e) {
</span></span><span style=display:flex><span>    stream.<span style=color:#a6e22e>cancel</span>(Status.<span style=color:#a6e22e>CANCELLED</span>.<span style=color:#a6e22e>withDescription</span>(<span style=color:#e6db74>&#34;Client sendMessage() failed with Error&#34;</span>));
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>throw</span> e;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 对于 unary 请求，不用flush，因为接下来就是 halfClose, 这样就可以在消息最后搭载 END_STREAM=true，</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 而无需打开损坏的流</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>unaryRequest) {
</span></span><span style=display:flex><span>    stream.<span style=color:#a6e22e>flush</span>();
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>io.grpc.internal.AbstractStream#writeMessage</li></ul><p>将消息内容转为流后，最终通过将消息传递给 Framer</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>writeMessage</span>(InputStream message) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>framer().<span style=color:#a6e22e>isClosed</span>()) {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 写入消息体</span>
</span></span><span style=display:flex><span>            framer().<span style=color:#a6e22e>writePayload</span>(message);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>finally</span> {
</span></span><span style=display:flex><span>        GrpcUtil.<span style=color:#a6e22e>closeQuietly</span>(message);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>io.grpc.internal.AbstractClientStream#deliverFrame</li></ul><p>将 Framer 的内容传递给 Transport</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>deliverFrame</span>(WritableBuffer frame,
</span></span><span style=display:flex><span>                               <span style=color:#66d9ef>boolean</span> endOfStream,
</span></span><span style=display:flex><span>                               <span style=color:#66d9ef>boolean</span> flush,
</span></span><span style=display:flex><span>                               <span style=color:#66d9ef>int</span> numMessages) {
</span></span><span style=display:flex><span>    Preconditions.<span style=color:#a6e22e>checkArgument</span>(frame <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span> <span style=color:#f92672>||</span> endOfStream, <span style=color:#e6db74>&#34;null frame before EOS&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 通过 netty 写入</span>
</span></span><span style=display:flex><span>    abstractClientStreamSink().<span style=color:#a6e22e>writeFrame</span>(frame, endOfStream, flush, numMessages);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>io.grpc.netty.NettyClientStream.Sink#writeFrameInternal</li></ul><p>最终通过 Netty 的指令，将消息内容发送给服务端</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>writeFrameInternal</span>(WritableBuffer frame, <span style=color:#66d9ef>boolean</span> endOfStream, <span style=color:#66d9ef>boolean</span> flush, <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>int</span> numMessages) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 将 frame 转换为 ByteBuf</span>
</span></span><span style=display:flex><span>    ByteBuf bytebuf <span style=color:#f92672>=</span> frame <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span> <span style=color:#f92672>?</span> EMPTY_BUFFER : ((NettyWritableBuffer) frame).<span style=color:#a6e22e>bytebuf</span>().<span style=color:#a6e22e>touch</span>();
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 统计 ByteBuf 的可读字节数</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>int</span> numBytes <span style=color:#f92672>=</span> bytebuf.<span style=color:#a6e22e>readableBytes</span>();
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 如果字节数大于 0</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (numBytes <span style=color:#f92672>&gt;</span> 0) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 将要出站的字节数添加到流控中</span>
</span></span><span style=display:flex><span>        onSendingBytes(numBytes);
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 将发送 gRPC 帧命令添加到写队列中</span>
</span></span><span style=display:flex><span>        writeQueue.<span style=color:#a6e22e>enqueue</span>(<span style=color:#66d9ef>new</span> SendGrpcFrameCommand(transportState(), bytebuf, endOfStream), flush)
</span></span><span style=display:flex><span>                  .<span style=color:#a6e22e>addListener</span>(<span style=color:#66d9ef>new</span> ChannelFutureListener() {
</span></span><span style=display:flex><span>                      <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>                      <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>operationComplete</span>(ChannelFuture future) <span style=color:#66d9ef>throws</span> Exception {
</span></span><span style=display:flex><span>                          <span style=color:#75715e>// 如果 future 成功，且 Transport 中的流不为 null</span>
</span></span><span style=display:flex><span>                          <span style=color:#66d9ef>if</span> (future.<span style=color:#a6e22e>isSuccess</span>() <span style=color:#f92672>&amp;&amp;</span> transportState().<span style=color:#a6e22e>http2Stream</span>() <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>                              <span style=color:#75715e>// 添加发送的字节数及统计</span>
</span></span><span style=display:flex><span>                              transportState().<span style=color:#a6e22e>onSentBytes</span>(numBytes);
</span></span><span style=display:flex><span>                              NettyClientStream.<span style=color:#a6e22e>this</span>.<span style=color:#a6e22e>getTransportTracer</span>().<span style=color:#a6e22e>reportMessageSent</span>(numMessages);
</span></span><span style=display:flex><span>                          }
</span></span><span style=display:flex><span>                      }
</span></span><span style=display:flex><span>                  });
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 如果发送的字节为空，则不会影响流控，仅仅发送</span>
</span></span><span style=display:flex><span>        writeQueue.<span style=color:#a6e22e>enqueue</span>(<span style=color:#66d9ef>new</span> SendGrpcFrameCommand(transportState(), bytebuf, endOfStream), flush);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=半关闭>半关闭</h4><ul><li>io.grpc.internal.AbstractClientStream#halfClose</li></ul><p>从客户端关闭流，关闭后客户端不能再发送消息，但是可以接收</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>halfClose</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>transportState().<span style=color:#a6e22e>isOutboundClosed</span>()) {
</span></span><span style=display:flex><span>        transportState().<span style=color:#a6e22e>setOutboundClosed</span>();
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 输出已经到达消息结尾</span>
</span></span><span style=display:flex><span>        endOfMessages();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>io.grpc.internal.AbstractStream#endOfMessages</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>endOfMessages</span>() {
</span></span><span style=display:flex><span>    framer().<span style=color:#a6e22e>close</span>();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>io.grpc.internal.MessageFramer#close</li></ul><p>调用 Framer，释放缓冲区， 提交流；最终还是通过 Netty，将关闭流的帧写入，发送给服务端</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>close</span>() {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>isClosed()) {
</span></span><span style=display:flex><span>    closed <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>    <span style=color:#75715e>// With the current code we don&#39;t expect readableBytes &gt; 0 to be possible here, added</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// defensively to prevent buffer leak issues if the framer code changes later.</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (buffer <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span> <span style=color:#f92672>&amp;&amp;</span> buffer.<span style=color:#a6e22e>readableBytes</span>() <span style=color:#f92672>==</span> 0) {
</span></span><span style=display:flex><span>      releaseBuffer();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    commitToSink(<span style=color:#66d9ef>true</span>, <span style=color:#66d9ef>true</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=获取返回结果>获取返回结果</h4><p>在 <code>io.grpc.stub.ClientCalls#blockingUnaryCall</code> 方法中，调用完 <code>futureUnaryCall</code> 方法后，会返回 <code>ListenableFuture</code>用于监听返回结果</p><ul><li>io.grpc.stub.ClientCalls#blockingUnaryCall</li></ul><p>会不断的循环，监听线程池返回的结果</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>ListenableFuture<span style=color:#f92672>&lt;</span>RespT<span style=color:#f92672>&gt;</span> responseFuture <span style=color:#f92672>=</span> futureUnaryCall(call, req);
</span></span><span style=display:flex><span><span style=color:#66d9ef>while</span> (<span style=color:#f92672>!</span>responseFuture.<span style=color:#a6e22e>isDone</span>()) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>    executor.<span style=color:#a6e22e>waitAndDrain</span>();
</span></span><span style=display:flex><span>  } <span style=color:#66d9ef>catch</span> (InterruptedException e) {
</span></span><span style=display:flex><span>    interrupt <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>    call.<span style=color:#a6e22e>cancel</span>(<span style=color:#e6db74>&#34;Thread interrupted&#34;</span>, e);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>return</span> getUnchecked(responseFuture);
</span></span></code></pre></div><p>当 Server 端返回响应内容时，会调用监听器的 <code>messagesAvailable</code> 方法，从响应的流中解析响应内容</p><ul><li>io.grpc.internal.ClientCallImpl.ClientStreamListenerImpl#messagesAvailable</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>  InputStream message;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>while</span> ((message <span style=color:#f92672>=</span> producer.<span style=color:#a6e22e>next</span>()) <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>	  <span style=color:#75715e>// 将消息流解析为响应对象，并传递给 Future</span>
</span></span><span style=display:flex><span>      observer.<span style=color:#a6e22e>onMessage</span>(method.<span style=color:#a6e22e>parseResponse</span>(message));
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>catch</span> (Throwable t) {
</span></span><span style=display:flex><span>      GrpcUtil.<span style=color:#a6e22e>closeQuietly</span>(message);
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>throw</span> t;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    message.<span style=color:#a6e22e>close</span>();
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>} <span style=color:#66d9ef>catch</span> (Throwable t) {
</span></span><span style=display:flex><span>  GrpcUtil.<span style=color:#a6e22e>closeQuietly</span>(producer);
</span></span><span style=display:flex><span>  Status status <span style=color:#f92672>=</span> Status.<span style=color:#a6e22e>CANCELLED</span>.<span style=color:#a6e22e>withCause</span>(t).<span style=color:#a6e22e>withDescription</span>(<span style=color:#e6db74>&#34;Failed to read message.&#34;</span>);
</span></span><span style=display:flex><span>  stream.<span style=color:#a6e22e>cancel</span>(status);
</span></span><span style=display:flex><span>  close(status, <span style=color:#66d9ef>new</span> Metadata());
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>io.grpc.stub.ClientCalls.UnaryStreamToFuture#onMessage</li></ul><p>为 Future 对象设置值</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>onMessage</span>(RespT value) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (<span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>value</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>throw</span> Status.<span style=color:#a6e22e>INTERNAL</span>.<span style=color:#a6e22e>withDescription</span>(<span style=color:#e6db74>&#34;More than one value received for unary call&#34;</span>)
</span></span><span style=display:flex><span>                         .<span style=color:#a6e22e>asRuntimeException</span>();
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>value</span> <span style=color:#f92672>=</span> value;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>io.grpc.stub.ClientCalls#getUnchecked</li></ul><p>返回 Future 的值</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#f92672>&lt;</span>V<span style=color:#f92672>&gt;</span> V <span style=color:#a6e22e>getUnchecked</span>(Future<span style=color:#f92672>&lt;</span>V<span style=color:#f92672>&gt;</span> future) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> future.<span style=color:#a6e22e>get</span>();
</span></span><span style=display:flex><span>  } <span style=color:#66d9ef>catch</span> (InterruptedException e) {
</span></span><span style=display:flex><span>    Thread.<span style=color:#a6e22e>currentThread</span>().<span style=color:#a6e22e>interrupt</span>();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>throw</span> Status.<span style=color:#a6e22e>CANCELLED</span>
</span></span><span style=display:flex><span>            .<span style=color:#a6e22e>withDescription</span>(<span style=color:#e6db74>&#34;Thread interrupted&#34;</span>)
</span></span><span style=display:flex><span>            .<span style=color:#a6e22e>withCause</span>(e)
</span></span><span style=display:flex><span>            .<span style=color:#a6e22e>asRuntimeException</span>();
</span></span><span style=display:flex><span>  } <span style=color:#66d9ef>catch</span> (ExecutionException e) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>throw</span> toStatusRuntimeException(e.<span style=color:#a6e22e>getCause</span>());
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></section><div class=paginator><a class=prev href=https://blog.hellowood.dev/posts/grpc-client-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/><svg class="icon" width="24" height="24" viewBox="0 0 24 24" fill="none"><path d="M3.77086 21.1546C11.0491 22.698 21.4339 21.7773 21.4339 16.3608V4.63375c0-.69413-.075800000000001-1.3284-.2422-1.86588M3.77086 21.1546C1.9934 20.7777.973585 18.7264 1.08749 16.688c.17931-3.209.06972-7.25665-.08236-10.47293C.87809 3.52811 3.12891 1.16316 5.51029 1.25008c4.25565.15534 9.86671-.04779 13.28091-.24466 1.2952-.074686 2.0494.62843 2.4005 1.76245M3.77086 21.1546C4.56586 21.4723 5.49168 21.7879 6.5 22.0658M21.1917 2.76787c1.918 1.4143 1.9383 9.65123 1.7087 13.59293-2.0526 7.6586-10.5943 7.3054-16.4004 5.705M21.1917 2.76787C21.7612 4.51192 22.7203 9.67216 22 16.3608 21.2797 23.0494 11.3665 22.9511 6.5 22.0658M9.94496 9C9.28897 9.61644 7.63215 10.997 6.04814 11.7966 5.98257 11.8297 5.98456 11.9753 6.05061 12.0063c1.00435.4716 2.8788 1.9201 3.89435 2.9937M6.44444 11.9667C8.86549 12.0608 14 12 16 11" stroke="currentcolor" stroke-linecap="round"/></svg>
<span>gRPC Client 启动流程</span></a>
<a class=next href=https://blog.hellowood.dev/posts/grpc-transport/><span>gRPC Transport</span><svg class="icon" width="24" height="24" viewBox="0 0 24 24" fill="none"><path d="M3.77086 21.1546C11.0491 22.698 21.4339 21.7773 21.4339 16.3608V4.63375c0-.69413-.075800000000001-1.3284-.2422-1.86588M3.77086 21.1546C1.9934 20.7777.973585 18.7264 1.08749 16.688c.17931-3.209.06972-7.25665-.08236-10.47293C.87809 3.52811 3.12891 1.16316 5.51029 1.25008c4.25565.15534 9.86671-.04779 13.28091-.24466 1.2952-.074686 2.0494.62843 2.4005 1.76245M3.77086 21.1546C4.56586 21.4723 5.49168 21.7879 6.5 22.0658M21.1917 2.76787c1.918 1.4143 1.9383 9.65123 1.7087 13.59293-2.0526 7.6586-10.5943 7.3054-16.4004 5.705M21.1917 2.76787C21.7612 4.51192 22.7203 9.67216 22 16.3608 21.2797 23.0494 11.3665 22.9511 6.5 22.0658M12.055 9C12.711 9.61644 14.3679 10.997 15.9519 11.7966 16.0174 11.8297 16.0154 11.9753 15.9494 12.0063 14.945 12.4779 13.0706 13.9264 12.055 15m3.5006-3.0333C13.1345 12.0608 8 12 6 11" stroke="currentcolor" stroke-linecap="round"/></svg></a></div></article></div><footer class=footer><p>&copy; 2024 <a href=https://blog.hellowood.dev/>HelloWood</a>
Powered by
<a href=https://gohugo.io/ rel=noopener target=_blank data-umami-event=to-hugo>Hugo️️</a>
<a href=https://github.com/guangzhengli/hugo-theme-ladder rel=noopener target=_blank data-umami-event=to-ladder>Ladder</a>
️</p></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g data-umami-event=top-link><svg width="24" height="24" viewBox="0 0 24 24" fill="none"><path d="M10.5376 22.7916C11.0152 22.7207 22.5795 21.1781 22.0978 10.4211 22.0536 9.43274 21.9303 8.53367 21.7387 7.71865M10.5376 22.7916C16.876 22.3728 20.0969 19.8899 21.5383 16.9142M10.5376 22.7916C9.7707 22.9055 8.97982 22.8964 8.19743 22.7725M21.7387 7.71865C21.4988 6.69828 21.1518 5.80967 20.7188 5.04257m1.0199 2.67608C22.6022 10.1105 23.0542 13.7848 21.5383 16.9142M20.7188 5.04257c-3.5504-6.28886-12.88753-4.410077-16.44303.0C2.88063 6.77451-.0433281 11.1668 1.38159 16.6571c.89322 3.4417 3.7911 5.6365 6.81584 6.1154M20.7188 5.04257c1.3509 1.89783 3.3111 6.34223 1.6353 10.37273M21.5383 16.9142C21.8737 16.4251 22.1428 15.9235 22.3541 15.4153M8.19743 22.7725C12.1971 23.4683 20.6281 22.971 22.3541 15.4153M14 10.945C13.3836 10.289 12.003 8.63215 11.2034 7.04814 11.1703 6.98257 11.0247 6.98456 10.9937 7.05061 10.5221 8.05496 9.07362 9.92941 8 10.945m3.0333-3.50056C10.9392 9.86549 11 15 12 17" stroke="currentcolor" stroke-linecap="round"/></svg>
</a><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const s=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="Copy";function n(){t.innerHTML="Copied",setTimeout(()=>{t.innerHTML="Copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),n();return}const s=document.createRange();s.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(s);try{document.execCommand("copy"),n()}catch{}o.removeRange(s)}),e.parentNode.appendChild(t)})</script></main></body><script src=https://cdnjs.cloudflare.com/ajax/libs/medium-zoom/1.0.6/medium-zoom.min.js integrity="sha512-N9IJRoc3LaP3NDoiGkcPa4gG94kapGpaA5Zq9/Dr04uf5TbLFU5q0o8AbRhLKUUlp8QFS2u7S+Yti0U7QtuZvQ==" crossorigin=anonymous referrerpolicy=no-referrer></script><script>const images=Array.from(document.querySelectorAll(".blog-content img"));images.forEach(e=>{mediumZoom(e,{margin:10,scrollOffset:40,container:null,template:null,background:"rgba(0, 0, 0, 0.5)"})})</script><script src=/main.min.6bb26b69159420159c74dc9e097b06a578ed2b68c701466a91a44a9632d851bd0af167a1b30012387b4c512b48ad9ad4d3394e04d77ae38d57e1920fe4ed34fe.js integrity="sha512-a7JraRWUIBWcdNyeCXsGpXjtK2jHAUZqkaRKljLYUb0K8WehswASOHtMUStIrZrU0zlOBNd6441X4ZIP5O00/g==" crossorigin=anonymous defer></script></html>