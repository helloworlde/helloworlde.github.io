<!doctype html><html lang=en><head><meta name=viewport content="width=device-width,initial-scale=1"><title>gRPC 中泛化调用服务接口</title><meta charset=utf-8><meta name=description content="Ladder@gRPC 中泛化调用服务接口 gRPC 没有直接支持泛化调用，protobuf 可以不依赖于生成的代码实现调用，所以可以通过反射接口间接实现泛化调用
要求 Server 端提供 grpc.reflection.v1alpha.ServerReflection 服务，用于获取服务的描述文件
大致的流程是：
根据方法名称，调用服务端反射服务的方法，获取方法所在 proto 文件的描述 根据 proto 描述文件，获取文件描述、服务描述，用于重新构建要被调用方法的方法描述 MethodDescriptor 根据方法描述，将请求内容序列化为对应的类型 使用重新构建的MethodDescriptor和其他参数对 Server 端相应的方法发起调用 解析响应并返回 实现 使用 JSON 格式请求被调用的服务方法，并返回 JSON 格式的响应
proto 定义 syntax = &#34;proto3&#34;; package io.github.helloworlde.grpc; option go_package = &#34;api;grpc_gateway&#34;; option java_package = &#34;io.github.helloworlde.grpc&#34;; option java_multiple_files = true; option java_outer_classname = &#34;HelloWorldGrpc&#34;; service HelloService{ rpc SayHello(HelloMessage) returns (HelloResponse){ } } message HelloMessage { string message = 2; } message HelloResponse { string message = 1; } 调用 1."><meta name=author content="HelloWood"><link rel=canonical href=https://blog.hellowood.dev/posts/grpc-%E4%B8%AD%E6%B3%9B%E5%8C%96%E8%B0%83%E7%94%A8%E6%9C%8D%E5%8A%A1%E6%8E%A5%E5%8F%A3/><meta name=google-site-verification content="G-3MSGPYTHPZ"><link rel=alternate type=application/rss+xml href=https://blog.hellowood.dev/index.xml title=HelloWood><script async src="https://www.googletagmanager.com/gtag/js?id=G-3MSGPYTHPZ"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-3MSGPYTHPZ",{anonymize_ip:!1})}</script><script async defer data-website-id=7a9034de-0ce7-4756-942a-829e6cd22301 src=https://umami.hellowood.dev/script.js></script><meta property="og:title" content="gRPC 中泛化调用服务接口"><meta property="og:description" content="gRPC 中泛化调用服务接口 gRPC 没有直接支持泛化调用，protobuf 可以不依赖于生成的代码实现调用，所以可以通过反射接口间接实现泛化调用
要求 Server 端提供 grpc.reflection.v1alpha.ServerReflection 服务，用于获取服务的描述文件
大致的流程是：
根据方法名称，调用服务端反射服务的方法，获取方法所在 proto 文件的描述 根据 proto 描述文件，获取文件描述、服务描述，用于重新构建要被调用方法的方法描述 MethodDescriptor 根据方法描述，将请求内容序列化为对应的类型 使用重新构建的MethodDescriptor和其他参数对 Server 端相应的方法发起调用 解析响应并返回 实现 使用 JSON 格式请求被调用的服务方法，并返回 JSON 格式的响应
proto 定义 syntax = &#34;proto3&#34;; package io.github.helloworlde.grpc; option go_package = &#34;api;grpc_gateway&#34;; option java_package = &#34;io.github.helloworlde.grpc&#34;; option java_multiple_files = true; option java_outer_classname = &#34;HelloWorldGrpc&#34;; service HelloService{ rpc SayHello(HelloMessage) returns (HelloResponse){ } } message HelloMessage { string message = 2; } message HelloResponse { string message = 1; } 调用 1."><meta property="og:type" content="article"><meta property="og:url" content="https://blog.hellowood.dev/posts/grpc-%E4%B8%AD%E6%B3%9B%E5%8C%96%E8%B0%83%E7%94%A8%E6%9C%8D%E5%8A%A1%E6%8E%A5%E5%8F%A3/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-01-29T22:34:46+00:00"><meta property="article:modified_time" content="2021-01-29T22:34:46+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="gRPC 中泛化调用服务接口"><meta name=twitter:description content="gRPC 中泛化调用服务接口 gRPC 没有直接支持泛化调用，protobuf 可以不依赖于生成的代码实现调用，所以可以通过反射接口间接实现泛化调用
要求 Server 端提供 grpc.reflection.v1alpha.ServerReflection 服务，用于获取服务的描述文件
大致的流程是：
根据方法名称，调用服务端反射服务的方法，获取方法所在 proto 文件的描述 根据 proto 描述文件，获取文件描述、服务描述，用于重新构建要被调用方法的方法描述 MethodDescriptor 根据方法描述，将请求内容序列化为对应的类型 使用重新构建的MethodDescriptor和其他参数对 Server 端相应的方法发起调用 解析响应并返回 实现 使用 JSON 格式请求被调用的服务方法，并返回 JSON 格式的响应
proto 定义 syntax = &#34;proto3&#34;; package io.github.helloworlde.grpc; option go_package = &#34;api;grpc_gateway&#34;; option java_package = &#34;io.github.helloworlde.grpc&#34;; option java_multiple_files = true; option java_outer_classname = &#34;HelloWorldGrpc&#34;; service HelloService{ rpc SayHello(HelloMessage) returns (HelloResponse){ } } message HelloMessage { string message = 2; } message HelloResponse { string message = 1; } 调用 1."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://blog.hellowood.dev/posts/"},{"@type":"ListItem","position":3,"name":"gRPC 中泛化调用服务接口","item":"https://blog.hellowood.dev/posts/grpc-%E4%B8%AD%E6%B3%9B%E5%8C%96%E8%B0%83%E7%94%A8%E6%9C%8D%E5%8A%A1%E6%8E%A5%E5%8F%A3/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"gRPC 中泛化调用服务接口","name":"gRPC 中泛化调用服务接口","description":"gRPC 中泛化调用服务接口 gRPC 没有直接支持泛化调用，protobuf 可以不依赖于生成的代码实现调用，所以可以通过反射接口间接实现泛化调用\n要求 Server 端提供 grpc.reflection.v1alpha.ServerReflection 服务，用于获取服务的描述文件\n大致的流程是：\n根据方法名称，调用服务端反射服务的方法，获取方法所在 proto 文件的描述 根据 proto 描述文件，获取文件描述、服务描述，用于重新构建要被调用方法的方法描述 MethodDescriptor 根据方法描述，将请求内容序列化为对应的类型 使用重新构建的MethodDescriptor和其他参数对 Server 端相应的方法发起调用 解析响应并返回 实现 使用 JSON 格式请求被调用的服务方法，并返回 JSON 格式的响应\nproto 定义 syntax = \u0026#34;proto3\u0026#34;; package io.github.helloworlde.grpc; option go_package = \u0026#34;api;grpc_gateway\u0026#34;; option java_package = \u0026#34;io.github.helloworlde.grpc\u0026#34;; option java_multiple_files = true; option java_outer_classname = \u0026#34;HelloWorldGrpc\u0026#34;; service HelloService{ rpc SayHello(HelloMessage) returns (HelloResponse){ } } message HelloMessage { string message = 2; } message HelloResponse { string message = 1; } 调用 1.","keywords":["gRPC"],"articleBody":"gRPC 中泛化调用服务接口 gRPC 没有直接支持泛化调用，protobuf 可以不依赖于生成的代码实现调用，所以可以通过反射接口间接实现泛化调用\n要求 Server 端提供 grpc.reflection.v1alpha.ServerReflection 服务，用于获取服务的描述文件\n大致的流程是：\n根据方法名称，调用服务端反射服务的方法，获取方法所在 proto 文件的描述 根据 proto 描述文件，获取文件描述、服务描述，用于重新构建要被调用方法的方法描述 MethodDescriptor 根据方法描述，将请求内容序列化为对应的类型 使用重新构建的MethodDescriptor和其他参数对 Server 端相应的方法发起调用 解析响应并返回 实现 使用 JSON 格式请求被调用的服务方法，并返回 JSON 格式的响应\nproto 定义 syntax = \"proto3\"; package io.github.helloworlde.grpc; option go_package = \"api;grpc_gateway\"; option java_package = \"io.github.helloworlde.grpc\"; option java_multiple_files = true; option java_outer_classname = \"HelloWorldGrpc\"; service HelloService{ rpc SayHello(HelloMessage) returns (HelloResponse){ } } message HelloMessage { string message = 2; } message HelloResponse { string message = 1; } 调用 1. 构建反射服务 Stub 需要调用反射服务的方法，该方法是双向流\n// 构建 Channel ManagedChannel channel=ManagedChannelBuilder.forAddress(\"127.0.0.1\",9090) .usePlaintext() .build(); // 使用 Channel 构建 BlockingStub ServerReflectionGrpc.ServerReflectionStub reflectionStub=ServerReflectionGrpc.newStub(channel); // 响应观察器 StreamObserver\u003cServerReflectionResponse\u003e streamObserver=new StreamObserver\u003cServerReflectionResponse\u003e(){ @Override public void onNext(ServerReflectionResponse response){ // 处理响应 } @Override public void onError(Throwable t){ } @Override public void onCompleted(){ log.info(\"Complete\"); } }; // 请求观察器 StreamObserver\u003cServerReflectionRequest\u003e requestStreamObserver=reflectionStub.serverReflectionInfo(streamObserver); 2. 根据方法名称获取文件描述 这里的 methodSymbol 即服务或方法的限定名，可以是 package.service 或者 package.service.method ，如 io.github.helloworlde.grpc.HelloService.SayHello，需要注意方法前是 .不是/\n// 构建并发送获取方法文件描述请求 ServerReflectionRequest getFileContainingSymbolRequest=ServerReflectionRequest.newBuilder() .setFileContainingSymbol(methodSymbol) .build(); requestStreamObserver.onNext(getFileContainingSymbolRequest); 3. 处理响应，解析 FileDescriptor 返回的响应后会触发 onNext 方法，如果响应类型是文件描述类型，即 FILE_DESCRIPTOR_RESPONSE，则进行处理\npublic void onNext(ServerReflectionResponse response) { try { // 只需要关注文件描述类型的响应 if (response.getMessageResponseCase() == ServerReflectionResponse.MessageResponseCase.FILE_DESCRIPTOR_RESPONSE) { List\u003cByteString\u003e fileDescriptorProtoList = response.getFileDescriptorResponse().getFileDescriptorProtoList(); handleResponse(fileDescriptorProtoList, channel, methodSymbol, requestContent); } else { log.warn(\"未知响应类型: \" + response.getMessageResponseCase()); } } catch (Exception e) { log.error(\"处理响应失败: {}\", e.getMessage(), e); } } handleResponse 在处理请求时，先解析了包名、服务名和方法名，然后根据包名和服务名，从返回的文件描述中获取到了响应方法所在文件的描述；然后从文件描述中获取服务描述，最终获取到方法描述，根据方法描述执行调用\nprivate static void handleResponse(List\u003cByteString\u003e fileDescriptorProtoList, ManagedChannel channel, String methodFullName, String requestContent) { try { // 解析方法和服务名称 String fullServiceName = extraPrefix(methodFullName); String methodName = extraSuffix(methodFullName); String packageName = extraPrefix(fullServiceName); String serviceName = extraSuffix(fullServiceName); // 根据响应解析 FileDescriptor Descriptors.FileDescriptor fileDescriptor = getFileDescriptor(fileDescriptorProtoList, packageName, serviceName); // 查找服务描述 Descriptors.ServiceDescriptor serviceDescriptor = fileDescriptor.getFile().findServiceByName(serviceName); // 查找方法描述 Descriptors.MethodDescriptor methodDescriptor = serviceDescriptor.findMethodByName(methodName); // 发起请求 executeCall(channel, fileDescriptor, methodDescriptor, requestContent); } catch (Exception e) { log.error(e.getMessage(), e); } } getFileDescriptor 根据响应找到方法对应的文件的 FileDescriptorProto，然后构建出对应的 FileDescriptor\nprivate static Descriptors.FileDescriptor getFileDescriptor(List\u003cByteString\u003e fileDescriptorProtoList, String packageName, String serviceName) throws Exception { Map\u003cString, DescriptorProtos.FileDescriptorProto\u003e fileDescriptorProtoMap = fileDescriptorProtoList.stream() .map(bs -\u003e { try { return DescriptorProtos.FileDescriptorProto.parseFrom(bs); } catch (InvalidProtocolBufferException e) { e.printStackTrace(); } return null; }) .filter(Objects::nonNull) .collect(Collectors.toMap(DescriptorProtos.FileDescriptorProto::getName, f -\u003e f)); if (fileDescriptorProtoMap.isEmpty()) { log.error(\"服务不存在\"); throw new IllegalArgumentException(\"方法的文件描述不存在\"); } // 查找服务对应的 Proto 描述 DescriptorProtos.FileDescriptorProto fileDescriptorProto = findServiceFileDescriptorProto(packageName, serviceName, fileDescriptorProtoMap); // 获取这个 Proto 的依赖 Descriptors.FileDescriptor[] dependencies = getDependencies(fileDescriptorProto, fileDescriptorProtoMap); // 生成 Proto 的 FileDescriptor return Descriptors.FileDescriptor.buildFrom(fileDescriptorProto, dependencies); } 4. 执行调用 生成方法描述 在执行调用时，需要重新生成 MethodDescriptor；因为获取到的 MethodDescriptor 中的方法全名是package.service.method 格式，而需要的是package.service/method格式，同时请求和响应类型也需要重新设置为 DynamicMessage,所以需要重新生成 MethodDescriptor\nprivate static MethodDescriptor\u003cDynamicMessage, DynamicMessage\u003e generateMethodDescriptor(Descriptors.MethodDescriptor originMethodDescriptor) { // 生成方法全名 String fullMethodName = MethodDescriptor.generateFullMethodName(originMethodDescriptor.getService().getFullName(), originMethodDescriptor.getName()); // 请求和响应类型 MethodDescriptor.Marshaller\u003cDynamicMessage\u003e inputTypeMarshaller = ProtoUtils.marshaller(DynamicMessage.newBuilder(originMethodDescriptor.getInputType()) .buildPartial()); MethodDescriptor.Marshaller\u003cDynamicMessage\u003e outputTypeMarshaller = ProtoUtils.marshaller(DynamicMessage.newBuilder(originMethodDescriptor.getOutputType()) .buildPartial()); // 生成方法描述, originMethodDescriptor 的 fullMethodName 不正确 return MethodDescriptor.\u003cDynamicMessage, DynamicMessage\u003enewBuilder() .setFullMethodName(fullMethodName) .setRequestMarshaller(inputTypeMarshaller) .setResponseMarshaller(outputTypeMarshaller) // 使用 UNKNOWN，自动修改 .setType(MethodDescriptor.MethodType.UNKNOWN) .build(); } 执行调用 同时需要根据文件描述，将请求的类型转为对应的请求类型，生成 DynamicMessage 对象；然后根据方法类型，使用MethodDescriptor 和 CallOptions 发起请求；当接收到响应后将 DynamicMessage 解析为对应的格式的字符串；完成调用\n参考文档 相关实现代码参考 ReflectionCall.java protobuf-dynamic grpcurl grpc-swagger gRPC + JSON gRPC Server Reflection Tutorial Reflection gRPC Server Reflection Tutorial Protocol buffer objects generated at runtime How can I send a gRPC message whose format is determined at runtime How to create GRPC client directly from protobuf without compiling it into java code ","wordCount":"454","inLanguage":"en","datePublished":"2021-01-29T22:34:46Z","dateModified":"2021-01-29T22:34:46Z","author":{"@type":"Person","name":"HelloWood"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.hellowood.dev/posts/grpc-%E4%B8%AD%E6%B3%9B%E5%8C%96%E8%B0%83%E7%94%A8%E6%9C%8D%E5%8A%A1%E6%8E%A5%E5%8F%A3/"},"publisher":{"@type":"Organization","name":"HelloWood","logo":{"@type":"ImageObject","url":"https://blog.hellowood.dev/favicon.ico"}}}</script><link rel=icon href=/images/avatar.png sizes=16x16><link rel=apple-touch-icon href=/images/avatar.png><link rel=manifest href=/images/avatar.png><link rel=stylesheet href=https://cdn.staticfile.org/lxgw-wenkai-webfont/1.6.0/style.css><link rel=stylesheet href=/css/main.min.f8020eba33d585b82c30b2a1ceb0d4c4e8e41fb6d8843d07d8ad056da8712972.css integrity="sha256-+AIOujPVhbgsMLKhzrDUxOjkH7bYhD0H2K0FbahxKXI=" crossorigin=anonymous media=screen><link rel=stylesheet href=/scss/highlight/github-dark.min.min.66034289ee9a113219a2c4aae0a8bd2095ab255c832a42efcf5863f10814e7a1.css><script src=/js/highlight.min.min.872dfd2cd00064018a833a6e8e77a0fbf8fbac159546f2f205d4dad79a5d8e15.js></script>
<script>hljs.highlightAll()</script><script>(()=>{var t=window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches,e=localStorage.getItem("theme");t&&e===null&&(localStorage.setItem("theme","dark"),document.documentElement.setAttribute("data-dark-mode","")),t&&e==="dark"&&document.documentElement.setAttribute("data-dark-mode",""),e==="dark"&&document.documentElement.setAttribute("data-dark-mode","")})()</script></head><body><main class=wrapper><nav class=navigation><section class=container><a class=navigation-brand href=/>HOME</a>
<input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><span></span><span></span><span></span></label><ul class=navigation-list id=navigation-list><li class="navigation-item navigation-menu"><a class=navigation-link href=/posts>Blog</a></li><li class="navigation-item navigation-menu"><a class=navigation-link href=/tags>Tags</a></li><li class="navigation-item navigation-menu"><a class=navigation-link href=/archives>Archive</a></li><li class="navigation-item navigation-menu"><a class=navigation-link href=https://umami.hellowood.dev/share/lab/Blog>Dashboard</a></li><li class="navigation-item menu-separator"><span>|</span></li><li class="navigation-item navigation-social"><a class=navigation-link href=https://github.com/helloworlde><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a></li><li class="navigation-item navigation-dark"><button id=mode type=button aria-label="toggle user light or dark theme">
<span class=toggle-dark><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-moon"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg></span><span class=toggle-light><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-sun"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></span></button></li></ul></section></nav><div id=content><article class=blog-single><header class=blog-title><h1>gRPC 中泛化调用服务接口</h1></header><p><small>January 29, 2021&nbsp;· 454 words&nbsp;· 3 min</small><p><div class=blog-toc><nav id=TableOfContents><ul><li><a href=#实现>实现</a><ul><li><a href=#proto-定义>proto 定义</a></li><li><a href=#调用>调用</a></li></ul></li><li><a href=#参考文档>参考文档</a></li></ul></nav></div><section class=blog-content><h1 id=grpc-中泛化调用服务接口>gRPC 中泛化调用服务接口</h1><p>gRPC 没有直接支持泛化调用，protobuf 可以不依赖于生成的代码实现调用，所以可以通过反射接口间接实现泛化调用</p><p>要求 Server 端提供 <code>grpc.reflection.v1alpha.ServerReflection</code> 服务，用于获取服务的描述文件</p><p>大致的流程是：</p><ol><li>根据方法名称，调用服务端反射服务的方法，获取方法所在 proto 文件的描述</li><li>根据 proto 描述文件，获取文件描述、服务描述，用于重新构建要被调用方法的方法描述 <code>MethodDescriptor</code></li><li>根据方法描述，将请求内容序列化为对应的类型</li><li>使用重新构建的<code>MethodDescriptor</code>和其他参数对 Server 端相应的方法发起调用</li><li>解析响应并返回</li></ol><h2 id=实现>实现</h2><p>使用 JSON 格式请求被调用的服务方法，并返回 JSON 格式的响应</p><h3 id=proto-定义>proto 定义</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-protobuf data-lang=protobuf><span style=display:flex><span>syntax <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;proto3&#34;</span>;<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#f92672>package</span> io<span style=color:#f92672>.</span>github.helloworlde.grpc;<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>option</span> go_package <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;api;grpc_gateway&#34;</span>;<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>option</span> java_package <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;io.github.helloworlde.grpc&#34;</span>;<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>option</span> java_multiple_files <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>option</span> java_outer_classname <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;HelloWorldGrpc&#34;</span>;<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>service</span> HelloService{<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>  <span style=color:#66d9ef>rpc</span> SayHello(HelloMessage) <span style=color:#66d9ef>returns</span> (HelloResponse){<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>  }<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>}<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>message</span> <span style=color:#a6e22e>HelloMessage</span> {<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>  <span style=color:#66d9ef>string</span> <span style=color:#66d9ef>message</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>;<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>}<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>message</span> <span style=color:#a6e22e>HelloResponse</span> {<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>  <span style=color:#66d9ef>string</span> <span style=color:#66d9ef>message</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>}<span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div><h3 id=调用>调用</h3><h4 id=1-构建反射服务-stub>1. 构建反射服务 Stub</h4><p>需要调用反射服务的方法，该方法是双向流</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// 构建 Channel
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>ManagedChannel channel<span style=color:#f92672>=</span>ManagedChannelBuilder<span style=color:#f92672>.</span><span style=color:#a6e22e>forAddress</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;127.0.0.1&#34;</span><span style=color:#f92672>,</span>9090<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>                                            <span style=color:#f92672>.</span><span style=color:#a6e22e>usePlaintext</span><span style=color:#f92672>()</span>
</span></span><span style=display:flex><span>                                            <span style=color:#f92672>.</span><span style=color:#a6e22e>build</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 使用 Channel 构建 BlockingStub
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>ServerReflectionGrpc<span style=color:#f92672>.</span><span style=color:#a6e22e>ServerReflectionStub</span> reflectionStub<span style=color:#f92672>=</span>ServerReflectionGrpc<span style=color:#f92672>.</span><span style=color:#a6e22e>newStub</span><span style=color:#f92672>(</span>channel<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 响应观察器
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>StreamObserver<span style=color:#f92672>&lt;</span>ServerReflectionResponse<span style=color:#f92672>&gt;</span> streamObserver<span style=color:#f92672>=</span><span style=color:#66d9ef>new</span> StreamObserver<span style=color:#f92672>&lt;</span>ServerReflectionResponse<span style=color:#f92672>&gt;(){</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>onNext</span><span style=color:#f92672>(</span>ServerReflectionResponse response<span style=color:#f92672>){</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 处理响应
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>onError</span><span style=color:#f92672>(</span>Throwable t<span style=color:#f92672>){</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>onCompleted</span><span style=color:#f92672>(){</span>
</span></span><span style=display:flex><span>        log<span style=color:#f92672>.</span><span style=color:#a6e22e>info</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;Complete&#34;</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>};</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 请求观察器
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>StreamObserver<span style=color:#f92672>&lt;</span>ServerReflectionRequest<span style=color:#f92672>&gt;</span> requestStreamObserver<span style=color:#f92672>=</span>reflectionStub<span style=color:#f92672>.</span><span style=color:#a6e22e>serverReflectionInfo</span><span style=color:#f92672>(</span>streamObserver<span style=color:#f92672>);</span>
</span></span></code></pre></div><h4 id=2-根据方法名称获取文件描述>2. 根据方法名称获取文件描述</h4><p>这里的 <code>methodSymbol</code> 即服务或方法的限定名，可以是 <code>package.service</code> 或者 <code>package.service.method</code>
，如 <code>io.github.helloworlde.grpc.HelloService.SayHello</code>，需要注意方法前是 <code>.</code>不是<code>/</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// 构建并发送获取方法文件描述请求
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>ServerReflectionRequest getFileContainingSymbolRequest<span style=color:#f92672>=</span>ServerReflectionRequest<span style=color:#f92672>.</span><span style=color:#a6e22e>newBuilder</span><span style=color:#f92672>()</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>.</span><span style=color:#a6e22e>setFileContainingSymbol</span><span style=color:#f92672>(</span>methodSymbol<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>.</span><span style=color:#a6e22e>build</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>        requestStreamObserver<span style=color:#f92672>.</span><span style=color:#a6e22e>onNext</span><span style=color:#f92672>(</span>getFileContainingSymbolRequest<span style=color:#f92672>);</span>
</span></span></code></pre></div><h4 id=3-处理响应解析-filedescriptor>3. 处理响应，解析 FileDescriptor</h4><p>返回的响应后会触发 <code>onNext</code> 方法，如果响应类型是文件描述类型，即 <code>FILE_DESCRIPTOR_RESPONSE</code>，则进行处理</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>onNext</span><span style=color:#f92672>(</span>ServerReflectionResponse response<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>try</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 只需要关注文件描述类型的响应
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>response<span style=color:#f92672>.</span><span style=color:#a6e22e>getMessageResponseCase</span><span style=color:#f92672>()</span> <span style=color:#f92672>==</span> ServerReflectionResponse<span style=color:#f92672>.</span><span style=color:#a6e22e>MessageResponseCase</span><span style=color:#f92672>.</span><span style=color:#a6e22e>FILE_DESCRIPTOR_RESPONSE</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            List<span style=color:#f92672>&lt;</span>ByteString<span style=color:#f92672>&gt;</span> fileDescriptorProtoList <span style=color:#f92672>=</span> response<span style=color:#f92672>.</span><span style=color:#a6e22e>getFileDescriptorResponse</span><span style=color:#f92672>().</span><span style=color:#a6e22e>getFileDescriptorProtoList</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>            handleResponse<span style=color:#f92672>(</span>fileDescriptorProtoList<span style=color:#f92672>,</span> channel<span style=color:#f92672>,</span> methodSymbol<span style=color:#f92672>,</span> requestContent<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span> <span style=color:#66d9ef>else</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            log<span style=color:#f92672>.</span><span style=color:#a6e22e>warn</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;未知响应类型: &#34;</span> <span style=color:#f92672>+</span> response<span style=color:#f92672>.</span><span style=color:#a6e22e>getMessageResponseCase</span><span style=color:#f92672>());</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span> <span style=color:#66d9ef>catch</span> <span style=color:#f92672>(</span>Exception e<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        log<span style=color:#f92672>.</span><span style=color:#a6e22e>error</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;处理响应失败: {}&#34;</span><span style=color:#f92672>,</span> e<span style=color:#f92672>.</span><span style=color:#a6e22e>getMessage</span><span style=color:#f92672>(),</span> e<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><ul><li>handleResponse</li></ul><p>在处理请求时，先解析了包名、服务名和方法名，然后根据包名和服务名，从返回的文件描述中获取到了响应方法所在文件的描述；然后从文件描述中获取服务描述，最终获取到方法描述，根据方法描述执行调用</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>handleResponse</span><span style=color:#f92672>(</span>List<span style=color:#f92672>&lt;</span>ByteString<span style=color:#f92672>&gt;</span> fileDescriptorProtoList<span style=color:#f92672>,</span>
</span></span><span style=display:flex><span>                                   ManagedChannel channel<span style=color:#f92672>,</span>
</span></span><span style=display:flex><span>                                   String methodFullName<span style=color:#f92672>,</span>
</span></span><span style=display:flex><span>                                   String requestContent<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>try</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 解析方法和服务名称
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        String fullServiceName <span style=color:#f92672>=</span> extraPrefix<span style=color:#f92672>(</span>methodFullName<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        String methodName <span style=color:#f92672>=</span> extraSuffix<span style=color:#f92672>(</span>methodFullName<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        String packageName <span style=color:#f92672>=</span> extraPrefix<span style=color:#f92672>(</span>fullServiceName<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        String serviceName <span style=color:#f92672>=</span> extraSuffix<span style=color:#f92672>(</span>fullServiceName<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 根据响应解析 FileDescriptor
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        Descriptors<span style=color:#f92672>.</span><span style=color:#a6e22e>FileDescriptor</span> fileDescriptor <span style=color:#f92672>=</span> getFileDescriptor<span style=color:#f92672>(</span>fileDescriptorProtoList<span style=color:#f92672>,</span> packageName<span style=color:#f92672>,</span> serviceName<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 查找服务描述
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        Descriptors<span style=color:#f92672>.</span><span style=color:#a6e22e>ServiceDescriptor</span> serviceDescriptor <span style=color:#f92672>=</span> fileDescriptor<span style=color:#f92672>.</span><span style=color:#a6e22e>getFile</span><span style=color:#f92672>().</span><span style=color:#a6e22e>findServiceByName</span><span style=color:#f92672>(</span>serviceName<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 查找方法描述
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        Descriptors<span style=color:#f92672>.</span><span style=color:#a6e22e>MethodDescriptor</span> methodDescriptor <span style=color:#f92672>=</span> serviceDescriptor<span style=color:#f92672>.</span><span style=color:#a6e22e>findMethodByName</span><span style=color:#f92672>(</span>methodName<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 发起请求
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        executeCall<span style=color:#f92672>(</span>channel<span style=color:#f92672>,</span> fileDescriptor<span style=color:#f92672>,</span> methodDescriptor<span style=color:#f92672>,</span> requestContent<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span> <span style=color:#66d9ef>catch</span> <span style=color:#f92672>(</span>Exception e<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        log<span style=color:#f92672>.</span><span style=color:#a6e22e>error</span><span style=color:#f92672>(</span>e<span style=color:#f92672>.</span><span style=color:#a6e22e>getMessage</span><span style=color:#f92672>(),</span> e<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><ul><li>getFileDescriptor</li></ul><p>根据响应找到方法对应的文件的 <code>FileDescriptorProto</code>，然后构建出对应的 <code>FileDescriptor</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> Descriptors<span style=color:#f92672>.</span><span style=color:#a6e22e>FileDescriptor</span> <span style=color:#a6e22e>getFileDescriptor</span><span style=color:#f92672>(</span>List<span style=color:#f92672>&lt;</span>ByteString<span style=color:#f92672>&gt;</span> fileDescriptorProtoList<span style=color:#f92672>,</span>
</span></span><span style=display:flex><span>                                                            String packageName<span style=color:#f92672>,</span>
</span></span><span style=display:flex><span>                                                            String serviceName<span style=color:#f92672>)</span> <span style=color:#66d9ef>throws</span> Exception <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    Map<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>,</span> DescriptorProtos<span style=color:#f92672>.</span><span style=color:#a6e22e>FileDescriptorProto</span><span style=color:#f92672>&gt;</span> fileDescriptorProtoMap <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>            fileDescriptorProtoList<span style=color:#f92672>.</span><span style=color:#a6e22e>stream</span><span style=color:#f92672>()</span>
</span></span><span style=display:flex><span>                                   <span style=color:#f92672>.</span><span style=color:#a6e22e>map</span><span style=color:#f92672>(</span>bs <span style=color:#f92672>-&gt;</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                                       <span style=color:#66d9ef>try</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                                           <span style=color:#66d9ef>return</span> DescriptorProtos<span style=color:#f92672>.</span><span style=color:#a6e22e>FileDescriptorProto</span><span style=color:#f92672>.</span><span style=color:#a6e22e>parseFrom</span><span style=color:#f92672>(</span>bs<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>                                       <span style=color:#f92672>}</span> <span style=color:#66d9ef>catch</span> <span style=color:#f92672>(</span>InvalidProtocolBufferException e<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                                           e<span style=color:#f92672>.</span><span style=color:#a6e22e>printStackTrace</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>                                       <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>                                       <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>                                   <span style=color:#f92672>})</span>
</span></span><span style=display:flex><span>                                   <span style=color:#f92672>.</span><span style=color:#a6e22e>filter</span><span style=color:#f92672>(</span>Objects<span style=color:#f92672>::</span>nonNull<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>                                   <span style=color:#f92672>.</span><span style=color:#a6e22e>collect</span><span style=color:#f92672>(</span>Collectors<span style=color:#f92672>.</span><span style=color:#a6e22e>toMap</span><span style=color:#f92672>(</span>DescriptorProtos<span style=color:#f92672>.</span><span style=color:#a6e22e>FileDescriptorProto</span><span style=color:#f92672>::</span>getName<span style=color:#f92672>,</span> f <span style=color:#f92672>-&gt;</span> f<span style=color:#f92672>));</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>fileDescriptorProtoMap<span style=color:#f92672>.</span><span style=color:#a6e22e>isEmpty</span><span style=color:#f92672>())</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        log<span style=color:#f92672>.</span><span style=color:#a6e22e>error</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;服务不存在&#34;</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> IllegalArgumentException<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;方法的文件描述不存在&#34;</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 查找服务对应的 Proto 描述
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    DescriptorProtos<span style=color:#f92672>.</span><span style=color:#a6e22e>FileDescriptorProto</span> fileDescriptorProto <span style=color:#f92672>=</span> findServiceFileDescriptorProto<span style=color:#f92672>(</span>packageName<span style=color:#f92672>,</span> serviceName<span style=color:#f92672>,</span> fileDescriptorProtoMap<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 获取这个 Proto 的依赖
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    Descriptors<span style=color:#f92672>.</span><span style=color:#a6e22e>FileDescriptor</span><span style=color:#f92672>[]</span> dependencies <span style=color:#f92672>=</span> getDependencies<span style=color:#f92672>(</span>fileDescriptorProto<span style=color:#f92672>,</span> fileDescriptorProtoMap<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 生成 Proto 的 FileDescriptor
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>return</span> Descriptors<span style=color:#f92672>.</span><span style=color:#a6e22e>FileDescriptor</span><span style=color:#f92672>.</span><span style=color:#a6e22e>buildFrom</span><span style=color:#f92672>(</span>fileDescriptorProto<span style=color:#f92672>,</span> dependencies<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><h4 id=4-执行调用>4. 执行调用</h4><ul><li>生成方法描述</li></ul><p>在执行调用时，需要重新生成 <code>MethodDescriptor</code>；因为获取到的 <code>MethodDescriptor</code> 中的方法全名是<code>package.service.method</code>
格式，而需要的是<code>package.service/method</code>格式，同时请求和响应类型也需要重新设置为 <code>DynamicMessage</code>,所以需要重新生成 <code>MethodDescriptor</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> MethodDescriptor<span style=color:#f92672>&lt;</span>DynamicMessage<span style=color:#f92672>,</span> DynamicMessage<span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>generateMethodDescriptor</span><span style=color:#f92672>(</span>Descriptors<span style=color:#f92672>.</span><span style=color:#a6e22e>MethodDescriptor</span> originMethodDescriptor<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 生成方法全名
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    String fullMethodName <span style=color:#f92672>=</span> MethodDescriptor<span style=color:#f92672>.</span><span style=color:#a6e22e>generateFullMethodName</span><span style=color:#f92672>(</span>originMethodDescriptor<span style=color:#f92672>.</span><span style=color:#a6e22e>getService</span><span style=color:#f92672>().</span><span style=color:#a6e22e>getFullName</span><span style=color:#f92672>(),</span> originMethodDescriptor<span style=color:#f92672>.</span><span style=color:#a6e22e>getName</span><span style=color:#f92672>());</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 请求和响应类型
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    MethodDescriptor<span style=color:#f92672>.</span><span style=color:#a6e22e>Marshaller</span><span style=color:#f92672>&lt;</span>DynamicMessage<span style=color:#f92672>&gt;</span> inputTypeMarshaller <span style=color:#f92672>=</span> ProtoUtils<span style=color:#f92672>.</span><span style=color:#a6e22e>marshaller</span><span style=color:#f92672>(</span>DynamicMessage<span style=color:#f92672>.</span><span style=color:#a6e22e>newBuilder</span><span style=color:#f92672>(</span>originMethodDescriptor<span style=color:#f92672>.</span><span style=color:#a6e22e>getInputType</span><span style=color:#f92672>())</span>
</span></span><span style=display:flex><span>                                                                                                          <span style=color:#f92672>.</span><span style=color:#a6e22e>buildPartial</span><span style=color:#f92672>());</span>
</span></span><span style=display:flex><span>    MethodDescriptor<span style=color:#f92672>.</span><span style=color:#a6e22e>Marshaller</span><span style=color:#f92672>&lt;</span>DynamicMessage<span style=color:#f92672>&gt;</span> outputTypeMarshaller <span style=color:#f92672>=</span> ProtoUtils<span style=color:#f92672>.</span><span style=color:#a6e22e>marshaller</span><span style=color:#f92672>(</span>DynamicMessage<span style=color:#f92672>.</span><span style=color:#a6e22e>newBuilder</span><span style=color:#f92672>(</span>originMethodDescriptor<span style=color:#f92672>.</span><span style=color:#a6e22e>getOutputType</span><span style=color:#f92672>())</span>
</span></span><span style=display:flex><span>                                                                                                           <span style=color:#f92672>.</span><span style=color:#a6e22e>buildPartial</span><span style=color:#f92672>());</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 生成方法描述, originMethodDescriptor 的 fullMethodName 不正确
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>return</span> MethodDescriptor<span style=color:#f92672>.&lt;</span>DynamicMessage<span style=color:#f92672>,</span> DynamicMessage<span style=color:#f92672>&gt;</span>newBuilder<span style=color:#f92672>()</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>.</span><span style=color:#a6e22e>setFullMethodName</span><span style=color:#f92672>(</span>fullMethodName<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>.</span><span style=color:#a6e22e>setRequestMarshaller</span><span style=color:#f92672>(</span>inputTypeMarshaller<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>.</span><span style=color:#a6e22e>setResponseMarshaller</span><span style=color:#f92672>(</span>outputTypeMarshaller<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 使用 UNKNOWN，自动修改
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#f92672>.</span><span style=color:#a6e22e>setType</span><span style=color:#f92672>(</span>MethodDescriptor<span style=color:#f92672>.</span><span style=color:#a6e22e>MethodType</span><span style=color:#f92672>.</span><span style=color:#a6e22e>UNKNOWN</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>.</span><span style=color:#a6e22e>build</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><ul><li>执行调用</li></ul><p>同时需要根据文件描述，将请求的类型转为对应的请求类型，生成 <code>DynamicMessage</code> 对象；然后根据方法类型，使用<code>MethodDescriptor</code> 和 <code>CallOptions</code>
发起请求；当接收到响应后将 <code>DynamicMessage</code> 解析为对应的格式的字符串；完成调用</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java></code></pre></div><hr><h2 id=参考文档>参考文档</h2><ul><li><a href=https://github.com/helloworlde/grpc-java-sample/blob/main/reflection/src/main/java/io/github/helloworlde/grpc/ReflectionCall.java>相关实现代码参考 ReflectionCall.java</a></li><li><a href=https://github.com/os72/protobuf-dynamic>protobuf-dynamic</a></li><li><a href=https://github.com/fullstorydev/grpcurl>grpcurl</a></li><li><a href=https://github.com/grpc-swagger/grpc-swagger>grpc-swagger</a></li><li><a href=https://grpc.io/blog/grpc-with-json/>gRPC + JSON</a></li><li><a href=https://github.com/grpc/grpc-java/blob/master/documentation/server-reflection-tutorial.md#enable-server-reflection>gRPC Server Reflection Tutorial</a></li><li><a href=https://github.com/grpc/grpc-go/tree/master/reflection>Reflection</a></li><li><a href=https://chromium.googlesource.com/external/github.com/grpc/grpc-go/+/HEAD/Documentation/server-reflection-tutorial.md>gRPC Server Reflection Tutorial</a></li><li><a href=https://stackoverflow.com/questions/18836727/protocol-buffer-objects-generated-at-runtime>Protocol buffer objects generated at runtime</a></li><li><a href=https://stackoverflow.com/questions/52368593/how-can-i-send-a-grpc-message-whose-format-is-determined-at-runtime>How can I send a gRPC message whose format is determined at runtime</a></li><li><a href=https://stackoverflow.com/questions/61133529/how-to-create-grpc-client-directly-from-protobuf-without-compiling-it-into-java/61144510#61144510>How to create GRPC client directly from protobuf without compiling it into java code</a></li></ul></section><div class=paginator><a class=prev href=https://blog.hellowood.dev/posts/thrift-%E4%B8%AD%E7%9A%84-protocol/><span>&larr;&nbsp;&nbsp;</span><span>Thrift 中的 Protocol</span></a>
<a class=next href=https://blog.hellowood.dev/posts/thrfit-%E4%B8%AD%E7%9A%84-server/><span>Thrfit 中的 Server</span><span>&nbsp;&nbsp;&rarr;</span></a></div></article></div><footer class=footer><p>&copy; 2023 <a href=https://blog.hellowood.dev>HelloWood</a>
Powered by
<a href=https://gohugo.io/ rel=noopener target=_blank>Hugo️️</a>
<a href=https://github.com/guangzhengli/hugo-theme-ladder rel=noopener target=_blank>Ladder</a>
️</p></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-up"><line x1="12" y1="19" x2="12" y2="5"/><polyline points="5 12 12 5 19 12"/></svg></a><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const s=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="Copy";function n(){t.innerHTML="Copied",setTimeout(()=>{t.innerHTML="Copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),n();return}const s=document.createRange();s.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(s);try{document.execCommand("copy"),n()}catch{}o.removeRange(s)}),e.parentNode.appendChild(t)})</script></main></body><script src=https://cdnjs.cloudflare.com/ajax/libs/medium-zoom/1.0.6/medium-zoom.min.js integrity="sha512-N9IJRoc3LaP3NDoiGkcPa4gG94kapGpaA5Zq9/Dr04uf5TbLFU5q0o8AbRhLKUUlp8QFS2u7S+Yti0U7QtuZvQ==" crossorigin=anonymous referrerpolicy=no-referrer></script>
<script>const images=Array.from(document.querySelectorAll(".blog-content img"));images.forEach(e=>{mediumZoom(e,{margin:10,scrollOffset:40,container:null,template:null,background:"rgba(0, 0, 0, 0.5)"})})</script><script src=/main.min.6bb26b69159420159c74dc9e097b06a578ed2b68c701466a91a44a9632d851bd0af167a1b30012387b4c512b48ad9ad4d3394e04d77ae38d57e1920fe4ed34fe.js integrity="sha512-a7JraRWUIBWcdNyeCXsGpXjtK2jHAUZqkaRKljLYUb0K8WehswASOHtMUStIrZrU0zlOBNd6441X4ZIP5O00/g==" crossorigin=anonymous defer></script></html>