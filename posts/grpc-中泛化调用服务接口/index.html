<!doctype html><html lang=en><head><meta name=viewport content="width=device-width,initial-scale=1"><title>gRPC 中泛化调用服务接口</title>
<meta charset=utf-8><meta name=description content='Ladder@gRPC 中泛化调用服务接口 gRPC 没有直接支持泛化调用，protobuf 可以不依赖于生成的代码实现调用，所以可以通过反射接口间接实现泛化调用
要求 Server 端提供 grpc.reflection.v1alpha.ServerReflection 服务，用于获取服务的描述文件
大致的流程是：
根据方法名称，调用服务端反射服务的方法，获取方法所在 proto 文件的描述 根据 proto 描述文件，获取文件描述、服务描述，用于重新构建要被调用方法的方法描述 MethodDescriptor 根据方法描述，将请求内容序列化为对应的类型 使用重新构建的MethodDescriptor和其他参数对 Server 端相应的方法发起调用 解析响应并返回 实现 使用 JSON 格式请求被调用的服务方法，并返回 JSON 格式的响应
proto 定义 syntax = "proto3"; package io.github.helloworlde.grpc; option go_package = "api;grpc_gateway"; option java_package = "io.github.helloworlde.grpc"; option java_multiple_files = true; option java_outer_classname = "HelloWorldGrpc"; service HelloService{ rpc SayHello(HelloMessage) returns (HelloResponse){ } } message HelloMessage { string message = 2; } message HelloResponse { string message = 1; } 调用 1.'><meta name=author content="HelloWood"><link rel=canonical href=https://blog.hellowood.dev/posts/grpc-%E4%B8%AD%E6%B3%9B%E5%8C%96%E8%B0%83%E7%94%A8%E6%9C%8D%E5%8A%A1%E6%8E%A5%E5%8F%A3/><meta name=google-site-verification content="G-3MSGPYTHPZ"><link rel=alternate type=application/rss+xml href=https://blog.hellowood.dev//index.xml title=HelloWood><script async src="https://www.googletagmanager.com/gtag/js?id=G-3MSGPYTHPZ"></script><script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-3MSGPYTHPZ",{anonymize_ip:!1})}</script><script async defer data-website-id=7a9034de-0ce7-4756-942a-829e6cd22301 src=https://umami.hellowood.dev/script.js></script><script defer data-cf-beacon='{"token": "b2e481d136dc428c8c96c8673e2a04cf"}' src=https://static.cloudflareinsights.com/beacon.min.js></script><meta property="og:title" content="gRPC 中泛化调用服务接口"><meta property="og:description" content='gRPC 中泛化调用服务接口 gRPC 没有直接支持泛化调用，protobuf 可以不依赖于生成的代码实现调用，所以可以通过反射接口间接实现泛化调用
要求 Server 端提供 grpc.reflection.v1alpha.ServerReflection 服务，用于获取服务的描述文件
大致的流程是：
根据方法名称，调用服务端反射服务的方法，获取方法所在 proto 文件的描述 根据 proto 描述文件，获取文件描述、服务描述，用于重新构建要被调用方法的方法描述 MethodDescriptor 根据方法描述，将请求内容序列化为对应的类型 使用重新构建的MethodDescriptor和其他参数对 Server 端相应的方法发起调用 解析响应并返回 实现 使用 JSON 格式请求被调用的服务方法，并返回 JSON 格式的响应
proto 定义 syntax = "proto3"; package io.github.helloworlde.grpc; option go_package = "api;grpc_gateway"; option java_package = "io.github.helloworlde.grpc"; option java_multiple_files = true; option java_outer_classname = "HelloWorldGrpc"; service HelloService{ rpc SayHello(HelloMessage) returns (HelloResponse){ } } message HelloMessage { string message = 2; } message HelloResponse { string message = 1; } 调用 1.'><meta property="og:type" content="article"><meta property="og:url" content="https://blog.hellowood.dev/posts/grpc-%E4%B8%AD%E6%B3%9B%E5%8C%96%E8%B0%83%E7%94%A8%E6%9C%8D%E5%8A%A1%E6%8E%A5%E5%8F%A3/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-01-29T22:34:46+00:00"><meta property="article:modified_time" content="2021-01-29T22:34:46+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="gRPC 中泛化调用服务接口"><meta name=twitter:description content='gRPC 中泛化调用服务接口 gRPC 没有直接支持泛化调用，protobuf 可以不依赖于生成的代码实现调用，所以可以通过反射接口间接实现泛化调用
要求 Server 端提供 grpc.reflection.v1alpha.ServerReflection 服务，用于获取服务的描述文件
大致的流程是：
根据方法名称，调用服务端反射服务的方法，获取方法所在 proto 文件的描述 根据 proto 描述文件，获取文件描述、服务描述，用于重新构建要被调用方法的方法描述 MethodDescriptor 根据方法描述，将请求内容序列化为对应的类型 使用重新构建的MethodDescriptor和其他参数对 Server 端相应的方法发起调用 解析响应并返回 实现 使用 JSON 格式请求被调用的服务方法，并返回 JSON 格式的响应
proto 定义 syntax = "proto3"; package io.github.helloworlde.grpc; option go_package = "api;grpc_gateway"; option java_package = "io.github.helloworlde.grpc"; option java_multiple_files = true; option java_outer_classname = "HelloWorldGrpc"; service HelloService{ rpc SayHello(HelloMessage) returns (HelloResponse){ } } message HelloMessage { string message = 2; } message HelloResponse { string message = 1; } 调用 1.'><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.hellowood.dev/posts/"},{"@type":"ListItem","position":2,"name":"gRPC 中泛化调用服务接口","item":"https://blog.hellowood.dev/posts/grpc-%E4%B8%AD%E6%B3%9B%E5%8C%96%E8%B0%83%E7%94%A8%E6%9C%8D%E5%8A%A1%E6%8E%A5%E5%8F%A3/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"gRPC 中泛化调用服务接口","name":"gRPC 中泛化调用服务接口","description":"gRPC 中泛化调用服务接口 gRPC 没有直接支持泛化调用，protobuf 可以不依赖于生成的代码实现调用，所以可以通过反射接口间接实现泛化调用\n要求 Server 端提供 grpc.reflection.v1alpha.ServerReflection 服务，用于获取服务的描述文件\n大致的流程是：\n根据方法名称，调用服务端反射服务的方法，获取方法所在 proto 文件的描述 根据 proto 描述文件，获取文件描述、服务描述，用于重新构建要被调用方法的方法描述 MethodDescriptor 根据方法描述，将请求内容序列化为对应的类型 使用重新构建的MethodDescriptor和其他参数对 Server 端相应的方法发起调用 解析响应并返回 实现 使用 JSON 格式请求被调用的服务方法，并返回 JSON 格式的响应\nproto 定义 syntax = \u0026#34;proto3\u0026#34;; package io.github.helloworlde.grpc; option go_package = \u0026#34;api;grpc_gateway\u0026#34;; option java_package = \u0026#34;io.github.helloworlde.grpc\u0026#34;; option java_multiple_files = true; option java_outer_classname = \u0026#34;HelloWorldGrpc\u0026#34;; service HelloService{ rpc SayHello(HelloMessage) returns (HelloResponse){ } } message HelloMessage { string message = 2; } message HelloResponse { string message = 1; } 调用 1.","keywords":["gRPC"],"articleBody":"gRPC 中泛化调用服务接口 gRPC 没有直接支持泛化调用，protobuf 可以不依赖于生成的代码实现调用，所以可以通过反射接口间接实现泛化调用\n要求 Server 端提供 grpc.reflection.v1alpha.ServerReflection 服务，用于获取服务的描述文件\n大致的流程是：\n根据方法名称，调用服务端反射服务的方法，获取方法所在 proto 文件的描述 根据 proto 描述文件，获取文件描述、服务描述，用于重新构建要被调用方法的方法描述 MethodDescriptor 根据方法描述，将请求内容序列化为对应的类型 使用重新构建的MethodDescriptor和其他参数对 Server 端相应的方法发起调用 解析响应并返回 实现 使用 JSON 格式请求被调用的服务方法，并返回 JSON 格式的响应\nproto 定义 syntax = \"proto3\"; package io.github.helloworlde.grpc; option go_package = \"api;grpc_gateway\"; option java_package = \"io.github.helloworlde.grpc\"; option java_multiple_files = true; option java_outer_classname = \"HelloWorldGrpc\"; service HelloService{ rpc SayHello(HelloMessage) returns (HelloResponse){ } } message HelloMessage { string message = 2; } message HelloResponse { string message = 1; } 调用 1. 构建反射服务 Stub 需要调用反射服务的方法，该方法是双向流\n// 构建 Channel ManagedChannel channel=ManagedChannelBuilder.forAddress(\"127.0.0.1\",9090) .usePlaintext() .build(); // 使用 Channel 构建 BlockingStub ServerReflectionGrpc.ServerReflectionStub reflectionStub=ServerReflectionGrpc.newStub(channel); // 响应观察器 StreamObserver\u003cServerReflectionResponse\u003e streamObserver=new StreamObserver\u003cServerReflectionResponse\u003e(){ @Override public void onNext(ServerReflectionResponse response){ // 处理响应 } @Override public void onError(Throwable t){ } @Override public void onCompleted(){ log.info(\"Complete\"); } }; // 请求观察器 StreamObserver\u003cServerReflectionRequest\u003e requestStreamObserver=reflectionStub.serverReflectionInfo(streamObserver); 2. 根据方法名称获取文件描述 这里的 methodSymbol 即服务或方法的限定名，可以是 package.service 或者 package.service.method ，如 io.github.helloworlde.grpc.HelloService.SayHello，需要注意方法前是 .不是/\n// 构建并发送获取方法文件描述请求 ServerReflectionRequest getFileContainingSymbolRequest=ServerReflectionRequest.newBuilder() .setFileContainingSymbol(methodSymbol) .build(); requestStreamObserver.onNext(getFileContainingSymbolRequest); 3. 处理响应，解析 FileDescriptor 返回的响应后会触发 onNext 方法，如果响应类型是文件描述类型，即 FILE_DESCRIPTOR_RESPONSE，则进行处理\npublic void onNext(ServerReflectionResponse response) { try { // 只需要关注文件描述类型的响应 if (response.getMessageResponseCase() == ServerReflectionResponse.MessageResponseCase.FILE_DESCRIPTOR_RESPONSE) { List\u003cByteString\u003e fileDescriptorProtoList = response.getFileDescriptorResponse().getFileDescriptorProtoList(); handleResponse(fileDescriptorProtoList, channel, methodSymbol, requestContent); } else { log.warn(\"未知响应类型: \" + response.getMessageResponseCase()); } } catch (Exception e) { log.error(\"处理响应失败: {}\", e.getMessage(), e); } } handleResponse 在处理请求时，先解析了包名、服务名和方法名，然后根据包名和服务名，从返回的文件描述中获取到了响应方法所在文件的描述；然后从文件描述中获取服务描述，最终获取到方法描述，根据方法描述执行调用\nprivate static void handleResponse(List\u003cByteString\u003e fileDescriptorProtoList, ManagedChannel channel, String methodFullName, String requestContent) { try { // 解析方法和服务名称 String fullServiceName = extraPrefix(methodFullName); String methodName = extraSuffix(methodFullName); String packageName = extraPrefix(fullServiceName); String serviceName = extraSuffix(fullServiceName); // 根据响应解析 FileDescriptor Descriptors.FileDescriptor fileDescriptor = getFileDescriptor(fileDescriptorProtoList, packageName, serviceName); // 查找服务描述 Descriptors.ServiceDescriptor serviceDescriptor = fileDescriptor.getFile().findServiceByName(serviceName); // 查找方法描述 Descriptors.MethodDescriptor methodDescriptor = serviceDescriptor.findMethodByName(methodName); // 发起请求 executeCall(channel, fileDescriptor, methodDescriptor, requestContent); } catch (Exception e) { log.error(e.getMessage(), e); } } getFileDescriptor 根据响应找到方法对应的文件的 FileDescriptorProto，然后构建出对应的 FileDescriptor\nprivate static Descriptors.FileDescriptor getFileDescriptor(List\u003cByteString\u003e fileDescriptorProtoList, String packageName, String serviceName) throws Exception { Map\u003cString, DescriptorProtos.FileDescriptorProto\u003e fileDescriptorProtoMap = fileDescriptorProtoList.stream() .map(bs -\u003e { try { return DescriptorProtos.FileDescriptorProto.parseFrom(bs); } catch (InvalidProtocolBufferException e) { e.printStackTrace(); } return null; }) .filter(Objects::nonNull) .collect(Collectors.toMap(DescriptorProtos.FileDescriptorProto::getName, f -\u003e f)); if (fileDescriptorProtoMap.isEmpty()) { log.error(\"服务不存在\"); throw new IllegalArgumentException(\"方法的文件描述不存在\"); } // 查找服务对应的 Proto 描述 DescriptorProtos.FileDescriptorProto fileDescriptorProto = findServiceFileDescriptorProto(packageName, serviceName, fileDescriptorProtoMap); // 获取这个 Proto 的依赖 Descriptors.FileDescriptor[] dependencies = getDependencies(fileDescriptorProto, fileDescriptorProtoMap); // 生成 Proto 的 FileDescriptor return Descriptors.FileDescriptor.buildFrom(fileDescriptorProto, dependencies); } 4. 执行调用 生成方法描述 在执行调用时，需要重新生成 MethodDescriptor；因为获取到的 MethodDescriptor 中的方法全名是package.service.method 格式，而需要的是package.service/method格式，同时请求和响应类型也需要重新设置为 DynamicMessage,所以需要重新生成 MethodDescriptor\nprivate static MethodDescriptor\u003cDynamicMessage, DynamicMessage\u003e generateMethodDescriptor(Descriptors.MethodDescriptor originMethodDescriptor) { // 生成方法全名 String fullMethodName = MethodDescriptor.generateFullMethodName(originMethodDescriptor.getService().getFullName(), originMethodDescriptor.getName()); // 请求和响应类型 MethodDescriptor.Marshaller\u003cDynamicMessage\u003e inputTypeMarshaller = ProtoUtils.marshaller(DynamicMessage.newBuilder(originMethodDescriptor.getInputType()) .buildPartial()); MethodDescriptor.Marshaller\u003cDynamicMessage\u003e outputTypeMarshaller = ProtoUtils.marshaller(DynamicMessage.newBuilder(originMethodDescriptor.getOutputType()) .buildPartial()); // 生成方法描述, originMethodDescriptor 的 fullMethodName 不正确 return MethodDescriptor.\u003cDynamicMessage, DynamicMessage\u003enewBuilder() .setFullMethodName(fullMethodName) .setRequestMarshaller(inputTypeMarshaller) .setResponseMarshaller(outputTypeMarshaller) // 使用 UNKNOWN，自动修改 .setType(MethodDescriptor.MethodType.UNKNOWN) .build(); } 执行调用 同时需要根据文件描述，将请求的类型转为对应的请求类型，生成 DynamicMessage 对象；然后根据方法类型，使用MethodDescriptor 和 CallOptions 发起请求；当接收到响应后将 DynamicMessage 解析为对应的格式的字符串；完成调用\n参考文档 相关实现代码参考 ReflectionCall.java protobuf-dynamic grpcurl grpc-swagger gRPC + JSON gRPC Server Reflection Tutorial Reflection gRPC Server Reflection Tutorial Protocol buffer objects generated at runtime How can I send a gRPC message whose format is determined at runtime How to create GRPC client directly from protobuf without compiling it into java code ","wordCount":"454","inLanguage":"en","datePublished":"2021-01-29T22:34:46Z","dateModified":"2021-01-29T22:34:46Z","author":{"@type":"Person","name":"HelloWood"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.hellowood.dev/posts/grpc-%E4%B8%AD%E6%B3%9B%E5%8C%96%E8%B0%83%E7%94%A8%E6%9C%8D%E5%8A%A1%E6%8E%A5%E5%8F%A3/"},"publisher":{"@type":"Organization","name":"HelloWood","logo":{"@type":"ImageObject","url":"https://blog.hellowood.dev/favicon.ico"}}}</script><link rel=icon href=/images/avatar.png sizes=16x16><link rel=apple-touch-icon href=/images/avatar.png><link rel=manifest href=/images/avatar.png><link rel=stylesheet href=https://cdn.staticfile.org/lxgw-wenkai-webfont/1.6.0/style.css><link rel=stylesheet href=/css/main.min.ff1bc260fafbfb440e10194d7d06d57eb5e85eed11d12d06255581262664204e.css integrity="sha256-/xvCYPr7+0QOEBlNfQbVfrXoXu0R0S0GJVWBJiZkIE4=" crossorigin=anonymous media=screen><link rel=stylesheet href=/scss/highlight/github-dark.min.min.66034289ee9a113219a2c4aae0a8bd2095ab255c832a42efcf5863f10814e7a1.css><script src=/js/highlight.min.min.c607d6febd16934a82eb61d3a896ed9d869f54373cc63ce95864ed5488fe3128.js></script><script>hljs.highlightAll()</script><script>(()=>{var t=window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches,e=localStorage.getItem("theme");t&&e===null&&(localStorage.setItem("theme","dark"),document.documentElement.setAttribute("data-dark-mode","")),t&&e==="dark"&&document.documentElement.setAttribute("data-dark-mode",""),e==="dark"&&document.documentElement.setAttribute("data-dark-mode","")})()</script><meta name=google-adsense-account content="ca-pub-3401351766168985"><script type=text/javascript>(function(e,t,n,s,o,i,a){e[n]=e[n]||function(){(e[n].q=e[n].q||[]).push(arguments)},i=t.createElement(s),i.async=1,i.src="https://www.clarity.ms/tag/"+o,a=t.getElementsByTagName(s)[0],a.parentNode.insertBefore(i,a)})(window,document,"clarity","script","jtbhx98g62")</script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3401351766168985" crossorigin=anonymous></script></head><body><main class=wrapper><nav class=navigation><section class=container><a class=navigation-brand data-umami-event=navigation-brand href=/>HOME
</a><input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><span></span><span></span><span></span></label><ul class=navigation-list id=navigation-list><li class="navigation-item navigation-menu"><a class=navigation-link data-umami-event=Blog href=/posts>Blog</a></li><li class="navigation-item navigation-menu"><a class=navigation-link data-umami-event=Tags href=/tags>Tags</a></li><li class="navigation-item navigation-menu"><a class=navigation-link data-umami-event=Archive href=/archives>Archive</a></li><li class="navigation-item navigation-menu"><a class=navigation-link data-umami-event=Dashboard href=https://umami.hellowood.dev/share/lab/Blog>Dashboard</a></li><li class="navigation-item menu-separator"><span>|</span></li><li class="navigation-item navigation-social"><a class=navigation-link data-umami-event=navigation-social href=https://github.com/helloworlde><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a></li><li class="navigation-item navigation-dark"><button id=mode type=button data-umami-event=toggle-theme aria-label="toggle user light or dark theme">
<span class=toggle-dark><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-moon"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg></span>
<span class=toggle-light><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-sun"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></span></button></li></ul></section></nav><div id=content><article class=blog-single><header class=blog-title><h1>gRPC 中泛化调用服务接口</h1></header><p><small>January 29, 2021&nbsp;· 454 words&nbsp;· 3 min</small><p><div class=blog-toc><nav id=TableOfContents><ul><li><a href=#实现>实现</a><ul><li><a href=#proto-定义>proto 定义</a></li><li><a href=#调用>调用</a></li></ul></li><li><a href=#参考文档>参考文档</a></li></ul></nav></div><section class=blog-content><h1 id=grpc-中泛化调用服务接口>gRPC 中泛化调用服务接口</h1><p>gRPC 没有直接支持泛化调用，protobuf 可以不依赖于生成的代码实现调用，所以可以通过反射接口间接实现泛化调用</p><p>要求 Server 端提供 <code>grpc.reflection.v1alpha.ServerReflection</code> 服务，用于获取服务的描述文件</p><p>大致的流程是：</p><ol><li>根据方法名称，调用服务端反射服务的方法，获取方法所在 proto 文件的描述</li><li>根据 proto 描述文件，获取文件描述、服务描述，用于重新构建要被调用方法的方法描述 <code>MethodDescriptor</code></li><li>根据方法描述，将请求内容序列化为对应的类型</li><li>使用重新构建的<code>MethodDescriptor</code>和其他参数对 Server 端相应的方法发起调用</li><li>解析响应并返回</li></ol><h2 id=实现>实现</h2><p>使用 JSON 格式请求被调用的服务方法，并返回 JSON 格式的响应</p><h3 id=proto-定义>proto 定义</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-protobuf data-lang=protobuf><span style=display:flex><span>syntax <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;proto3&#34;</span>;<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#f92672>package</span> io<span style=color:#f92672>.</span>github.helloworlde.grpc;<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>option</span> go_package <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;api;grpc_gateway&#34;</span>;<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>option</span> java_package <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;io.github.helloworlde.grpc&#34;</span>;<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>option</span> java_multiple_files <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>option</span> java_outer_classname <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;HelloWorldGrpc&#34;</span>;<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>service</span> HelloService{<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>  <span style=color:#66d9ef>rpc</span> SayHello(HelloMessage) <span style=color:#66d9ef>returns</span> (HelloResponse){<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>  }<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>}<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>message</span> <span style=color:#a6e22e>HelloMessage</span> {<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>  <span style=color:#66d9ef>string</span> <span style=color:#66d9ef>message</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>;<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>}<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>message</span> <span style=color:#a6e22e>HelloResponse</span> {<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>  <span style=color:#66d9ef>string</span> <span style=color:#66d9ef>message</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>}<span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div><h3 id=调用>调用</h3><h4 id=1-构建反射服务-stub>1. 构建反射服务 Stub</h4><p>需要调用反射服务的方法，该方法是双向流</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// 构建 Channel</span>
</span></span><span style=display:flex><span>ManagedChannel channel<span style=color:#f92672>=</span>ManagedChannelBuilder.<span style=color:#a6e22e>forAddress</span>(<span style=color:#e6db74>&#34;127.0.0.1&#34;</span>,9090)
</span></span><span style=display:flex><span>                                            .<span style=color:#a6e22e>usePlaintext</span>()
</span></span><span style=display:flex><span>                                            .<span style=color:#a6e22e>build</span>();
</span></span><span style=display:flex><span><span style=color:#75715e>// 使用 Channel 构建 BlockingStub</span>
</span></span><span style=display:flex><span>ServerReflectionGrpc.<span style=color:#a6e22e>ServerReflectionStub</span> reflectionStub<span style=color:#f92672>=</span>ServerReflectionGrpc.<span style=color:#a6e22e>newStub</span>(channel);
</span></span><span style=display:flex><span><span style=color:#75715e>// 响应观察器</span>
</span></span><span style=display:flex><span>StreamObserver<span style=color:#f92672>&lt;</span>ServerReflectionResponse<span style=color:#f92672>&gt;</span> streamObserver<span style=color:#f92672>=</span><span style=color:#66d9ef>new</span> StreamObserver<span style=color:#f92672>&lt;</span>ServerReflectionResponse<span style=color:#f92672>&gt;</span>(){
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>onNext</span>(ServerReflectionResponse response){
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 处理响应</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>onError</span>(Throwable t){
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>onCompleted</span>(){
</span></span><span style=display:flex><span>        log.<span style=color:#a6e22e>info</span>(<span style=color:#e6db74>&#34;Complete&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span><span style=color:#75715e>// 请求观察器</span>
</span></span><span style=display:flex><span>StreamObserver<span style=color:#f92672>&lt;</span>ServerReflectionRequest<span style=color:#f92672>&gt;</span> requestStreamObserver<span style=color:#f92672>=</span>reflectionStub.<span style=color:#a6e22e>serverReflectionInfo</span>(streamObserver);
</span></span></code></pre></div><h4 id=2-根据方法名称获取文件描述>2. 根据方法名称获取文件描述</h4><p>这里的 <code>methodSymbol</code> 即服务或方法的限定名，可以是 <code>package.service</code> 或者 <code>package.service.method</code>
，如 <code>io.github.helloworlde.grpc.HelloService.SayHello</code>，需要注意方法前是 <code>.</code>不是<code>/</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// 构建并发送获取方法文件描述请求</span>
</span></span><span style=display:flex><span>ServerReflectionRequest getFileContainingSymbolRequest<span style=color:#f92672>=</span>ServerReflectionRequest.<span style=color:#a6e22e>newBuilder</span>()
</span></span><span style=display:flex><span>        .<span style=color:#a6e22e>setFileContainingSymbol</span>(methodSymbol)
</span></span><span style=display:flex><span>        .<span style=color:#a6e22e>build</span>();
</span></span><span style=display:flex><span>        requestStreamObserver.<span style=color:#a6e22e>onNext</span>(getFileContainingSymbolRequest);
</span></span></code></pre></div><h4 id=3-处理响应解析-filedescriptor>3. 处理响应，解析 FileDescriptor</h4><p>返回的响应后会触发 <code>onNext</code> 方法，如果响应类型是文件描述类型，即 <code>FILE_DESCRIPTOR_RESPONSE</code>，则进行处理</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>onNext</span>(ServerReflectionResponse response) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 只需要关注文件描述类型的响应</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (response.<span style=color:#a6e22e>getMessageResponseCase</span>() <span style=color:#f92672>==</span> ServerReflectionResponse.<span style=color:#a6e22e>MessageResponseCase</span>.<span style=color:#a6e22e>FILE_DESCRIPTOR_RESPONSE</span>) {
</span></span><span style=display:flex><span>            List<span style=color:#f92672>&lt;</span>ByteString<span style=color:#f92672>&gt;</span> fileDescriptorProtoList <span style=color:#f92672>=</span> response.<span style=color:#a6e22e>getFileDescriptorResponse</span>().<span style=color:#a6e22e>getFileDescriptorProtoList</span>();
</span></span><span style=display:flex><span>            handleResponse(fileDescriptorProtoList, channel, methodSymbol, requestContent);
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            log.<span style=color:#a6e22e>warn</span>(<span style=color:#e6db74>&#34;未知响应类型: &#34;</span> <span style=color:#f92672>+</span> response.<span style=color:#a6e22e>getMessageResponseCase</span>());
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>catch</span> (Exception e) {
</span></span><span style=display:flex><span>        log.<span style=color:#a6e22e>error</span>(<span style=color:#e6db74>&#34;处理响应失败: {}&#34;</span>, e.<span style=color:#a6e22e>getMessage</span>(), e);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>handleResponse</li></ul><p>在处理请求时，先解析了包名、服务名和方法名，然后根据包名和服务名，从返回的文件描述中获取到了响应方法所在文件的描述；然后从文件描述中获取服务描述，最终获取到方法描述，根据方法描述执行调用</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>handleResponse</span>(List<span style=color:#f92672>&lt;</span>ByteString<span style=color:#f92672>&gt;</span> fileDescriptorProtoList,
</span></span><span style=display:flex><span>                                   ManagedChannel channel,
</span></span><span style=display:flex><span>                                   String methodFullName,
</span></span><span style=display:flex><span>                                   String requestContent) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 解析方法和服务名称</span>
</span></span><span style=display:flex><span>        String fullServiceName <span style=color:#f92672>=</span> extraPrefix(methodFullName);
</span></span><span style=display:flex><span>        String methodName <span style=color:#f92672>=</span> extraSuffix(methodFullName);
</span></span><span style=display:flex><span>        String packageName <span style=color:#f92672>=</span> extraPrefix(fullServiceName);
</span></span><span style=display:flex><span>        String serviceName <span style=color:#f92672>=</span> extraSuffix(fullServiceName);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 根据响应解析 FileDescriptor</span>
</span></span><span style=display:flex><span>        Descriptors.<span style=color:#a6e22e>FileDescriptor</span> fileDescriptor <span style=color:#f92672>=</span> getFileDescriptor(fileDescriptorProtoList, packageName, serviceName);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 查找服务描述</span>
</span></span><span style=display:flex><span>        Descriptors.<span style=color:#a6e22e>ServiceDescriptor</span> serviceDescriptor <span style=color:#f92672>=</span> fileDescriptor.<span style=color:#a6e22e>getFile</span>().<span style=color:#a6e22e>findServiceByName</span>(serviceName);
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 查找方法描述</span>
</span></span><span style=display:flex><span>        Descriptors.<span style=color:#a6e22e>MethodDescriptor</span> methodDescriptor <span style=color:#f92672>=</span> serviceDescriptor.<span style=color:#a6e22e>findMethodByName</span>(methodName);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 发起请求</span>
</span></span><span style=display:flex><span>        executeCall(channel, fileDescriptor, methodDescriptor, requestContent);
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>catch</span> (Exception e) {
</span></span><span style=display:flex><span>        log.<span style=color:#a6e22e>error</span>(e.<span style=color:#a6e22e>getMessage</span>(), e);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>getFileDescriptor</li></ul><p>根据响应找到方法对应的文件的 <code>FileDescriptorProto</code>，然后构建出对应的 <code>FileDescriptor</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> Descriptors.<span style=color:#a6e22e>FileDescriptor</span> <span style=color:#a6e22e>getFileDescriptor</span>(List<span style=color:#f92672>&lt;</span>ByteString<span style=color:#f92672>&gt;</span> fileDescriptorProtoList,
</span></span><span style=display:flex><span>                                                            String packageName,
</span></span><span style=display:flex><span>                                                            String serviceName) <span style=color:#66d9ef>throws</span> Exception {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    Map<span style=color:#f92672>&lt;</span>String, DescriptorProtos.<span style=color:#a6e22e>FileDescriptorProto</span><span style=color:#f92672>&gt;</span> fileDescriptorProtoMap <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>            fileDescriptorProtoList.<span style=color:#a6e22e>stream</span>()
</span></span><span style=display:flex><span>                                   .<span style=color:#a6e22e>map</span>(bs <span style=color:#f92672>-&gt;</span> {
</span></span><span style=display:flex><span>                                       <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>                                           <span style=color:#66d9ef>return</span> DescriptorProtos.<span style=color:#a6e22e>FileDescriptorProto</span>.<span style=color:#a6e22e>parseFrom</span>(bs);
</span></span><span style=display:flex><span>                                       } <span style=color:#66d9ef>catch</span> (InvalidProtocolBufferException e) {
</span></span><span style=display:flex><span>                                           e.<span style=color:#a6e22e>printStackTrace</span>();
</span></span><span style=display:flex><span>                                       }
</span></span><span style=display:flex><span>                                       <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>                                   })
</span></span><span style=display:flex><span>                                   .<span style=color:#a6e22e>filter</span>(Objects::nonNull)
</span></span><span style=display:flex><span>                                   .<span style=color:#a6e22e>collect</span>(Collectors.<span style=color:#a6e22e>toMap</span>(DescriptorProtos.<span style=color:#a6e22e>FileDescriptorProto</span>::getName, f <span style=color:#f92672>-&gt;</span> f));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (fileDescriptorProtoMap.<span style=color:#a6e22e>isEmpty</span>()) {
</span></span><span style=display:flex><span>        log.<span style=color:#a6e22e>error</span>(<span style=color:#e6db74>&#34;服务不存在&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> IllegalArgumentException(<span style=color:#e6db74>&#34;方法的文件描述不存在&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 查找服务对应的 Proto 描述</span>
</span></span><span style=display:flex><span>    DescriptorProtos.<span style=color:#a6e22e>FileDescriptorProto</span> fileDescriptorProto <span style=color:#f92672>=</span> findServiceFileDescriptorProto(packageName, serviceName, fileDescriptorProtoMap);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 获取这个 Proto 的依赖</span>
</span></span><span style=display:flex><span>    Descriptors.<span style=color:#a6e22e>FileDescriptor</span><span style=color:#f92672>[]</span> dependencies <span style=color:#f92672>=</span> getDependencies(fileDescriptorProto, fileDescriptorProtoMap);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 生成 Proto 的 FileDescriptor</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> Descriptors.<span style=color:#a6e22e>FileDescriptor</span>.<span style=color:#a6e22e>buildFrom</span>(fileDescriptorProto, dependencies);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=4-执行调用>4. 执行调用</h4><ul><li>生成方法描述</li></ul><p>在执行调用时，需要重新生成 <code>MethodDescriptor</code>；因为获取到的 <code>MethodDescriptor</code> 中的方法全名是<code>package.service.method</code>
格式，而需要的是<code>package.service/method</code>格式，同时请求和响应类型也需要重新设置为 <code>DynamicMessage</code>,所以需要重新生成 <code>MethodDescriptor</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> MethodDescriptor<span style=color:#f92672>&lt;</span>DynamicMessage, DynamicMessage<span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>generateMethodDescriptor</span>(Descriptors.<span style=color:#a6e22e>MethodDescriptor</span> originMethodDescriptor) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 生成方法全名</span>
</span></span><span style=display:flex><span>    String fullMethodName <span style=color:#f92672>=</span> MethodDescriptor.<span style=color:#a6e22e>generateFullMethodName</span>(originMethodDescriptor.<span style=color:#a6e22e>getService</span>().<span style=color:#a6e22e>getFullName</span>(), originMethodDescriptor.<span style=color:#a6e22e>getName</span>());
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 请求和响应类型</span>
</span></span><span style=display:flex><span>    MethodDescriptor.<span style=color:#a6e22e>Marshaller</span><span style=color:#f92672>&lt;</span>DynamicMessage<span style=color:#f92672>&gt;</span> inputTypeMarshaller <span style=color:#f92672>=</span> ProtoUtils.<span style=color:#a6e22e>marshaller</span>(DynamicMessage.<span style=color:#a6e22e>newBuilder</span>(originMethodDescriptor.<span style=color:#a6e22e>getInputType</span>())
</span></span><span style=display:flex><span>                                                                                                          .<span style=color:#a6e22e>buildPartial</span>());
</span></span><span style=display:flex><span>    MethodDescriptor.<span style=color:#a6e22e>Marshaller</span><span style=color:#f92672>&lt;</span>DynamicMessage<span style=color:#f92672>&gt;</span> outputTypeMarshaller <span style=color:#f92672>=</span> ProtoUtils.<span style=color:#a6e22e>marshaller</span>(DynamicMessage.<span style=color:#a6e22e>newBuilder</span>(originMethodDescriptor.<span style=color:#a6e22e>getOutputType</span>())
</span></span><span style=display:flex><span>                                                                                                           .<span style=color:#a6e22e>buildPartial</span>());
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 生成方法描述, originMethodDescriptor 的 fullMethodName 不正确</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> MethodDescriptor.<span style=color:#f92672>&lt;</span>DynamicMessage, DynamicMessage<span style=color:#f92672>&gt;</span>newBuilder()
</span></span><span style=display:flex><span>            .<span style=color:#a6e22e>setFullMethodName</span>(fullMethodName)
</span></span><span style=display:flex><span>            .<span style=color:#a6e22e>setRequestMarshaller</span>(inputTypeMarshaller)
</span></span><span style=display:flex><span>            .<span style=color:#a6e22e>setResponseMarshaller</span>(outputTypeMarshaller)
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 使用 UNKNOWN，自动修改</span>
</span></span><span style=display:flex><span>            .<span style=color:#a6e22e>setType</span>(MethodDescriptor.<span style=color:#a6e22e>MethodType</span>.<span style=color:#a6e22e>UNKNOWN</span>)
</span></span><span style=display:flex><span>            .<span style=color:#a6e22e>build</span>();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>执行调用</li></ul><p>同时需要根据文件描述，将请求的类型转为对应的请求类型，生成 <code>DynamicMessage</code> 对象；然后根据方法类型，使用<code>MethodDescriptor</code> 和 <code>CallOptions</code>
发起请求；当接收到响应后将 <code>DynamicMessage</code> 解析为对应的格式的字符串；完成调用</p><hr><h2 id=参考文档>参考文档</h2><ul><li><a href=https://github.com/helloworlde/grpc-java-sample/blob/main/reflection/src/main/java/io/github/helloworlde/grpc/ReflectionCall.java>相关实现代码参考 ReflectionCall.java</a></li><li><a href=https://github.com/os72/protobuf-dynamic>protobuf-dynamic</a></li><li><a href=https://github.com/fullstorydev/grpcurl>grpcurl</a></li><li><a href=https://github.com/grpc-swagger/grpc-swagger>grpc-swagger</a></li><li><a href=https://grpc.io/blog/grpc-with-json/>gRPC + JSON</a></li><li><a href=https://github.com/grpc/grpc-java/blob/master/documentation/server-reflection-tutorial.md#enable-server-reflection>gRPC Server Reflection Tutorial</a></li><li><a href=https://github.com/grpc/grpc-go/tree/master/reflection>Reflection</a></li><li><a href=https://chromium.googlesource.com/external/github.com/grpc/grpc-go/+/HEAD/Documentation/server-reflection-tutorial.md>gRPC Server Reflection Tutorial</a></li><li><a href=https://stackoverflow.com/questions/18836727/protocol-buffer-objects-generated-at-runtime>Protocol buffer objects generated at runtime</a></li><li><a href=https://stackoverflow.com/questions/52368593/how-can-i-send-a-grpc-message-whose-format-is-determined-at-runtime>How can I send a gRPC message whose format is determined at runtime</a></li><li><a href=https://stackoverflow.com/questions/61133529/how-to-create-grpc-client-directly-from-protobuf-without-compiling-it-into-java/61144510#61144510>How to create GRPC client directly from protobuf without compiling it into java code</a></li></ul></section><div class=paginator><a class=prev href=https://blog.hellowood.dev/posts/thrift-%E4%B8%AD%E7%9A%84-protocol/><svg class="icon" width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M3.77086 21.1546C11.0491 22.698 21.4339 21.7773 21.4339 16.3608V4.63375c0-.69413-.075800000000001-1.3284-.2422-1.86588M3.77086 21.1546C1.9934 20.7777.973585 18.7264 1.08749 16.688c.17931-3.209.06972-7.25665-.08236-10.47293C.87809 3.52811 3.12891 1.16316 5.51029 1.25008c4.25565.15534 9.86671-.04779 13.28091-.24466 1.2952-.074686 2.0494.62843 2.4005 1.76245M3.77086 21.1546C4.56586 21.4723 5.49168 21.7879 6.5 22.0658M21.1917 2.76787c1.918 1.4143 1.9383 9.65123 1.7087 13.59293-2.0526 7.6586-10.5943 7.3054-16.4004 5.705M21.1917 2.76787C21.7612 4.51192 22.7203 9.67216 22 16.3608 21.2797 23.0494 11.3665 22.9511 6.5 22.0658M9.94496 9C9.28897 9.61644 7.63215 10.997 6.04814 11.7966 5.98257 11.8297 5.98456 11.9753 6.05061 12.0063c1.00435.4716 2.8788 1.9201 3.89435 2.9937M6.44444 11.9667C8.86549 12.0608 14 12 16 11" stroke="currentcolor" stroke-linecap="round"/></svg>
<span>Thrift 中的 Protocol</span></a>
<a class=next href=https://blog.hellowood.dev/posts/thrfit-%E4%B8%AD%E7%9A%84-server/><span>Thrfit 中的 Server</span><svg class="icon" width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M3.77086 21.1546C11.0491 22.698 21.4339 21.7773 21.4339 16.3608V4.63375c0-.69413-.075800000000001-1.3284-.2422-1.86588M3.77086 21.1546C1.9934 20.7777.973585 18.7264 1.08749 16.688c.17931-3.209.06972-7.25665-.08236-10.47293C.87809 3.52811 3.12891 1.16316 5.51029 1.25008c4.25565.15534 9.86671-.04779 13.28091-.24466 1.2952-.074686 2.0494.62843 2.4005 1.76245M3.77086 21.1546C4.56586 21.4723 5.49168 21.7879 6.5 22.0658M21.1917 2.76787c1.918 1.4143 1.9383 9.65123 1.7087 13.59293-2.0526 7.6586-10.5943 7.3054-16.4004 5.705M21.1917 2.76787C21.7612 4.51192 22.7203 9.67216 22 16.3608 21.2797 23.0494 11.3665 22.9511 6.5 22.0658M12.055 9C12.711 9.61644 14.3679 10.997 15.9519 11.7966 16.0174 11.8297 16.0154 11.9753 15.9494 12.0063 14.945 12.4779 13.0706 13.9264 12.055 15m3.5006-3.0333C13.1345 12.0608 8 12 6 11" stroke="currentcolor" stroke-linecap="round"/></svg></a></div></article></div><footer class=footer><p>&copy; 2024 <a href=https://blog.hellowood.dev/>HelloWood</a>
Powered by
<a href=https://gohugo.io/ rel=noopener target=_blank data-umami-event=to-hugo>Hugo️️</a>
<a href=https://github.com/guangzhengli/hugo-theme-ladder rel=noopener target=_blank data-umami-event=to-ladder>Ladder</a>
️</p></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g data-umami-event=top-link><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M10.5376 22.7916C11.0152 22.7207 22.5795 21.1781 22.0978 10.4211 22.0536 9.43274 21.9303 8.53367 21.7387 7.71865M10.5376 22.7916C16.876 22.3728 20.0969 19.8899 21.5383 16.9142M10.5376 22.7916C9.7707 22.9055 8.97982 22.8964 8.19743 22.7725M21.7387 7.71865C21.4988 6.69828 21.1518 5.80967 20.7188 5.04257m1.0199 2.67608C22.6022 10.1105 23.0542 13.7848 21.5383 16.9142M20.7188 5.04257c-3.5504-6.28886-12.88753-4.410077-16.44303.0C2.88063 6.77451-.0433281 11.1668 1.38159 16.6571c.89322 3.4417 3.7911 5.6365 6.81584 6.1154M20.7188 5.04257c1.3509 1.89783 3.3111 6.34223 1.6353 10.37273M21.5383 16.9142C21.8737 16.4251 22.1428 15.9235 22.3541 15.4153M8.19743 22.7725C12.1971 23.4683 20.6281 22.971 22.3541 15.4153M14 10.945C13.3836 10.289 12.003 8.63215 11.2034 7.04814 11.1703 6.98257 11.0247 6.98456 10.9937 7.05061 10.5221 8.05496 9.07362 9.92941 8 10.945m3.0333-3.50056C10.9392 9.86549 11 15 12 17" stroke="currentcolor" stroke-linecap="round"/></svg>
</a><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const s=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="Copy";function n(){t.innerHTML="Copied",setTimeout(()=>{t.innerHTML="Copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),n();return}const s=document.createRange();s.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(s);try{document.execCommand("copy"),n()}catch{}o.removeRange(s)}),e.parentNode.appendChild(t)})</script></main></body><script src=https://cdnjs.cloudflare.com/ajax/libs/medium-zoom/1.0.6/medium-zoom.min.js integrity="sha512-N9IJRoc3LaP3NDoiGkcPa4gG94kapGpaA5Zq9/Dr04uf5TbLFU5q0o8AbRhLKUUlp8QFS2u7S+Yti0U7QtuZvQ==" crossorigin=anonymous referrerpolicy=no-referrer></script><script>const images=Array.from(document.querySelectorAll(".blog-content img"));images.forEach(e=>{mediumZoom(e,{margin:10,scrollOffset:40,container:null,template:null,background:"rgba(0, 0, 0, 0.5)"})})</script><script src=/main.min.6bb26b69159420159c74dc9e097b06a578ed2b68c701466a91a44a9632d851bd0af167a1b30012387b4c512b48ad9ad4d3394e04d77ae38d57e1920fe4ed34fe.js integrity="sha512-a7JraRWUIBWcdNyeCXsGpXjtK2jHAUZqkaRKljLYUb0K8WehswASOHtMUStIrZrU0zlOBNd6441X4ZIP5O00/g==" crossorigin=anonymous defer></script></html>