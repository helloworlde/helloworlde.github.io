<!doctype html><html lang=en><head><meta name=viewport content="width=device-width,initial-scale=1"><title>gRPC 对冲原理</title>
<meta charset=utf-8><meta name=description content="Ladder@gRPC 对冲原理 gRPC 对冲开启后，当请求在指定的时间间隔后没有返回时，会发起对冲请求，继续等待，如果依然没有返回，则重复发送直到接收到返回结果或者超时取消
对冲适用于当下游服务部分节点故障无法及时响应或者响应不及时的场景，通过对冲可以减少请求的失败率，但是可能会导致延时增加
对冲和重试的流程相似，在第一次发起请求的时候根据服务名和方法名决定使用哪种策略；如果是对冲策略，则在发起请求时提交一个延时任务，这个任务会发起一个新的请求，并在执行的时候再发起一个请求，并将这些请求添加到队列中；多个请求哪个先返回就使用哪个请求的结果，将其他的请求取消并提交流
执行流程 io.grpc.internal.RetriableStream#start 开始第一个 RPC 调用
@Override public final void start(ClientStreamListener listener) { // 构造一个 BufferEntry class StartEntry implements BufferEntry { @Override public void runWith(Substream substream) { substream.stream.start(new Sublistener(substream)); } } synchronized (lock) { // 新建 BufferEntry，添加到 buffer 中 state.buffer.add(new StartEntry()); } // 创建 Substream Substream substream = createSubstream(0); hedgingPolicy = hedgingPolicyProvider.get(); // 如果有对冲策略 if (!HedgingPolicy.DEFAULT.equals(hedgingPolicy)) { // 如果对冲策略有效，则将重试策略置为 null isHedging = true; retryPolicy = RetryPolicy."><meta name=author content="HelloWood"><link rel=canonical href=https://blog.hellowood.dev/posts/grpc-%E5%AF%B9%E5%86%B2%E5%8E%9F%E7%90%86/><meta name=google-site-verification content="G-3MSGPYTHPZ"><link rel=alternate type=application/rss+xml href=https://blog.hellowood.dev//index.xml title=HelloWood><script async src="https://www.googletagmanager.com/gtag/js?id=G-3MSGPYTHPZ"></script><script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-3MSGPYTHPZ",{anonymize_ip:!1})}</script><script async defer data-website-id=7a9034de-0ce7-4756-942a-829e6cd22301 src=https://umami.hellowood.dev/script.js></script><script defer data-cf-beacon='{"token": "b2e481d136dc428c8c96c8673e2a04cf"}' src=https://static.cloudflareinsights.com/beacon.min.js></script><meta property="og:title" content="gRPC 对冲原理"><meta property="og:description" content="gRPC 对冲原理 gRPC 对冲开启后，当请求在指定的时间间隔后没有返回时，会发起对冲请求，继续等待，如果依然没有返回，则重复发送直到接收到返回结果或者超时取消
对冲适用于当下游服务部分节点故障无法及时响应或者响应不及时的场景，通过对冲可以减少请求的失败率，但是可能会导致延时增加
对冲和重试的流程相似，在第一次发起请求的时候根据服务名和方法名决定使用哪种策略；如果是对冲策略，则在发起请求时提交一个延时任务，这个任务会发起一个新的请求，并在执行的时候再发起一个请求，并将这些请求添加到队列中；多个请求哪个先返回就使用哪个请求的结果，将其他的请求取消并提交流
执行流程 io.grpc.internal.RetriableStream#start 开始第一个 RPC 调用
@Override public final void start(ClientStreamListener listener) { // 构造一个 BufferEntry class StartEntry implements BufferEntry { @Override public void runWith(Substream substream) { substream.stream.start(new Sublistener(substream)); } } synchronized (lock) { // 新建 BufferEntry，添加到 buffer 中 state.buffer.add(new StartEntry()); } // 创建 Substream Substream substream = createSubstream(0); hedgingPolicy = hedgingPolicyProvider.get(); // 如果有对冲策略 if (!HedgingPolicy.DEFAULT.equals(hedgingPolicy)) { // 如果对冲策略有效，则将重试策略置为 null isHedging = true; retryPolicy = RetryPolicy."><meta property="og:type" content="article"><meta property="og:url" content="https://blog.hellowood.dev/posts/grpc-%E5%AF%B9%E5%86%B2%E5%8E%9F%E7%90%86/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-09-20T22:39:26+00:00"><meta property="article:modified_time" content="2020-09-20T22:39:26+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="gRPC 对冲原理"><meta name=twitter:description content="gRPC 对冲原理 gRPC 对冲开启后，当请求在指定的时间间隔后没有返回时，会发起对冲请求，继续等待，如果依然没有返回，则重复发送直到接收到返回结果或者超时取消
对冲适用于当下游服务部分节点故障无法及时响应或者响应不及时的场景，通过对冲可以减少请求的失败率，但是可能会导致延时增加
对冲和重试的流程相似，在第一次发起请求的时候根据服务名和方法名决定使用哪种策略；如果是对冲策略，则在发起请求时提交一个延时任务，这个任务会发起一个新的请求，并在执行的时候再发起一个请求，并将这些请求添加到队列中；多个请求哪个先返回就使用哪个请求的结果，将其他的请求取消并提交流
执行流程 io.grpc.internal.RetriableStream#start 开始第一个 RPC 调用
@Override public final void start(ClientStreamListener listener) { // 构造一个 BufferEntry class StartEntry implements BufferEntry { @Override public void runWith(Substream substream) { substream.stream.start(new Sublistener(substream)); } } synchronized (lock) { // 新建 BufferEntry，添加到 buffer 中 state.buffer.add(new StartEntry()); } // 创建 Substream Substream substream = createSubstream(0); hedgingPolicy = hedgingPolicyProvider.get(); // 如果有对冲策略 if (!HedgingPolicy.DEFAULT.equals(hedgingPolicy)) { // 如果对冲策略有效，则将重试策略置为 null isHedging = true; retryPolicy = RetryPolicy."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.hellowood.dev/posts/"},{"@type":"ListItem","position":2,"name":"gRPC 对冲原理","item":"https://blog.hellowood.dev/posts/grpc-%E5%AF%B9%E5%86%B2%E5%8E%9F%E7%90%86/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"gRPC 对冲原理","name":"gRPC 对冲原理","description":"gRPC 对冲原理 gRPC 对冲开启后，当请求在指定的时间间隔后没有返回时，会发起对冲请求，继续等待，如果依然没有返回，则重复发送直到接收到返回结果或者超时取消\n对冲适用于当下游服务部分节点故障无法及时响应或者响应不及时的场景，通过对冲可以减少请求的失败率，但是可能会导致延时增加\n对冲和重试的流程相似，在第一次发起请求的时候根据服务名和方法名决定使用哪种策略；如果是对冲策略，则在发起请求时提交一个延时任务，这个任务会发起一个新的请求，并在执行的时候再发起一个请求，并将这些请求添加到队列中；多个请求哪个先返回就使用哪个请求的结果，将其他的请求取消并提交流\n执行流程 io.grpc.internal.RetriableStream#start 开始第一个 RPC 调用\n@Override public final void start(ClientStreamListener listener) { // 构造一个 BufferEntry class StartEntry implements BufferEntry { @Override public void runWith(Substream substream) { substream.stream.start(new Sublistener(substream)); } } synchronized (lock) { // 新建 BufferEntry，添加到 buffer 中 state.buffer.add(new StartEntry()); } // 创建 Substream Substream substream = createSubstream(0); hedgingPolicy = hedgingPolicyProvider.get(); // 如果有对冲策略 if (!HedgingPolicy.DEFAULT.equals(hedgingPolicy)) { // 如果对冲策略有效，则将重试策略置为 null isHedging = true; retryPolicy = RetryPolicy.","keywords":["gRPC"],"articleBody":"gRPC 对冲原理 gRPC 对冲开启后，当请求在指定的时间间隔后没有返回时，会发起对冲请求，继续等待，如果依然没有返回，则重复发送直到接收到返回结果或者超时取消\n对冲适用于当下游服务部分节点故障无法及时响应或者响应不及时的场景，通过对冲可以减少请求的失败率，但是可能会导致延时增加\n对冲和重试的流程相似，在第一次发起请求的时候根据服务名和方法名决定使用哪种策略；如果是对冲策略，则在发起请求时提交一个延时任务，这个任务会发起一个新的请求，并在执行的时候再发起一个请求，并将这些请求添加到队列中；多个请求哪个先返回就使用哪个请求的结果，将其他的请求取消并提交流\n执行流程 io.grpc.internal.RetriableStream#start 开始第一个 RPC 调用\n@Override public final void start(ClientStreamListener listener) { // 构造一个 BufferEntry class StartEntry implements BufferEntry { @Override public void runWith(Substream substream) { substream.stream.start(new Sublistener(substream)); } } synchronized (lock) { // 新建 BufferEntry，添加到 buffer 中 state.buffer.add(new StartEntry()); } // 创建 Substream Substream substream = createSubstream(0); hedgingPolicy = hedgingPolicyProvider.get(); // 如果有对冲策略 if (!HedgingPolicy.DEFAULT.equals(hedgingPolicy)) { // 如果对冲策略有效，则将重试策略置为 null isHedging = true; retryPolicy = RetryPolicy.DEFAULT; FutureCanceller scheduledHedgingRef = null; synchronized (lock) { // 将这个流添加到对冲中 state = state.addActiveHedge(substream); // 没有提交的流，且没有达到最大对冲次数，且没有终止，且没有节流或没有达到节流阈值 // 则创建对冲 Future if (hasPotentialHedging(state) \u0026\u0026 (throttle == null || throttle.isAboveThreshold())) { scheduledHedging = scheduledHedgingRef = new FutureCanceller(lock); } } // 如果对冲请求不为空，则提交延时任务 if (scheduledHedgingRef != null) { scheduledHedgingRef.setFuture( scheduledExecutorService.schedule( new HedgingRunnable(scheduledHedgingRef), hedgingPolicy.hedgingDelayNanos, TimeUnit.NANOSECONDS) ); } } // 消耗缓冲的请求 drain(substream); } io.grpc.internal.RetriableStream.HedgingRunnable 对冲任务，在执行的时候发起请求，并根据当前的提交的请求数量、状态等判断是否需要取消，如果不取消则再次提交一个延时任务\nprivate final class HedgingRunnable implements Runnable { @Override public void run() { callExecutor.execute(new Runnable() { @Override public void run() { // 创建对冲流 Substream newSubstream = createSubstream(state.hedgingAttemptCount); boolean cancelled = false; FutureCanceller future = null; synchronized (lock) { // 如果请求被取消了，则取消流 if (scheduledHedgingRef.isCancelled()) { cancelled = true; } else { // 将新创建的流添加到对冲流集合中 state = state.addActiveHedge(newSubstream); // 没有提交的流，且没有达到最大对冲次数，且没有终止，且没有节流或者没有达到节流阈值， // 则创建 Future if (hasPotentialHedging(state) \u0026\u0026 (throttle == null || throttle.isAboveThreshold())) { scheduledHedging = future = new FutureCanceller(lock); } else { // 否则冻结对冲 state = state.freezeHedging(); scheduledHedging = null; } } } // 如果请求已经取消了，则取消流并返回 if (cancelled) { newSubstream.stream.cancel(Status.CANCELLED.withDescription(\"Unneeded hedging\")); return; } // 如果对冲请求不为空，则提交延时任务 if (future != null) { future.setFuture( scheduledExecutorService.schedule( new HedgingRunnable(future), hedgingPolicy.hedgingDelayNanos, TimeUnit.NANOSECONDS)); } // 消耗缓冲的请求 drain(newSubstream); } }); } } ","wordCount":"244","inLanguage":"en","datePublished":"2020-09-20T22:39:26Z","dateModified":"2020-09-20T22:39:26Z","author":{"@type":"Person","name":"HelloWood"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.hellowood.dev/posts/grpc-%E5%AF%B9%E5%86%B2%E5%8E%9F%E7%90%86/"},"publisher":{"@type":"Organization","name":"HelloWood","logo":{"@type":"ImageObject","url":"https://blog.hellowood.dev/favicon.ico"}}}</script><link rel=icon href=/images/avatar.png sizes=16x16><link rel=apple-touch-icon href=/images/avatar.png><link rel=manifest href=/images/avatar.png><link rel=stylesheet href=https://cdn.staticfile.org/lxgw-wenkai-webfont/1.6.0/style.css><link rel=stylesheet href=/css/main.min.ff1bc260fafbfb440e10194d7d06d57eb5e85eed11d12d06255581262664204e.css integrity="sha256-/xvCYPr7+0QOEBlNfQbVfrXoXu0R0S0GJVWBJiZkIE4=" crossorigin=anonymous media=screen><link rel=stylesheet href=/scss/highlight/github-dark.min.min.66034289ee9a113219a2c4aae0a8bd2095ab255c832a42efcf5863f10814e7a1.css><script src=/js/highlight.min.min.c607d6febd16934a82eb61d3a896ed9d869f54373cc63ce95864ed5488fe3128.js></script><script>hljs.highlightAll()</script><script>(()=>{var t=window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches,e=localStorage.getItem("theme");t&&e===null&&(localStorage.setItem("theme","dark"),document.documentElement.setAttribute("data-dark-mode","")),t&&e==="dark"&&document.documentElement.setAttribute("data-dark-mode",""),e==="dark"&&document.documentElement.setAttribute("data-dark-mode","")})()</script><meta name=google-adsense-account content="ca-pub-3401351766168985"><script type=text/javascript>(function(e,t,n,s,o,i,a){e[n]=e[n]||function(){(e[n].q=e[n].q||[]).push(arguments)},i=t.createElement(s),i.async=1,i.src="https://www.clarity.ms/tag/"+o,a=t.getElementsByTagName(s)[0],a.parentNode.insertBefore(i,a)})(window,document,"clarity","script","jtbhx98g62")</script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3401351766168985" crossorigin=anonymous></script></head><body><main class=wrapper><nav class=navigation><section class=container><a class=navigation-brand data-umami-event=navigation-brand href=/>HOME
</a><input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><span></span><span></span><span></span></label><ul class=navigation-list id=navigation-list><li class="navigation-item navigation-menu"><a class=navigation-link data-umami-event=Blog href=/posts>Blog</a></li><li class="navigation-item navigation-menu"><a class=navigation-link data-umami-event=Tags href=/tags>Tags</a></li><li class="navigation-item navigation-menu"><a class=navigation-link data-umami-event=Archive href=/archives>Archive</a></li><li class="navigation-item navigation-menu"><a class=navigation-link data-umami-event=Dashboard href=https://umami.hellowood.dev/share/lab/Blog>Dashboard</a></li><li class="navigation-item menu-separator"><span>|</span></li><li class="navigation-item navigation-social"><a class=navigation-link data-umami-event=navigation-social href=https://github.com/helloworlde><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a></li><li class="navigation-item navigation-dark"><button id=mode type=button data-umami-event=toggle-theme aria-label="toggle user light or dark theme">
<span class=toggle-dark><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-moon"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg></span>
<span class=toggle-light><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-sun"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></span></button></li></ul></section></nav><div id=content><article class=blog-single><header class=blog-title><h1>gRPC 对冲原理</h1></header><p><small>September 20, 2020&nbsp;· 244 words&nbsp;· 2 min</small><p><div class=blog-toc><nav id=TableOfContents><ul><li><a href=#执行流程>执行流程</a></li></ul></nav></div><section class=blog-content><h1 id=grpc-对冲原理>gRPC 对冲原理</h1><p>gRPC 对冲开启后，当请求在指定的时间间隔后没有返回时，会发起对冲请求，继续等待，如果依然没有返回，则重复发送直到接收到返回结果或者超时取消</p><p>对冲适用于当下游服务部分节点故障无法及时响应或者响应不及时的场景，通过对冲可以减少请求的失败率，但是可能会导致延时增加</p><p>对冲和重试的流程相似，在第一次发起请求的时候根据服务名和方法名决定使用哪种策略；如果是对冲策略，则在发起请求时提交一个延时任务，这个任务会发起一个新的请求，并在执行的时候再发起一个请求，并将这些请求添加到队列中；多个请求哪个先返回就使用哪个请求的结果，将其他的请求取消并提交流</p><h2 id=执行流程>执行流程</h2><ul><li>io.grpc.internal.RetriableStream#start</li></ul><p>开始第一个 RPC 调用</p><pre tabindex=0><code>  @Override
  public final void start(ClientStreamListener listener) {
    // 构造一个 BufferEntry
    class StartEntry implements BufferEntry {
      @Override
      public void runWith(Substream substream) {
        substream.stream.start(new Sublistener(substream));
      }
    }

    synchronized (lock) {
      // 新建 BufferEntry，添加到 buffer 中
      state.buffer.add(new StartEntry());
    }

    // 创建 Substream
    Substream substream = createSubstream(0);
    hedgingPolicy = hedgingPolicyProvider.get();
    // 如果有对冲策略
    if (!HedgingPolicy.DEFAULT.equals(hedgingPolicy)) {
      // 如果对冲策略有效，则将重试策略置为 null
      isHedging = true;
      retryPolicy = RetryPolicy.DEFAULT;

      FutureCanceller scheduledHedgingRef = null;

      synchronized (lock) {
        // 将这个流添加到对冲中
        state = state.addActiveHedge(substream);
        // 没有提交的流，且没有达到最大对冲次数，且没有终止，且没有节流或没有达到节流阈值
        // 则创建对冲 Future
        if (hasPotentialHedging(state) &amp;&amp; (throttle == null || throttle.isAboveThreshold())) {
          scheduledHedging = scheduledHedgingRef = new FutureCanceller(lock);
        }
      }

      // 如果对冲请求不为空，则提交延时任务
      if (scheduledHedgingRef != null) {
        scheduledHedgingRef.setFuture(
                scheduledExecutorService.schedule(
                        new HedgingRunnable(scheduledHedgingRef),
                        hedgingPolicy.hedgingDelayNanos,
                        TimeUnit.NANOSECONDS)
        );
      }
    }
    // 消耗缓冲的请求
    drain(substream);
  }
</code></pre><ul><li>io.grpc.internal.RetriableStream.HedgingRunnable</li></ul><p>对冲任务，在执行的时候发起请求，并根据当前的提交的请求数量、状态等判断是否需要取消，如果不取消则再次提交一个延时任务</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>  <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>HedgingRunnable</span> <span style=color:#66d9ef>implements</span> Runnable {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>run</span>() {
</span></span><span style=display:flex><span>      callExecutor.<span style=color:#a6e22e>execute</span>(<span style=color:#66d9ef>new</span> Runnable() {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>run</span>() {
</span></span><span style=display:flex><span>          <span style=color:#75715e>// 创建对冲流</span>
</span></span><span style=display:flex><span>          Substream newSubstream <span style=color:#f92672>=</span> createSubstream(state.<span style=color:#a6e22e>hedgingAttemptCount</span>);
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>boolean</span> cancelled <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>          FutureCanceller future <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>synchronized</span> (lock) {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 如果请求被取消了，则取消流</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (scheduledHedgingRef.<span style=color:#a6e22e>isCancelled</span>()) {
</span></span><span style=display:flex><span>              cancelled <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>              <span style=color:#75715e>// 将新创建的流添加到对冲流集合中</span>
</span></span><span style=display:flex><span>              state <span style=color:#f92672>=</span> state.<span style=color:#a6e22e>addActiveHedge</span>(newSubstream);
</span></span><span style=display:flex><span>              <span style=color:#75715e>// 没有提交的流，且没有达到最大对冲次数，且没有终止，且没有节流或者没有达到节流阈值，</span>
</span></span><span style=display:flex><span>              <span style=color:#75715e>// 则创建 Future</span>
</span></span><span style=display:flex><span>              <span style=color:#66d9ef>if</span> (hasPotentialHedging(state) <span style=color:#f92672>&amp;&amp;</span> (throttle <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span> <span style=color:#f92672>||</span> throttle.<span style=color:#a6e22e>isAboveThreshold</span>())) {
</span></span><span style=display:flex><span>                scheduledHedging <span style=color:#f92672>=</span> future <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> FutureCanceller(lock);
</span></span><span style=display:flex><span>              } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 否则冻结对冲</span>
</span></span><span style=display:flex><span>                state <span style=color:#f92672>=</span> state.<span style=color:#a6e22e>freezeHedging</span>();
</span></span><span style=display:flex><span>                scheduledHedging <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>              }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>          }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>          <span style=color:#75715e>// 如果请求已经取消了，则取消流并返回</span>
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>if</span> (cancelled) {
</span></span><span style=display:flex><span>            newSubstream.<span style=color:#a6e22e>stream</span>.<span style=color:#a6e22e>cancel</span>(Status.<span style=color:#a6e22e>CANCELLED</span>.<span style=color:#a6e22e>withDescription</span>(<span style=color:#e6db74>&#34;Unneeded hedging&#34;</span>));
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>          }
</span></span><span style=display:flex><span>          <span style=color:#75715e>// 如果对冲请求不为空，则提交延时任务</span>
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>if</span> (future <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>            future.<span style=color:#a6e22e>setFuture</span>(
</span></span><span style=display:flex><span>                    scheduledExecutorService.<span style=color:#a6e22e>schedule</span>(
</span></span><span style=display:flex><span>                            <span style=color:#66d9ef>new</span> HedgingRunnable(future),
</span></span><span style=display:flex><span>                            hedgingPolicy.<span style=color:#a6e22e>hedgingDelayNanos</span>,
</span></span><span style=display:flex><span>                            TimeUnit.<span style=color:#a6e22e>NANOSECONDS</span>));
</span></span><span style=display:flex><span>          }
</span></span><span style=display:flex><span>          <span style=color:#75715e>// 消耗缓冲的请求</span>
</span></span><span style=display:flex><span>          drain(newSubstream);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>      });
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span></code></pre></div></section><div class=paginator><a class=prev href=https://blog.hellowood.dev/posts/grpc-%E9%87%8D%E8%AF%95%E6%B5%81%E7%A8%8B/><svg class="icon" width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M3.77086 21.1546C11.0491 22.698 21.4339 21.7773 21.4339 16.3608V4.63375c0-.69413-.075800000000001-1.3284-.2422-1.86588M3.77086 21.1546C1.9934 20.7777.973585 18.7264 1.08749 16.688c.17931-3.209.06972-7.25665-.08236-10.47293C.87809 3.52811 3.12891 1.16316 5.51029 1.25008c4.25565.15534 9.86671-.04779 13.28091-.24466 1.2952-.074686 2.0494.62843 2.4005 1.76245M3.77086 21.1546C4.56586 21.4723 5.49168 21.7879 6.5 22.0658M21.1917 2.76787c1.918 1.4143 1.9383 9.65123 1.7087 13.59293-2.0526 7.6586-10.5943 7.3054-16.4004 5.705M21.1917 2.76787C21.7612 4.51192 22.7203 9.67216 22 16.3608 21.2797 23.0494 11.3665 22.9511 6.5 22.0658M9.94496 9C9.28897 9.61644 7.63215 10.997 6.04814 11.7966 5.98257 11.8297 5.98456 11.9753 6.05061 12.0063c1.00435.4716 2.8788 1.9201 3.89435 2.9937M6.44444 11.9667C8.86549 12.0608 14 12 16 11" stroke="currentcolor" stroke-linecap="round"/></svg>
<span>gRPC 重试流程</span></a>
<a class=next href=https://blog.hellowood.dev/posts/grpc-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%81%A5%E5%BA%B7%E6%A3%80%E6%9F%A5/><span>gRPC 自定义健康检查</span><svg class="icon" width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M3.77086 21.1546C11.0491 22.698 21.4339 21.7773 21.4339 16.3608V4.63375c0-.69413-.075800000000001-1.3284-.2422-1.86588M3.77086 21.1546C1.9934 20.7777.973585 18.7264 1.08749 16.688c.17931-3.209.06972-7.25665-.08236-10.47293C.87809 3.52811 3.12891 1.16316 5.51029 1.25008c4.25565.15534 9.86671-.04779 13.28091-.24466 1.2952-.074686 2.0494.62843 2.4005 1.76245M3.77086 21.1546C4.56586 21.4723 5.49168 21.7879 6.5 22.0658M21.1917 2.76787c1.918 1.4143 1.9383 9.65123 1.7087 13.59293-2.0526 7.6586-10.5943 7.3054-16.4004 5.705M21.1917 2.76787C21.7612 4.51192 22.7203 9.67216 22 16.3608 21.2797 23.0494 11.3665 22.9511 6.5 22.0658M12.055 9C12.711 9.61644 14.3679 10.997 15.9519 11.7966 16.0174 11.8297 16.0154 11.9753 15.9494 12.0063 14.945 12.4779 13.0706 13.9264 12.055 15m3.5006-3.0333C13.1345 12.0608 8 12 6 11" stroke="currentcolor" stroke-linecap="round"/></svg></a></div></article></div><footer class=footer><p>&copy; 2024 <a href=https://blog.hellowood.dev/>HelloWood</a>
Powered by
<a href=https://gohugo.io/ rel=noopener target=_blank data-umami-event=to-hugo>Hugo️️</a>
<a href=https://github.com/guangzhengli/hugo-theme-ladder rel=noopener target=_blank data-umami-event=to-ladder>Ladder</a>
️</p></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g data-umami-event=top-link><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M10.5376 22.7916C11.0152 22.7207 22.5795 21.1781 22.0978 10.4211 22.0536 9.43274 21.9303 8.53367 21.7387 7.71865M10.5376 22.7916C16.876 22.3728 20.0969 19.8899 21.5383 16.9142M10.5376 22.7916C9.7707 22.9055 8.97982 22.8964 8.19743 22.7725M21.7387 7.71865C21.4988 6.69828 21.1518 5.80967 20.7188 5.04257m1.0199 2.67608C22.6022 10.1105 23.0542 13.7848 21.5383 16.9142M20.7188 5.04257c-3.5504-6.28886-12.88753-4.410077-16.44303.0C2.88063 6.77451-.0433281 11.1668 1.38159 16.6571c.89322 3.4417 3.7911 5.6365 6.81584 6.1154M20.7188 5.04257c1.3509 1.89783 3.3111 6.34223 1.6353 10.37273M21.5383 16.9142C21.8737 16.4251 22.1428 15.9235 22.3541 15.4153M8.19743 22.7725C12.1971 23.4683 20.6281 22.971 22.3541 15.4153M14 10.945C13.3836 10.289 12.003 8.63215 11.2034 7.04814 11.1703 6.98257 11.0247 6.98456 10.9937 7.05061 10.5221 8.05496 9.07362 9.92941 8 10.945m3.0333-3.50056C10.9392 9.86549 11 15 12 17" stroke="currentcolor" stroke-linecap="round"/></svg>
</a><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const s=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="Copy";function n(){t.innerHTML="Copied",setTimeout(()=>{t.innerHTML="Copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),n();return}const s=document.createRange();s.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(s);try{document.execCommand("copy"),n()}catch{}o.removeRange(s)}),e.parentNode.appendChild(t)})</script></main></body><script src=https://cdnjs.cloudflare.com/ajax/libs/medium-zoom/1.0.6/medium-zoom.min.js integrity="sha512-N9IJRoc3LaP3NDoiGkcPa4gG94kapGpaA5Zq9/Dr04uf5TbLFU5q0o8AbRhLKUUlp8QFS2u7S+Yti0U7QtuZvQ==" crossorigin=anonymous referrerpolicy=no-referrer></script><script>const images=Array.from(document.querySelectorAll(".blog-content img"));images.forEach(e=>{mediumZoom(e,{margin:10,scrollOffset:40,container:null,template:null,background:"rgba(0, 0, 0, 0.5)"})})</script><script src=/main.min.6bb26b69159420159c74dc9e097b06a578ed2b68c701466a91a44a9632d851bd0af167a1b30012387b4c512b48ad9ad4d3394e04d77ae38d57e1920fe4ed34fe.js integrity="sha512-a7JraRWUIBWcdNyeCXsGpXjtK2jHAUZqkaRKljLYUb0K8WehswASOHtMUStIrZrU0zlOBNd6441X4ZIP5O00/g==" crossorigin=anonymous defer></script></html>