<!doctype html><html lang=en><head><meta name=viewport content="width=device-width,initial-scale=1"><title>使用WireGuard连接异地局域网</title><meta charset=utf-8><meta name=description content="Ladder@使用 WireGuard 连接异地局域网 最近使用 Frigate 做家庭监控，因为 Frigate 部署在自己的 HomeLab 服务器里，有几个监控在老家，需要跨地域访问；有以下几种方案：
使用公网映射：将老家的监控映射到公网，但是在公网开放监控并不安全，另外还需要申请公网IP 使用 TailScale 组网：测试过程中发现 TailScale 需要从香港中转，延迟很高，视频经常断开；自己部署 DERP 服务端同样需要在公网开放多个端口，不安全并且比较麻烦 使用 Cloudflare Tunnel 转发：使用 Tunnel 延迟也很高，并不稳定 使用 WireGuard 组网：对端直接连接，延迟低，仅需要开放一个 UDP 端口，较安全 最终选择使用 WireGuard 组网方案，在老家放了一台树莓派4B，用于运行 WireGuard 进行流量转发；HomeLab 服务器部署了一台 LXC 容器运行 WireGuard，用于连接树莓派；开启了局域网转发后，本地的局域网设备可以和老家的局域网设备互相通信
关于 WireGuard 的介绍可以参考 WireGuard
安装配置 WireGuard 安装 wireguard 因为 LXC 容器和树莓派都使用的是 Ubuntu 22.04 的系统，因此直接使用 apt 安装即可
apt update && apt install -y wireguard-tools 生成密钥对 详细操作参考 Key Generation
创建文件夹并修改权限 mkdir wireguard && cd wireguard umask 077 umask 077 的作用是设置系统默认文件和文件夹的权限为只有创建用户拥有全部权限（读、写和执行）"><meta name=author content="HelloWood"><link rel=canonical href=https://blog.hellowood.dev/posts/%E4%BD%BF%E7%94%A8wireguard%E8%BF%9E%E6%8E%A5%E5%BC%82%E5%9C%B0%E5%B1%80%E5%9F%9F%E7%BD%91/><meta name=google-site-verification content="G-3MSGPYTHPZ"><link rel=alternate type=application/rss+xml href=https://blog.hellowood.dev/index.xml title=HelloWood><script async src="https://www.googletagmanager.com/gtag/js?id=G-3MSGPYTHPZ"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-3MSGPYTHPZ",{anonymize_ip:!1})}</script><script async defer data-website-id=7a9034de-0ce7-4756-942a-829e6cd22301 src=https://umami.hellowood.dev/script.js></script><meta property="og:title" content="使用WireGuard连接异地局域网"><meta property="og:description" content="使用 WireGuard 连接异地局域网 最近使用 Frigate 做家庭监控，因为 Frigate 部署在自己的 HomeLab 服务器里，有几个监控在老家，需要跨地域访问；有以下几种方案：
使用公网映射：将老家的监控映射到公网，但是在公网开放监控并不安全，另外还需要申请公网IP 使用 TailScale 组网：测试过程中发现 TailScale 需要从香港中转，延迟很高，视频经常断开；自己部署 DERP 服务端同样需要在公网开放多个端口，不安全并且比较麻烦 使用 Cloudflare Tunnel 转发：使用 Tunnel 延迟也很高，并不稳定 使用 WireGuard 组网：对端直接连接，延迟低，仅需要开放一个 UDP 端口，较安全 最终选择使用 WireGuard 组网方案，在老家放了一台树莓派4B，用于运行 WireGuard 进行流量转发；HomeLab 服务器部署了一台 LXC 容器运行 WireGuard，用于连接树莓派；开启了局域网转发后，本地的局域网设备可以和老家的局域网设备互相通信
关于 WireGuard 的介绍可以参考 WireGuard
安装配置 WireGuard 安装 wireguard 因为 LXC 容器和树莓派都使用的是 Ubuntu 22.04 的系统，因此直接使用 apt 安装即可
apt update && apt install -y wireguard-tools 生成密钥对 详细操作参考 Key Generation
创建文件夹并修改权限 mkdir wireguard && cd wireguard umask 077 umask 077 的作用是设置系统默认文件和文件夹的权限为只有创建用户拥有全部权限（读、写和执行）"><meta property="og:type" content="article"><meta property="og:url" content="https://blog.hellowood.dev/posts/%E4%BD%BF%E7%94%A8wireguard%E8%BF%9E%E6%8E%A5%E5%BC%82%E5%9C%B0%E5%B1%80%E5%9F%9F%E7%BD%91/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-09-24T17:56:49+08:00"><meta property="article:modified_time" content="2023-09-24T17:56:49+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="使用WireGuard连接异地局域网"><meta name=twitter:description content="使用 WireGuard 连接异地局域网 最近使用 Frigate 做家庭监控，因为 Frigate 部署在自己的 HomeLab 服务器里，有几个监控在老家，需要跨地域访问；有以下几种方案：
使用公网映射：将老家的监控映射到公网，但是在公网开放监控并不安全，另外还需要申请公网IP 使用 TailScale 组网：测试过程中发现 TailScale 需要从香港中转，延迟很高，视频经常断开；自己部署 DERP 服务端同样需要在公网开放多个端口，不安全并且比较麻烦 使用 Cloudflare Tunnel 转发：使用 Tunnel 延迟也很高，并不稳定 使用 WireGuard 组网：对端直接连接，延迟低，仅需要开放一个 UDP 端口，较安全 最终选择使用 WireGuard 组网方案，在老家放了一台树莓派4B，用于运行 WireGuard 进行流量转发；HomeLab 服务器部署了一台 LXC 容器运行 WireGuard，用于连接树莓派；开启了局域网转发后，本地的局域网设备可以和老家的局域网设备互相通信
关于 WireGuard 的介绍可以参考 WireGuard
安装配置 WireGuard 安装 wireguard 因为 LXC 容器和树莓派都使用的是 Ubuntu 22.04 的系统，因此直接使用 apt 安装即可
apt update && apt install -y wireguard-tools 生成密钥对 详细操作参考 Key Generation
创建文件夹并修改权限 mkdir wireguard && cd wireguard umask 077 umask 077 的作用是设置系统默认文件和文件夹的权限为只有创建用户拥有全部权限（读、写和执行）"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://blog.hellowood.dev/posts/"},{"@type":"ListItem","position":3,"name":"使用WireGuard连接异地局域网","item":"https://blog.hellowood.dev/posts/%E4%BD%BF%E7%94%A8wireguard%E8%BF%9E%E6%8E%A5%E5%BC%82%E5%9C%B0%E5%B1%80%E5%9F%9F%E7%BD%91/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"使用WireGuard连接异地局域网","name":"使用WireGuard连接异地局域网","description":"使用 WireGuard 连接异地局域网 最近使用 Frigate 做家庭监控，因为 Frigate 部署在自己的 HomeLab 服务器里，有几个监控在老家，需要跨地域访问；有以下几种方案：\n使用公网映射：将老家的监控映射到公网，但是在公网开放监控并不安全，另外还需要申请公网IP 使用 TailScale 组网：测试过程中发现 TailScale 需要从香港中转，延迟很高，视频经常断开；自己部署 DERP 服务端同样需要在公网开放多个端口，不安全并且比较麻烦 使用 Cloudflare Tunnel 转发：使用 Tunnel 延迟也很高，并不稳定 使用 WireGuard 组网：对端直接连接，延迟低，仅需要开放一个 UDP 端口，较安全 最终选择使用 WireGuard 组网方案，在老家放了一台树莓派4B，用于运行 WireGuard 进行流量转发；HomeLab 服务器部署了一台 LXC 容器运行 WireGuard，用于连接树莓派；开启了局域网转发后，本地的局域网设备可以和老家的局域网设备互相通信\n关于 WireGuard 的介绍可以参考 WireGuard\n安装配置 WireGuard 安装 wireguard 因为 LXC 容器和树莓派都使用的是 Ubuntu 22.04 的系统，因此直接使用 apt 安装即可\napt update \u0026amp;\u0026amp; apt install -y wireguard-tools 生成密钥对 详细操作参考 Key Generation\n创建文件夹并修改权限 mkdir wireguard \u0026amp;\u0026amp; cd wireguard umask 077 umask 077 的作用是设置系统默认文件和文件夹的权限为只有创建用户拥有全部权限（读、写和执行）","keywords":["HomeLab","WireGuard"],"articleBody":"使用 WireGuard 连接异地局域网 最近使用 Frigate 做家庭监控，因为 Frigate 部署在自己的 HomeLab 服务器里，有几个监控在老家，需要跨地域访问；有以下几种方案：\n使用公网映射：将老家的监控映射到公网，但是在公网开放监控并不安全，另外还需要申请公网IP 使用 TailScale 组网：测试过程中发现 TailScale 需要从香港中转，延迟很高，视频经常断开；自己部署 DERP 服务端同样需要在公网开放多个端口，不安全并且比较麻烦 使用 Cloudflare Tunnel 转发：使用 Tunnel 延迟也很高，并不稳定 使用 WireGuard 组网：对端直接连接，延迟低，仅需要开放一个 UDP 端口，较安全 最终选择使用 WireGuard 组网方案，在老家放了一台树莓派4B，用于运行 WireGuard 进行流量转发；HomeLab 服务器部署了一台 LXC 容器运行 WireGuard，用于连接树莓派；开启了局域网转发后，本地的局域网设备可以和老家的局域网设备互相通信\n关于 WireGuard 的介绍可以参考 WireGuard\n安装配置 WireGuard 安装 wireguard 因为 LXC 容器和树莓派都使用的是 Ubuntu 22.04 的系统，因此直接使用 apt 安装即可\napt update \u0026\u0026 apt install -y wireguard-tools 生成密钥对 详细操作参考 Key Generation\n创建文件夹并修改权限 mkdir wireguard \u0026\u0026 cd wireguard umask 077 umask 077 的作用是设置系统默认文件和文件夹的权限为只有创建用户拥有全部权限（读、写和执行）\n创建 OpenWrt 密钥对 先创建私钥，然后使用私钥创建公钥\nwg genkey \u003e homelab_private_key wg pubkey \u003c homelab_private_key \u003e homelab_public_key 创建预共享密钥 wg genpsk \u003e pre_share_key 创建对端密钥对 wg genkey \u003e rasp_private_key wg pubkey \u003c rasp_private_key \u003e rasp_public_key 生成 WireGuard 配置文件 使用生成的密钥对修改配置文件，这里使用 10.0.1.0/24 网段作为 WireGuard 的通信网段\nHomeLab 节点的配置文件 HomeLab 的 IP 地址为10.0.1.0，提供用于连接的端口12345暴露在公网，配置文件保存在 /etc/wireguard/wg0.conf\n[Interface] Address = 10.0.1.0/24 ListenPort = 12345 PrivateKey = homelab_private_key的值 MTU = 1450 [Peer] PublicKey = rasp_public_key的值 PresharedKey = pre_share_key的值 AllowedIPs = 10.0.1.1/32 rasp 节点的配置文件 rasp 节点作为 HomeLab 的对端，IP地址为 10.0.1.1启动后连接 HomeLab 节点，配置文件保存在 /etc/wireguard/wg0.conf\n[Interface] Address = 10.0.1.1/32 PrivateKey = rasp_private_key的值 DNS = 223.5.5.5,1.1.1.1 MTU = 1450 [Peer] PublicKey = homelab_public_key的值 PresharedKey = pre_share_key的值 AllowedIPs = 10.0.1.0/24 Endpoint = 公网IP:12345 PersistentKeepalive = 15 启动验证 在 HomeLab 和 Rasp 节点先后使用 wireguard-tools 的命令 wg-quick启动 WireGuard 进行测试验证\n启动 WireGuard wg-quick 指定的接口为 wg0，名称需要与/etc/wireguard/wg0.conf 文件名一致；wg-quick 会自动查找/ect/wireguard/路径下与接口名称一样的配置文件；或者可以在启动命令中指定配置文件地址\nwg-quick up wg0 检查连接状态 wg show 会返回 WireGuard 的连接状态，如果 HomeLab 节点能看到对端的 IP 端口，并且transfer received 有数据传输说明连接成功了，可以使用 ping 进行检测\ninterface: wg0 public key: xxx= private key: (hidden) listening port: 53486 peer: xxx= preshared key: (hidden) endpoint: xxx.xxx.xxx.xxx:12345 allowed ips: 10.0.1.0/24 latest handshake: 1 minute, 19 seconds ago transfer: 535.98 KiB received, 1.07 KiB sent persistent keepalive: every 15 seconds ➜ ~ ping 10.0.1.0 PING 10.0.1.0 (10.0.1.0) 56(84) bytes of data. 64 bytes from 10.0.1.0: icmp_seq=1 ttl=64 time=43.0 ms 64 bytes from 10.0.1.0: icmp_seq=2 ttl=64 time=43.0 ms ^C --- 10.0.1.0 ping statistics --- 2 packets transmitted, 2 received, 0% packet loss, time 1001ms rtt min/avg/max/mdev = 42.979/42.997/43.016/0.018 ms ➜ ~ ping 10.0.1.1 PING 10.0.1.1 (10.0.1.1) 56(84) bytes of data. 64 bytes from 10.0.1.1: icmp_seq=1 ttl=64 time=0.175 ms 64 bytes from 10.0.1.1: icmp_seq=2 ttl=64 time=0.138 ms ^C --- 10.0.1.1 ping statistics --- 2 packets transmitted, 2 received, 0% packet loss, time 1015ms rtt min/avg/max/mdev = 0.138/0.156/0.175/0.018 ms 配置局域网转发 需要在 HomeLab 和 Rasp 节点都开启配置转发，才能访问到对方的局域网设备\n配置允许局域网数据转发 检测是否开启转发 sysctl 是一个用来在系统运作中查看及调整系统参数的工具，-p 用于读取配置文件中的参数值；没有返回信息说明没有开启转发\nsysctl -p 开启转发 需要在 /etc/sysctl.conf 文件中开启数据转发\nvi /etc/sysctl.conf 添加以下内容（如果没有 IPV6 可以只添加 IPV4的配置），保存后实时生效\nnet.ipv4.ip_forward=1 net.ipv6.conf.all.forwarding=1 这两个参数控制着Linux系统是否允许将接收到的IP数据包进行路由转发。当这个参数的值为1时，表示允许IP数据包转发，这通常用于将Linux系统配置成路由器或者网关，允许它将数据包从一个网络接口路由到另一个网络接口\n检查转发配置 再次使用 sysctl -p 检查，配置已经生效，此时设备已经可以将数据转发局域网内的其他设备\nsysctl -p net.ipv4.ip_forward = 1 net.ipv6.conf.all.forwarding = 1 配置 WireGuard 允许转发 添加 iptable 规则 在 wg0.conf 的 [Interface] 中添加 PostUp和 PostDown 配置，用于在 WireGuard 启动后允许设备进行转发，在 WrieGuard 关闭后删除规则\n[Interface] ... PostUp = iptables -A FORWARD -i %i -j ACCEPT; iptables -A FORWARD -o %i -j ACCEPT; iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE PostDown = iptables -D FORWARD -i %i -j ACCEPT; iptables -D FORWARD -o %i -j ACCEPT; iptables -t nat -D POSTROUTING -o eth0 -j MASQUERADE PostUp iptables -A FORWARD -i %i -j ACCEPT: 此命令添加一个规则，允许从接口%i（即wg0）进入的数据包通过防火墙的FORWARD链 iptables -A FORWARD -o %i -j ACCEPT: 此命令添加一个规则，允许从接口%i（即wg0）出去的数据包通过防火墙的FORWARD链 iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE: 此命令添加一个NAT（网络地址转换）规则，将从eth0出去的数据包的源地址修改为设备的地址，以便它们可以正确路由回来。这通常用于创建网络地址转换（NAT）以允许多台内部设备共享单个公共IP地址。\nPostDown iptables -D FORWARD -i %i -j ACCEPT: 此命令删除允许从接口%i（即wg0）进入的数据包通过防火墙的FORWARD链的规则 iptables -D FORWARD -o %i -j ACCEPT: 此命令删除允许从接口%i（即wg0）出去的数据包通过防火墙的FORWARD链的规则 iptables -t nat -D POSTROUTING -o eth0 -j MASQUERADE: 此命令删除之前添加的NAT规则，将从eth0出去的数据包的源地址修改为设备的地址的规则\n添加允许访问的 IP 范围 除了配置转发规则外，还需要添加允许访问的 IP 地址范围，这样对应网段的数据才会通过 WireGuard 进行转发\nHomeLab 需要在 HomeLab 的配置文件的 [Peer] 的 AllowedIPs中，添加 Rasp 所在局域网的网段信息，即192.168.31.0/24\n[Peer] PublicKey = rasp_public_key的值 PresharedKey = pre_share_key的值 AllowedIPs = 10.0.1.1/32,192.168.31.0/24 Rasp 需要在 Rasp 的配置文件的 [Peer] 的 AllowedIPs中，添加 HomeLab 所在局域网的网段信息，即192.168.2.0/24\n[Peer] PublicKey = homelab_public_key的值 PresharedKey = pre_share_key的值 AllowedIPs = 10.0.1.1/32,192.168.2.0/24 Endpoint = 公网IP:12345 PersistentKeepalive = 15 重启 WireGuard 检测 这样，当重启 WireGuard 后，就可以在 HomeLab 或者 Rasp 访问到对方局域网的其他设备了\nwg-quick down wg0 wg-quick up wg0 在 Rasp 上可以 ping 通对方路由的 IP 地址，说明连接成功\nping 192.168.2.1 PING 192.168.2.1 (192.168.2.1) 56(84) bytes of data. 64 bytes from 192.168.2.1: icmp_seq=1 ttl=63 time=43.5 ms ^C --- 192.168.2.1 ping statistics --- 1 packets transmitted, 1 received, 0% packet loss, time 0ms rtt min/avg/max/mdev = 43.548/43.548/43.548/0.000 ms 配置静态路由规则 完成以上步骤后，HomeLab 的 LXC 容器和 Rasp 都可以访问到对方的局域网的设备，但是局域网内的其他设备还无法访问到对方局域网的设备，这是因为没有路由规则，所以需要手动配置静态路由规则\n查看路由规则 在 HomeLab 的容器上检查路由规则，发现 Rasp 所在局域网的流量是由 wg0 接口转发的，但是在其他设备上并没有这个规则，因此其他设备需要知道路由转发规则后才可以访问\nip route default via 192.168.2.1 dev eth0 proto static 10.0.1.0/24 dev wg0 proto kernel scope link src 10.0.1.0 172.17.0.0/16 dev docker0 proto kernel scope link src 172.17.0.1 linkdown 192.168.2.0/24 dev eth0 proto kernel scope link src 192.168.2.5 192.168.31.0/24 dev wg0 scope link OpenWrt 配置路由规则 如果主路由或者网关路由器是 OpenWrt，则可以直接配置静态路由规则\n添加路由规则 在 /etc/rc.local 添加路由规则，在启动后自动执行命令添加路由规则\nvi /etc/rc.local route -n add -net 192.168.31.0 -netmask 255.255.255.0 192.168.2.5 这里将 192.168.31.0/24 网段的数据都转发给了 LXC 容器 192.168.2.5 处理；192.168.2.5 收到数据后会通过 WireGuard 转发给 Rasp，再由 Rasp 将数据转发给对应的设备\n配置防火墙 修改/etc/config/firewall 防火墙策略，允许转发：\nvi /etc/config/firewall config defaults option syn_flood '0' option input 'ACCEPT' option output 'ACCEPT' # REJECT 改为 ACCEPT option forward 'ACCEPT' # 1 改为 0 option drop_invalid '0' option disable_ipv6 '0' config zone option name 'lan' option network 'lan' option input 'ACCEPT' option output 'ACCEPT' #REJECT 改为 ACCEPT option forward 'ACCEPT' 其他设备配置规则 如果路由器不是 OpenWrt，或者不能添加静态路由规则，或者仅需要个别设备访问，可以在设备上直接添加路由规则：\nLinux 设备 ip route add 192.168.31.0/24 via 192.168.2.5 MacOS 设备 sudo route -n add -net 192.168.31.0 -netmask 255.255.255.0 192.168.2.5 完整 WireGuard 配置 HomeLab [Interface] Address = 10.0.1.0/24 ListenPort = 12345 PrivateKey = homelab_private_key PostUp = iptables -A FORWARD -i %i -j ACCEPT; iptables -A FORWARD -o %i -j ACCEPT; iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE PostDown = iptables -D FORWARD -i %i -j ACCEPT; iptables -D FORWARD -o %i -j ACCEPT; iptables -t nat -D POSTROUTING -o eth0 -j MASQUERADE [Peer] PublicKey = rasp_public_key PresharedKey = pre_share_key AllowedIPs = 10.0.1.1/32,192.168.31.0/24 Rasp [Interface] Address = 10.0.1.1/32 PrivateKey = rasp_private_key DNS = 223.5.5.5,1.1.1.1 PostUp = iptables -A FORWARD -i %i -j ACCEPT; iptables -A FORWARD -o %i -j ACCEPT; iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE PostDown = iptables -D FORWARD -i %i -j ACCEPT; iptables -D FORWARD -o %i -j ACCEPT; iptables -t nat -D POSTROUTING -o eth0 -j MASQUERADE [Peer] PublicKey = homelab_public_key PresharedKey = pre_share_key AllowedIPs = 10.0.1.0/24,192.168.2.1/24 Endpoint = 公网IP:12345 PersistentKeepalive = 15 ","wordCount":"944","inLanguage":"en","datePublished":"2023-09-24T17:56:49+08:00","dateModified":"2023-09-24T17:56:49+08:00","author":{"@type":"Person","name":"HelloWood"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.hellowood.dev/posts/%E4%BD%BF%E7%94%A8wireguard%E8%BF%9E%E6%8E%A5%E5%BC%82%E5%9C%B0%E5%B1%80%E5%9F%9F%E7%BD%91/"},"publisher":{"@type":"Organization","name":"HelloWood","logo":{"@type":"ImageObject","url":"https://blog.hellowood.dev/favicon.ico"}}}</script><link rel=icon href=/images/avatar.png sizes=16x16><link rel=apple-touch-icon href=/images/avatar.png><link rel=manifest href=/images/avatar.png><link rel=stylesheet href=https://cdn.staticfile.org/lxgw-wenkai-webfont/1.6.0/style.css><link rel=stylesheet href=/css/main.min.f8020eba33d585b82c30b2a1ceb0d4c4e8e41fb6d8843d07d8ad056da8712972.css integrity="sha256-+AIOujPVhbgsMLKhzrDUxOjkH7bYhD0H2K0FbahxKXI=" crossorigin=anonymous media=screen><link rel=stylesheet href=/scss/highlight/github-dark.min.min.66034289ee9a113219a2c4aae0a8bd2095ab255c832a42efcf5863f10814e7a1.css><script src=/js/highlight.min.min.872dfd2cd00064018a833a6e8e77a0fbf8fbac159546f2f205d4dad79a5d8e15.js></script>
<script>hljs.highlightAll()</script><script>(()=>{var t=window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches,e=localStorage.getItem("theme");t&&e===null&&(localStorage.setItem("theme","dark"),document.documentElement.setAttribute("data-dark-mode","")),t&&e==="dark"&&document.documentElement.setAttribute("data-dark-mode",""),e==="dark"&&document.documentElement.setAttribute("data-dark-mode","")})()</script></head><body><main class=wrapper><nav class=navigation><section class=container><a class=navigation-brand href=/>HOME</a>
<input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><span></span><span></span><span></span></label><ul class=navigation-list id=navigation-list><li class="navigation-item navigation-menu"><a class=navigation-link href=/posts>Blog</a></li><li class="navigation-item navigation-menu"><a class=navigation-link href=/tags>Tags</a></li><li class="navigation-item navigation-menu"><a class=navigation-link href=/archives>Archive</a></li><li class="navigation-item navigation-menu"><a class=navigation-link href=https://umami.hellowood.dev/share/lab/Blog>Dashboard</a></li><li class="navigation-item menu-separator"><span>|</span></li><li class="navigation-item navigation-social"><a class=navigation-link href=https://github.com/helloworlde><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a></li><li class="navigation-item navigation-dark"><button id=mode type=button aria-label="toggle user light or dark theme">
<span class=toggle-dark><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-moon"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg></span><span class=toggle-light><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-sun"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></span></button></li></ul></section></nav><div id=content><article class=blog-single><header class=blog-title><h1>使用WireGuard连接异地局域网</h1></header><p><small>September 24, 2023&nbsp;· 944 words&nbsp;· 5 min</small><p><div class=blog-toc><nav id=TableOfContents><ul><li><a href=#安装配置-wireguard>安装配置 WireGuard</a><ul><li><a href=#安装-wireguard>安装 wireguard</a></li><li><a href=#生成密钥对>生成密钥对</a></li><li><a href=#生成-wireguard-配置文件>生成 WireGuard 配置文件</a></li><li><a href=#启动验证>启动验证</a></li></ul></li><li><a href=#配置局域网转发>配置局域网转发</a><ul><li><a href=#配置允许局域网数据转发>配置允许局域网数据转发</a></li><li><a href=#配置-wireguard-允许转发>配置 WireGuard 允许转发</a></li></ul></li><li><a href=#配置静态路由规则>配置静态路由规则</a><ul><li><a href=#查看路由规则>查看路由规则</a></li><li><a href=#openwrt-配置路由规则>OpenWrt 配置路由规则</a></li><li><a href=#其他设备配置规则>其他设备配置规则</a></li></ul></li><li><a href=#完整-wireguard-配置>完整 WireGuard 配置</a></li></ul></nav></div><section class=blog-content><h1 id=使用-wireguard-连接异地局域网>使用 WireGuard 连接异地局域网</h1><p>最近使用 Frigate 做家庭监控，因为 Frigate 部署在自己的 HomeLab 服务器里，有几个监控在老家，需要跨地域访问；有以下几种方案：</p><ol><li>使用公网映射：将老家的监控映射到公网，但是在公网开放监控并不安全，另外还需要申请公网IP</li><li>使用 TailScale 组网：测试过程中发现 TailScale 需要从香港中转，延迟很高，视频经常断开；自己部署 DERP 服务端同样需要在公网开放多个端口，不安全并且比较麻烦</li><li>使用 Cloudflare Tunnel 转发：使用 Tunnel 延迟也很高，并不稳定</li><li>使用 WireGuard 组网：对端直接连接，延迟低，仅需要开放一个 UDP 端口，较安全</li></ol><p>最终选择使用 WireGuard 组网方案，在老家放了一台树莓派4B，用于运行 WireGuard 进行流量转发；HomeLab 服务器部署了一台 LXC 容器运行 WireGuard，用于连接树莓派；开启了局域网转发后，本地的局域网设备可以和老家的局域网设备互相通信</p><p>关于 WireGuard 的介绍可以参考 <a href=https://www.wireguard.com/>WireGuard</a></p><p><img src=https://hellowoodes.oss-cn-beijing.aliyuncs.com/picture/homelab-wireguard-vpn-for-sub-network.svg alt=homelab-wireguard-vpn-for-sub-network.svg></p><h2 id=安装配置-wireguard>安装配置 WireGuard</h2><h3 id=安装-wireguard>安装 wireguard</h3><p>因为 LXC 容器和树莓派都使用的是 Ubuntu 22.04 的系统，因此直接使用 apt 安装即可</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>apt update <span style=color:#f92672>&amp;&amp;</span> apt install -y wireguard-tools
</span></span></code></pre></div><h3 id=生成密钥对>生成密钥对</h3><p>详细操作参考 <a href=https://www.wireguard.com/quickstart/#key-generation>Key Generation</a></p><ul><li>创建文件夹并修改权限</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>mkdir wireguard <span style=color:#f92672>&amp;&amp;</span> cd wireguard
</span></span><span style=display:flex><span>umask <span style=color:#ae81ff>077</span>
</span></span></code></pre></div><p><code>umask 077</code> 的作用是设置系统默认文件和文件夹的权限为只有创建用户拥有全部权限（读、写和执行）</p><ul><li>创建 OpenWrt 密钥对</li></ul><p>先创建私钥，然后使用私钥创建公钥</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>wg genkey &gt; homelab_private_key
</span></span><span style=display:flex><span>wg pubkey &lt; homelab_private_key &gt; homelab_public_key
</span></span></code></pre></div><ul><li>创建预共享密钥</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>wg genpsk &gt; pre_share_key
</span></span></code></pre></div><ul><li>创建对端密钥对</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>wg genkey &gt; rasp_private_key
</span></span><span style=display:flex><span>wg pubkey &lt; rasp_private_key &gt; rasp_public_key
</span></span></code></pre></div><h3 id=生成-wireguard-配置文件>生成 WireGuard 配置文件</h3><p>使用生成的密钥对修改配置文件，这里使用 <code>10.0.1.0/24</code> 网段作为 WireGuard 的通信网段</p><ul><li>HomeLab 节点的配置文件</li></ul><p>HomeLab 的 IP 地址为<code>10.0.1.0</code>，提供用于连接的端口<code>12345</code>暴露在公网，配置文件保存在 <code>/etc/wireguard/wg0.conf</code></p><pre tabindex=0><code>[Interface]
Address = 10.0.1.0/24
ListenPort = 12345
PrivateKey = homelab_private_key的值
MTU = 1450

[Peer]
PublicKey = rasp_public_key的值
PresharedKey = pre_share_key的值
AllowedIPs = 10.0.1.1/32
</code></pre><ul><li>rasp 节点的配置文件</li></ul><p>rasp 节点作为 HomeLab 的对端，IP地址为 <code>10.0.1.1</code>启动后连接 HomeLab 节点，配置文件保存在 <code>/etc/wireguard/wg0.conf</code></p><pre tabindex=0><code>[Interface]
Address = 10.0.1.1/32
PrivateKey = rasp_private_key的值
DNS = 223.5.5.5,1.1.1.1
MTU = 1450

[Peer]
PublicKey = homelab_public_key的值
PresharedKey = pre_share_key的值
AllowedIPs = 10.0.1.0/24
Endpoint = 公网IP:12345
PersistentKeepalive = 15
</code></pre><h3 id=启动验证>启动验证</h3><p>在 HomeLab 和 Rasp 节点先后使用 wireguard-tools 的命令 <code>wg-quick</code>启动 WireGuard 进行测试验证</p><ul><li>启动 WireGuard</li></ul><p><code>wg-quick</code> 指定的接口为 <code>wg0</code>，名称需要与<code>/etc/wireguard/wg0.conf</code> 文件名一致；<code>wg-quick</code> 会自动查找<code>/ect/wireguard/</code>路径下与接口名称一样的配置文件；或者可以在启动命令中指定配置文件地址</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>wg-quick up wg0
</span></span></code></pre></div><ul><li>检查连接状态</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>wg show
</span></span></code></pre></div><p>会返回 WireGuard 的连接状态，如果 HomeLab 节点能看到对端的 IP 端口，并且transfer received 有数据传输说明连接成功了，可以使用 ping 进行检测</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>interface: wg0
</span></span><span style=display:flex><span>  public key: xxx<span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>  private key: <span style=color:#f92672>(</span>hidden<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>  listening port: <span style=color:#ae81ff>53486</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>peer: xxx<span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>  preshared key: <span style=color:#f92672>(</span>hidden<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>  endpoint: xxx.xxx.xxx.xxx:12345
</span></span><span style=display:flex><span>  allowed ips: 10.0.1.0/24
</span></span><span style=display:flex><span>  latest handshake: <span style=color:#ae81ff>1</span> minute, <span style=color:#ae81ff>19</span> seconds ago
</span></span><span style=display:flex><span>  transfer: 535.98 KiB received, 1.07 KiB sent
</span></span><span style=display:flex><span>  persistent keepalive: every <span style=color:#ae81ff>15</span> seconds
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>➜  ~ ping 10.0.1.0
</span></span><span style=display:flex><span>PING 10.0.1.0 <span style=color:#f92672>(</span>10.0.1.0<span style=color:#f92672>)</span> 56<span style=color:#f92672>(</span>84<span style=color:#f92672>)</span> bytes of data.
</span></span><span style=display:flex><span><span style=color:#ae81ff>64</span> bytes from 10.0.1.0: icmp_seq<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span> ttl<span style=color:#f92672>=</span><span style=color:#ae81ff>64</span> time<span style=color:#f92672>=</span>43.0 ms
</span></span><span style=display:flex><span><span style=color:#ae81ff>64</span> bytes from 10.0.1.0: icmp_seq<span style=color:#f92672>=</span><span style=color:#ae81ff>2</span> ttl<span style=color:#f92672>=</span><span style=color:#ae81ff>64</span> time<span style=color:#f92672>=</span>43.0 ms
</span></span><span style=display:flex><span>^C
</span></span><span style=display:flex><span>--- 10.0.1.0 ping statistics ---
</span></span><span style=display:flex><span><span style=color:#ae81ff>2</span> packets transmitted, <span style=color:#ae81ff>2</span> received, 0% packet loss, time 1001ms
</span></span><span style=display:flex><span>rtt min/avg/max/mdev <span style=color:#f92672>=</span> 42.979/42.997/43.016/0.018 ms
</span></span><span style=display:flex><span>➜  ~ ping 10.0.1.1
</span></span><span style=display:flex><span>PING 10.0.1.1 <span style=color:#f92672>(</span>10.0.1.1<span style=color:#f92672>)</span> 56<span style=color:#f92672>(</span>84<span style=color:#f92672>)</span> bytes of data.
</span></span><span style=display:flex><span><span style=color:#ae81ff>64</span> bytes from 10.0.1.1: icmp_seq<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span> ttl<span style=color:#f92672>=</span><span style=color:#ae81ff>64</span> time<span style=color:#f92672>=</span>0.175 ms
</span></span><span style=display:flex><span><span style=color:#ae81ff>64</span> bytes from 10.0.1.1: icmp_seq<span style=color:#f92672>=</span><span style=color:#ae81ff>2</span> ttl<span style=color:#f92672>=</span><span style=color:#ae81ff>64</span> time<span style=color:#f92672>=</span>0.138 ms
</span></span><span style=display:flex><span>^C
</span></span><span style=display:flex><span>--- 10.0.1.1 ping statistics ---
</span></span><span style=display:flex><span><span style=color:#ae81ff>2</span> packets transmitted, <span style=color:#ae81ff>2</span> received, 0% packet loss, time 1015ms
</span></span><span style=display:flex><span>rtt min/avg/max/mdev <span style=color:#f92672>=</span> 0.138/0.156/0.175/0.018 ms
</span></span></code></pre></div><h2 id=配置局域网转发>配置局域网转发</h2><p>需要在 HomeLab 和 Rasp 节点都开启配置转发，才能访问到对方的局域网设备</p><h3 id=配置允许局域网数据转发>配置允许局域网数据转发</h3><ul><li>检测是否开启转发</li></ul><p><code>sysctl</code> 是一个用来在系统运作中查看及调整系统参数的工具，<code>-p</code> 用于读取配置文件中的参数值；没有返回信息说明没有开启转发</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>sysctl -p
</span></span></code></pre></div><ul><li>开启转发</li></ul><p>需要在 <code>/etc/sysctl.conf</code> 文件中开启数据转发</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>vi /etc/sysctl.conf
</span></span></code></pre></div><p>添加以下内容（如果没有 IPV6 可以只添加 IPV4的配置），保存后实时生效</p><pre tabindex=0><code>net.ipv4.ip_forward=1
net.ipv6.conf.all.forwarding=1
</code></pre><p>这两个参数控制着Linux系统是否允许将接收到的IP数据包进行路由转发。当这个参数的值为1时，表示允许IP数据包转发，这通常用于将Linux系统配置成路由器或者网关，允许它将数据包从一个网络接口路由到另一个网络接口</p><ul><li>检查转发配置</li></ul><p>再次使用 <code>sysctl -p</code> 检查，配置已经生效，此时设备已经可以将数据转发局域网内的其他设备</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>sysctl -p
</span></span><span style=display:flex><span>net.ipv4.ip_forward <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>net.ipv6.conf.all.forwarding <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>
</span></span></code></pre></div><h3 id=配置-wireguard-允许转发>配置 WireGuard 允许转发</h3><h4 id=添加-iptable-规则>添加 iptable 规则</h4><p>在 <code>wg0.conf</code> 的 <code>[Interface]</code> 中添加 <code>PostUp</code>和 <code>PostDown</code> 配置，用于在 WireGuard 启动后允许设备进行转发，在 WrieGuard 关闭后删除规则</p><pre tabindex=0><code>[Interface]
...
PostUp = iptables -A FORWARD -i %i -j ACCEPT; iptables -A FORWARD -o %i -j ACCEPT; iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE
PostDown = iptables -D FORWARD -i %i -j ACCEPT; iptables -D FORWARD -o %i -j ACCEPT; iptables -t nat -D POSTROUTING -o eth0 -j MASQUERADE
</code></pre><ul><li><p>PostUp
<code>iptables -A FORWARD -i %i -j ACCEPT</code>: 此命令添加一个规则，允许从接口<code>%i</code>（即wg0）进入的数据包通过防火墙的FORWARD链
<code>iptables -A FORWARD -o %i -j ACCEPT</code>: 此命令添加一个规则，允许从接口<code>%i</code>（即wg0）出去的数据包通过防火墙的FORWARD链
<code>iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE</code>: 此命令添加一个NAT（网络地址转换）规则，将从eth0出去的数据包的源地址修改为设备的地址，以便它们可以正确路由回来。这通常用于创建网络地址转换（NAT）以允许多台内部设备共享单个公共IP地址。</p></li><li><p>PostDown
<code>iptables -D FORWARD -i %i -j ACCEPT</code>: 此命令删除允许从接口<code>%i</code>（即wg0）进入的数据包通过防火墙的FORWARD链的规则
<code>iptables -D FORWARD -o %i -j ACCEPT</code>: 此命令删除允许从接口<code>%i</code>（即wg0）出去的数据包通过防火墙的FORWARD链的规则
<code>iptables -t nat -D POSTROUTING -o eth0 -j MASQUERADE</code>: 此命令删除之前添加的NAT规则，将从eth0出去的数据包的源地址修改为设备的地址的规则</p></li></ul><h4 id=添加允许访问的-ip-范围>添加允许访问的 IP 范围</h4><p>除了配置转发规则外，还需要添加允许访问的 IP 地址范围，这样对应网段的数据才会通过 WireGuard 进行转发</p><ul><li>HomeLab</li></ul><p>需要在 HomeLab 的配置文件的 <code>[Peer]</code> 的 <code>AllowedIPs</code>中，添加 Rasp 所在局域网的网段信息，即<code>192.168.31.0/24</code></p><pre tabindex=0><code>[Peer]
PublicKey = rasp_public_key的值
PresharedKey = pre_share_key的值
AllowedIPs = 10.0.1.1/32,192.168.31.0/24
</code></pre><ul><li>Rasp</li></ul><p>需要在 Rasp 的配置文件的 <code>[Peer]</code> 的 <code>AllowedIPs</code>中，添加 HomeLab 所在局域网的网段信息，即<code>192.168.2.0/24</code></p><pre tabindex=0><code>[Peer]
PublicKey = homelab_public_key的值
PresharedKey = pre_share_key的值
AllowedIPs = 10.0.1.1/32,192.168.2.0/24
Endpoint = 公网IP:12345
PersistentKeepalive = 15
</code></pre><h4 id=重启-wireguard-检测>重启 WireGuard 检测</h4><p>这样，当重启 WireGuard 后，就可以在 HomeLab 或者 Rasp 访问到对方局域网的其他设备了</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>wg-quick down wg0
</span></span><span style=display:flex><span>wg-quick up wg0
</span></span></code></pre></div><p>在 Rasp 上可以 ping 通对方路由的 IP 地址，说明连接成功</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>ping 192.168.2.1
</span></span><span style=display:flex><span>PING 192.168.2.1 <span style=color:#f92672>(</span>192.168.2.1<span style=color:#f92672>)</span> 56<span style=color:#f92672>(</span>84<span style=color:#f92672>)</span> bytes of data.
</span></span><span style=display:flex><span><span style=color:#ae81ff>64</span> bytes from 192.168.2.1: icmp_seq<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span> ttl<span style=color:#f92672>=</span><span style=color:#ae81ff>63</span> time<span style=color:#f92672>=</span>43.5 ms
</span></span><span style=display:flex><span>^C
</span></span><span style=display:flex><span>--- 192.168.2.1 ping statistics ---
</span></span><span style=display:flex><span><span style=color:#ae81ff>1</span> packets transmitted, <span style=color:#ae81ff>1</span> received, 0% packet loss, time 0ms
</span></span><span style=display:flex><span>rtt min/avg/max/mdev <span style=color:#f92672>=</span> 43.548/43.548/43.548/0.000 ms
</span></span></code></pre></div><h2 id=配置静态路由规则>配置静态路由规则</h2><p>完成以上步骤后，HomeLab 的 LXC 容器和 Rasp 都可以访问到对方的局域网的设备，但是局域网内的其他设备还无法访问到对方局域网的设备，这是因为没有路由规则，所以需要手动配置静态路由规则</p><h3 id=查看路由规则>查看路由规则</h3><p>在 HomeLab 的容器上检查路由规则，发现 Rasp 所在局域网的流量是由 wg0 接口转发的，但是在其他设备上并没有这个规则，因此其他设备需要知道路由转发规则后才可以访问</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>ip route
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>default via 192.168.2.1 dev eth0 proto static
</span></span><span style=display:flex><span>10.0.1.0/24 dev wg0 proto kernel scope link src 10.0.1.0
</span></span><span style=display:flex><span>172.17.0.0/16 dev docker0 proto kernel scope link src 172.17.0.1 linkdown
</span></span><span style=display:flex><span>192.168.2.0/24 dev eth0 proto kernel scope link src 192.168.2.5
</span></span><span style=display:flex><span>192.168.31.0/24 dev wg0 scope link
</span></span></code></pre></div><h3 id=openwrt-配置路由规则>OpenWrt 配置路由规则</h3><p>如果主路由或者网关路由器是 OpenWrt，则可以直接配置静态路由规则</p><ul><li>添加路由规则</li></ul><p>在 <code>/etc/rc.local</code> 添加路由规则，在启动后自动执行命令添加路由规则</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>vi /etc/rc.local
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>route -n add -net 192.168.31.0 -netmask 255.255.255.0 192.168.2.5
</span></span></code></pre></div><p>这里将 <code>192.168.31.0/24</code> 网段的数据都转发给了 LXC 容器 <code>192.168.2.5</code> 处理；<code>192.168.2.5</code> 收到数据后会通过 WireGuard 转发给 Rasp，再由 Rasp 将数据转发给对应的设备</p><ul><li>配置防火墙</li></ul><p>修改<code>/etc/config/firewall</code> 防火墙策略，允许转发：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>vi /etc/config/firewall
</span></span></code></pre></div><pre tabindex=0><code>config defaults
        option syn_flood &#39;0&#39;
        option input &#39;ACCEPT&#39;
        option output &#39;ACCEPT&#39;
        # REJECT 改为 ACCEPT
        option forward &#39;ACCEPT&#39;
        # 1 改为 0
        option drop_invalid &#39;0&#39;
        option disable_ipv6 &#39;0&#39;

config zone
        option name &#39;lan&#39;
        option network &#39;lan&#39;
        option input &#39;ACCEPT&#39;
        option output &#39;ACCEPT&#39;
        #REJECT 改为 ACCEPT        
        option forward &#39;ACCEPT&#39;
</code></pre><h3 id=其他设备配置规则>其他设备配置规则</h3><p>如果路由器不是 OpenWrt，或者不能添加静态路由规则，或者仅需要个别设备访问，可以在设备上直接添加路由规则：</p><ul><li>Linux 设备</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>ip route add 192.168.31.0/24 via 192.168.2.5
</span></span></code></pre></div><ul><li>MacOS 设备</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>sudo route -n add -net 192.168.31.0 -netmask 255.255.255.0 192.168.2.5
</span></span></code></pre></div><h2 id=完整-wireguard-配置>完整 WireGuard 配置</h2><ul><li>HomeLab</li></ul><pre tabindex=0><code>[Interface]
Address = 10.0.1.0/24
ListenPort = 12345
PrivateKey = homelab_private_key
PostUp = iptables -A FORWARD -i %i -j ACCEPT; iptables -A FORWARD -o %i -j ACCEPT; iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE
PostDown = iptables -D FORWARD -i %i -j ACCEPT; iptables -D FORWARD -o %i -j ACCEPT; iptables -t nat -D POSTROUTING -o eth0 -j MASQUERADE

[Peer]
PublicKey = rasp_public_key
PresharedKey = pre_share_key
AllowedIPs = 10.0.1.1/32,192.168.31.0/24
</code></pre><ul><li>Rasp</li></ul><pre tabindex=0><code>[Interface]
Address = 10.0.1.1/32
PrivateKey = rasp_private_key
DNS = 223.5.5.5,1.1.1.1
PostUp = iptables -A FORWARD -i %i -j ACCEPT; iptables -A FORWARD -o %i -j ACCEPT; iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE
PostDown = iptables -D FORWARD -i %i -j ACCEPT; iptables -D FORWARD -o %i -j ACCEPT; iptables -t nat -D POSTROUTING -o eth0 -j MASQUERADE


[Peer]
PublicKey = homelab_public_key
PresharedKey = pre_share_key
AllowedIPs = 10.0.1.0/24,192.168.2.1/24
Endpoint = 公网IP:12345
PersistentKeepalive = 15
</code></pre></section><div class=paginator><a class=next href=https://blog.hellowood.dev/posts/%E4%BD%BF%E7%94%A8docker%E9%83%A8%E7%BD%B2clash-premium/><span>使用 Docker 部署 Clash Premium</span><span>&nbsp;&nbsp;&rarr;</span></a></div></article></div><footer class=footer><p>&copy; 2023 <a href=https://blog.hellowood.dev>HelloWood</a>
Powered by
<a href=https://gohugo.io/ rel=noopener target=_blank>Hugo️️</a>
<a href=https://github.com/guangzhengli/hugo-theme-ladder rel=noopener target=_blank>Ladder</a>
️</p></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-up"><line x1="12" y1="19" x2="12" y2="5"/><polyline points="5 12 12 5 19 12"/></svg></a><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const s=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="Copy";function n(){t.innerHTML="Copied",setTimeout(()=>{t.innerHTML="Copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),n();return}const s=document.createRange();s.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(s);try{document.execCommand("copy"),n()}catch{}o.removeRange(s)}),e.parentNode.appendChild(t)})</script></main></body><script src=https://cdnjs.cloudflare.com/ajax/libs/medium-zoom/1.0.6/medium-zoom.min.js integrity="sha512-N9IJRoc3LaP3NDoiGkcPa4gG94kapGpaA5Zq9/Dr04uf5TbLFU5q0o8AbRhLKUUlp8QFS2u7S+Yti0U7QtuZvQ==" crossorigin=anonymous referrerpolicy=no-referrer></script>
<script>const images=Array.from(document.querySelectorAll(".blog-content img"));images.forEach(e=>{mediumZoom(e,{margin:10,scrollOffset:40,container:null,template:null,background:"rgba(0, 0, 0, 0.5)"})})</script><script src=/main.min.6bb26b69159420159c74dc9e097b06a578ed2b68c701466a91a44a9632d851bd0af167a1b30012387b4c512b48ad9ad4d3394e04d77ae38d57e1920fe4ed34fe.js integrity="sha512-a7JraRWUIBWcdNyeCXsGpXjtK2jHAUZqkaRKljLYUb0K8WehswASOHtMUStIrZrU0zlOBNd6441X4ZIP5O00/g==" crossorigin=anonymous defer></script></html>