<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><style>:root{--accent-color:#FF4D4D}</style><title>使用WireGuard连接异地局域网</title>
<meta name=description content="Copy Paste Worker"><meta name=keywords content='blog,hugo,HomeLab,WireGuard'><meta property="og:url" content="https://blog.hellowood.dev/posts/%E4%BD%BF%E7%94%A8wireguard%E8%BF%9E%E6%8E%A5%E5%BC%82%E5%9C%B0%E5%B1%80%E5%9F%9F%E7%BD%91/"><meta property="og:type" content="website"><meta property="og:title" content="使用WireGuard连接异地局域网"><meta property="og:description" content="Copy Paste Worker"><meta property="og:image" content="https://blog.hellowood.dev/images/avatar.png"><meta property="og:image:secure_url" content="https://blog.hellowood.dev/images/avatar.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:title content="使用WireGuard连接异地局域网"><meta name=twitter:description content="Copy Paste Worker"><meta property="twitter:domain" content="https://blog.hellowood.dev/posts/%E4%BD%BF%E7%94%A8wireguard%E8%BF%9E%E6%8E%A5%E5%BC%82%E5%9C%B0%E5%B1%80%E5%9F%9F%E7%BD%91/"><meta property="twitter:url" content="https://blog.hellowood.dev/posts/%E4%BD%BF%E7%94%A8wireguard%E8%BF%9E%E6%8E%A5%E5%BC%82%E5%9C%B0%E5%B1%80%E5%9F%9F%E7%BD%91/"><meta name=twitter:image content="https://blog.hellowood.dev/images/avatar.png"><link rel=canonical href=https://blog.hellowood.dev/posts/%E4%BD%BF%E7%94%A8wireguard%E8%BF%9E%E6%8E%A5%E5%BC%82%E5%9C%B0%E5%B1%80%E5%9F%9F%E7%BD%91/><link rel=stylesheet type=text/css href=/css/normalize.min.css media=print><link rel=stylesheet type=text/css href=/css/main.min.css><link id=dark-theme rel=stylesheet href=/css/dark.min.css><script src=/js/bundle.min.9a920d7dabdbad8363b6a0a94e29a9dfebdb7ee64cfcb193a0145e512ef2bdab.js integrity="sha256-mpINfavbrYNjtqCpTimp3+vbfuZM/LGToBReUS7yvas="></script><meta name=google-adsense-account content="ca-pub-3401351766168985"><script defer src=https://umami.hellowood.dev/script.js data-website-id=7a9034de-0ce7-4756-942a-829e6cd22301></script><script defer src=https://static.cloudflareinsights.com/beacon.min.js data-cf-beacon='{"token": "b2e481d136dc428c8c96c8673e2a04cf"}'></script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3401351766168985" crossorigin=anonymous></script><script defer src=https://analytics.us.umami.is/script.js data-website-id=73ff1c8c-9938-43cf-81af-e77e26b0cca3></script><script type=text/javascript>(function(e,t,n,s,o,i,a){e[n]=e[n]||function(){(e[n].q=e[n].q||[]).push(arguments)},i=t.createElement(s),i.async=1,i.src="https://www.clarity.ms/tag/"+o,a=t.getElementsByTagName(s)[0],a.parentNode.insertBefore(i,a)})(window,document,"clarity","script","jtbhx98g62")</script></head><body><script>setThemeByUserPref()</script><header class=header><nav class=header-nav><div class=avatar><a href=https://blog.hellowood.dev/><img src=/images/avatar.png alt=avatar></a></div><div class=nav-title><a class=nav-brand href=https://blog.hellowood.dev/>HelloWood</a></div><div class=nav-links><div class=nav-link><a href=https://blog.hellowood.dev/><span data-feather=home></span> Home</a></div><div class=nav-link><a href=https://blog.hellowood.dev/posts/><span data-feather=book></span> Posts</a></div><div class=nav-link><a href=https://blog.hellowood.dev/tags/><span data-feather=tag></span> Tags</a></div><div class=nav-link><a href=https://github.com/helloworlde><span data-feather=github></span></a></div><div class=nav-link><a href=https://umami.hellowood.dev/share/lab/Blog><span data-feather=pie-chart></span></a></div><div class=nav-link><a href=https://blog.hellowood.dev/index.xml><span data-feather=rss></span></a></div><span class=nav-icons-divider></span><div class="nav-link dark-theme-toggle"><span class="sr-only dark-theme-toggle-screen-reader-target"></span>
<a><span class=theme-toggle-icon data-feather=moon></span></a></div><div class=nav-link id=hamburger-menu-toggle><span class="sr-only hamburger-menu-toggle-screen-reader-target">menu</span>
<a><span data-feather=menu></span></a></div><ul class="nav-hamburger-list visibility-hidden"><li class=nav-item><a href=https://blog.hellowood.dev/><span data-feather=home></span> Home</a></li><li class=nav-item><a href=https://blog.hellowood.dev/posts/><span data-feather=book></span> Posts</a></li><li class=nav-item><a href=https://blog.hellowood.dev/tags/><span data-feather=tag></span> Tags</a></li><li class=nav-item><a href=https://github.com/helloworlde><span data-feather=github></span></a></li><li class=nav-item><a href=https://umami.hellowood.dev/share/lab/Blog><span data-feather=pie-chart></span></a></li><li class=nav-item><a href=https://blog.hellowood.dev/index.xml><span data-feather=rss></span></a></li><li class="nav-item dark-theme-toggle"><span class="sr-only dark-theme-toggle-screen-reader-target">theme</span>
<a><span class=theme-toggle-icon data-feather=moon></span></a></li></ul></div></nav></header><main id=content><div class="post container"><div class=post-header-section><h1>使用WireGuard连接异地局域网</h1><small role=doc-subtitle></small><p class=post-date>2023-09-09</p><ul class=post-tags><li class=post-tag><a href=https://blog.hellowood.dev/tags/homelab>HomeLab</a></li><li class=post-tag><a href=https://blog.hellowood.dev/tags/wireguard>WireGuard</a></li></ul></div><div class=post-content><h1 id=使用-wireguard-连接异地局域网>使用 WireGuard 连接异地局域网</h1><p>最近使用 Frigate 做家庭监控，因为 Frigate 部署在自己的 HomeLab 服务器里，有几个监控在老家，需要跨地域访问；有以下几种方案：</p><ol><li>使用公网映射：将老家的监控映射到公网，但是在公网开放监控并不安全，另外还需要申请公网IP</li><li>使用 TailScale 组网：测试过程中发现 TailScale 需要从香港中转，延迟很高，视频经常断开；自己部署 DERP 服务端同样需要在公网开放多个端口，不安全并且比较麻烦</li><li>使用 Cloudflare Tunnel 转发：使用 Tunnel 延迟也很高，并不稳定</li><li>使用 WireGuard 组网：对端直接连接，延迟低，仅需要开放一个 UDP 端口，较安全</li></ol><p>最终选择使用 WireGuard 组网方案，在老家放了一台树莓派4B，用于运行 WireGuard 进行流量转发；HomeLab 服务器部署了一台 LXC 容器运行 WireGuard，用于连接树莓派；开启了局域网转发后，本地的局域网设备可以和老家的局域网设备互相通信</p><blockquote><p>注意：需要对端其中一方有可以直接访问的公网IP</p></blockquote><p>关于 WireGuard 的介绍可以参考 <a href=https://www.wireguard.com/>WireGuard</a></p><p><img src=https://img.hellowood.dev/picture/homelab-wireguard-vpn-for-sub-network.svg alt=homelab-wireguard-vpn-for-sub-network.svg></p><h2 id=安装配置-wireguard>安装配置 WireGuard</h2><h3 id=安装-wireguard>安装 wireguard</h3><p>因为 LXC 容器和树莓派都使用的是 Ubuntu 22.04 的系统，因此直接使用 apt 安装即可</p><div class=highlight><pre tabindex=0 style=color:#b0c4de;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>apt update <span style=color:#c7bf54>&amp;&amp;</span> apt install -y wireguard-tools
</span></span></code></pre></div><h3 id=生成密钥对>生成密钥对</h3><p>详细操作参考 <a href=https://www.wireguard.com/quickstart/#key-generation>Key Generation</a></p><ul><li>创建文件夹并修改权限</li></ul><div class=highlight><pre tabindex=0 style=color:#b0c4de;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>mkdir wireguard <span style=color:#c7bf54>&amp;&amp;</span> <span style=color:#ef8383>cd</span> wireguard
</span></span><span style=display:flex><span><span style=color:#ef8383>umask</span> <span style=color:#d19a66>077</span>
</span></span></code></pre></div><p><code>umask 077</code> 的作用是设置系统默认文件和文件夹的权限为只有创建用户拥有全部权限（读、写和执行）</p><ul><li>创建 OpenWrt 密钥对</li></ul><p>先创建私钥，然后使用私钥创建公钥</p><div class=highlight><pre tabindex=0 style=color:#b0c4de;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>wg genkey &gt; homelab_private_key
</span></span><span style=display:flex><span>wg pubkey &lt; homelab_private_key &gt; homelab_public_key
</span></span></code></pre></div><ul><li>创建预共享密钥</li></ul><div class=highlight><pre tabindex=0 style=color:#b0c4de;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>wg genpsk &gt; pre_share_key
</span></span></code></pre></div><ul><li>创建对端密钥对</li></ul><div class=highlight><pre tabindex=0 style=color:#b0c4de;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>wg genkey &gt; rasp_private_key
</span></span><span style=display:flex><span>wg pubkey &lt; rasp_private_key &gt; rasp_public_key
</span></span></code></pre></div><h3 id=生成-wireguard-配置文件>生成 WireGuard 配置文件</h3><p>使用生成的密钥对修改配置文件，这里使用 <code>10.0.1.0/24</code> 网段作为 WireGuard 的通信网段</p><ul><li>HomeLab 节点的配置文件</li></ul><p>HomeLab 的 IP 地址为<code>10.0.1.0</code>，提供用于连接的端口<code>12345</code>暴露在公网，配置文件保存在 <code>/etc/wireguard/wg0.conf</code></p><pre tabindex=0><code>[Interface]
Address = 10.0.1.0/24
ListenPort = 12345
PrivateKey = homelab_private_key的值
MTU = 1450

[Peer]
PublicKey = rasp_public_key的值
PresharedKey = pre_share_key的值
AllowedIPs = 10.0.1.1/32
</code></pre><ul><li>rasp 节点的配置文件</li></ul><p>rasp 节点作为 HomeLab 的对端，IP地址为 <code>10.0.1.1</code>启动后连接 HomeLab 节点，配置文件保存在 <code>/etc/wireguard/wg0.conf</code></p><pre tabindex=0><code>[Interface]
Address = 10.0.1.1/32
PrivateKey = rasp_private_key的值
DNS = 223.5.5.5,1.1.1.1
MTU = 1450

[Peer]
PublicKey = homelab_public_key的值
PresharedKey = pre_share_key的值
AllowedIPs = 10.0.1.0/24
Endpoint = 公网IP:12345
PersistentKeepalive = 15
</code></pre><h3 id=启动验证>启动验证</h3><p>在 HomeLab 和 Rasp 节点先后使用 wireguard-tools 的命令 <code>wg-quick</code>启动 WireGuard 进行测试验证</p><ul><li>启动 WireGuard</li></ul><p><code>wg-quick</code> 指定的接口为 <code>wg0</code>，名称需要与<code>/etc/wireguard/wg0.conf</code> 文件名一致；<code>wg-quick</code> 会自动查找<code>/ect/wireguard/</code>路径下与接口名称一样的配置文件；或者可以在启动命令中指定配置文件地址</p><div class=highlight><pre tabindex=0 style=color:#b0c4de;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>wg-quick up wg0
</span></span></code></pre></div><ul><li>检查连接状态</li></ul><div class=highlight><pre tabindex=0 style=color:#b0c4de;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>wg show
</span></span></code></pre></div><p>会返回 WireGuard 的连接状态，如果 HomeLab 节点能看到对端的 IP 端口，并且transfer received 有数据传输说明连接成功了，可以使用 ping 进行检测</p><div class=highlight><pre tabindex=0 style=color:#b0c4de;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>interface: wg0
</span></span><span style=display:flex><span>  public key: <span style=color:#dcaeea>xxx</span><span style=color:#c7bf54>=</span>
</span></span><span style=display:flex><span>  private key: <span style=color:#c7bf54>(</span>hidden<span style=color:#c7bf54>)</span>
</span></span><span style=display:flex><span>  listening port: <span style=color:#d19a66>53486</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>peer: <span style=color:#dcaeea>xxx</span><span style=color:#c7bf54>=</span>
</span></span><span style=display:flex><span>  preshared key: <span style=color:#c7bf54>(</span>hidden<span style=color:#c7bf54>)</span>
</span></span><span style=display:flex><span>  endpoint: xxx.xxx.xxx.xxx:12345
</span></span><span style=display:flex><span>  allowed ips: 10.0.1.0/24
</span></span><span style=display:flex><span>  latest handshake: <span style=color:#d19a66>1</span> minute, <span style=color:#d19a66>19</span> seconds ago
</span></span><span style=display:flex><span>  transfer: 535.98 KiB received, 1.07 KiB sent
</span></span><span style=display:flex><span>  persistent keepalive: every <span style=color:#d19a66>15</span> seconds
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#b0c4de;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>➜  ~ ping 10.0.1.0
</span></span><span style=display:flex><span>PING 10.0.1.0 <span style=color:#c7bf54>(</span>10.0.1.0<span style=color:#c7bf54>)</span> 56<span style=color:#c7bf54>(</span>84<span style=color:#c7bf54>)</span> bytes of data.
</span></span><span style=display:flex><span><span style=color:#d19a66>64</span> bytes from 10.0.1.0: <span style=color:#dcaeea>icmp_seq</span><span style=color:#c7bf54>=</span><span style=color:#d19a66>1</span> <span style=color:#dcaeea>ttl</span><span style=color:#c7bf54>=</span><span style=color:#d19a66>64</span> <span style=color:#dcaeea>time</span><span style=color:#c7bf54>=</span>43.0 ms
</span></span><span style=display:flex><span><span style=color:#d19a66>64</span> bytes from 10.0.1.0: <span style=color:#dcaeea>icmp_seq</span><span style=color:#c7bf54>=</span><span style=color:#d19a66>2</span> <span style=color:#dcaeea>ttl</span><span style=color:#c7bf54>=</span><span style=color:#d19a66>64</span> <span style=color:#dcaeea>time</span><span style=color:#c7bf54>=</span>43.0 ms
</span></span><span style=display:flex><span>^C
</span></span><span style=display:flex><span>--- 10.0.1.0 ping statistics ---
</span></span><span style=display:flex><span><span style=color:#d19a66>2</span> packets transmitted, <span style=color:#d19a66>2</span> received, 0% packet loss, <span style=color:#ef8383>time</span> 1001ms
</span></span><span style=display:flex><span>rtt min/avg/max/mdev <span style=color:#c7bf54>=</span> 42.979/42.997/43.016/0.018 ms
</span></span><span style=display:flex><span>➜  ~ ping 10.0.1.1
</span></span><span style=display:flex><span>PING 10.0.1.1 <span style=color:#c7bf54>(</span>10.0.1.1<span style=color:#c7bf54>)</span> 56<span style=color:#c7bf54>(</span>84<span style=color:#c7bf54>)</span> bytes of data.
</span></span><span style=display:flex><span><span style=color:#d19a66>64</span> bytes from 10.0.1.1: <span style=color:#dcaeea>icmp_seq</span><span style=color:#c7bf54>=</span><span style=color:#d19a66>1</span> <span style=color:#dcaeea>ttl</span><span style=color:#c7bf54>=</span><span style=color:#d19a66>64</span> <span style=color:#dcaeea>time</span><span style=color:#c7bf54>=</span>0.175 ms
</span></span><span style=display:flex><span><span style=color:#d19a66>64</span> bytes from 10.0.1.1: <span style=color:#dcaeea>icmp_seq</span><span style=color:#c7bf54>=</span><span style=color:#d19a66>2</span> <span style=color:#dcaeea>ttl</span><span style=color:#c7bf54>=</span><span style=color:#d19a66>64</span> <span style=color:#dcaeea>time</span><span style=color:#c7bf54>=</span>0.138 ms
</span></span><span style=display:flex><span>^C
</span></span><span style=display:flex><span>--- 10.0.1.1 ping statistics ---
</span></span><span style=display:flex><span><span style=color:#d19a66>2</span> packets transmitted, <span style=color:#d19a66>2</span> received, 0% packet loss, <span style=color:#ef8383>time</span> 1015ms
</span></span><span style=display:flex><span>rtt min/avg/max/mdev <span style=color:#c7bf54>=</span> 0.138/0.156/0.175/0.018 ms
</span></span></code></pre></div><h2 id=配置局域网转发>配置局域网转发</h2><p>需要在 HomeLab 和 Rasp 节点都开启配置转发，才能访问到对方的局域网设备</p><h3 id=配置允许局域网数据转发>配置允许局域网数据转发</h3><ul><li>检测是否开启转发</li></ul><p><code>sysctl</code> 是一个用来在系统运作中查看及调整系统参数的工具，<code>-p</code> 用于读取配置文件中的参数值；没有返回信息说明没有开启转发</p><div class=highlight><pre tabindex=0 style=color:#b0c4de;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>sysctl -p
</span></span></code></pre></div><ul><li>开启转发</li></ul><p>需要在 <code>/etc/sysctl.conf</code> 文件中开启数据转发</p><div class=highlight><pre tabindex=0 style=color:#b0c4de;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>vi /etc/sysctl.conf
</span></span></code></pre></div><p>添加以下内容（如果没有 IPV6 可以只添加 IPV4的配置），保存后实时生效</p><pre tabindex=0><code>net.ipv4.ip_forward=1
net.ipv6.conf.all.forwarding=1
</code></pre><p>这两个参数控制着Linux系统是否允许将接收到的IP数据包进行路由转发。当这个参数的值为1时，表示允许IP数据包转发，这通常用于将Linux系统配置成路由器或者网关，允许它将数据包从一个网络接口路由到另一个网络接口</p><ul><li>检查转发配置</li></ul><p>再次使用 <code>sysctl -p</code> 检查，配置已经生效，此时设备已经可以将数据转发局域网内的其他设备</p><div class=highlight><pre tabindex=0 style=color:#b0c4de;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>sysctl -p
</span></span><span style=display:flex><span>net.ipv4.ip_forward <span style=color:#c7bf54>=</span> <span style=color:#d19a66>1</span>
</span></span><span style=display:flex><span>net.ipv6.conf.all.forwarding <span style=color:#c7bf54>=</span> <span style=color:#d19a66>1</span>
</span></span></code></pre></div><h3 id=配置-wireguard-允许转发>配置 WireGuard 允许转发</h3><h4 id=添加-iptable-规则>添加 iptable 规则</h4><p>在 <code>wg0.conf</code> 的 <code>[Interface]</code> 中添加 <code>PostUp</code>和 <code>PostDown</code> 配置，用于在 WireGuard 启动后允许设备进行转发，在 WrieGuard 关闭后删除规则</p><pre tabindex=0><code>[Interface]
...
PostUp = iptables -A FORWARD -i %i -j ACCEPT; iptables -A FORWARD -o %i -j ACCEPT; iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE
PostDown = iptables -D FORWARD -i %i -j ACCEPT; iptables -D FORWARD -o %i -j ACCEPT; iptables -t nat -D POSTROUTING -o eth0 -j MASQUERADE
</code></pre><ul><li><p>PostUp
<code>iptables -A FORWARD -i %i -j ACCEPT</code>: 此命令添加一个规则，允许从接口<code>%i</code>（即wg0）进入的数据包通过防火墙的FORWARD链
<code>iptables -A FORWARD -o %i -j ACCEPT</code>: 此命令添加一个规则，允许从接口<code>%i</code>（即wg0）出去的数据包通过防火墙的FORWARD链
<code>iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE</code>: 此命令添加一个NAT（网络地址转换）规则，将从eth0出去的数据包的源地址修改为设备的地址，以便它们可以正确路由回来。这通常用于创建网络地址转换（NAT）以允许多台内部设备共享单个公共IP地址。</p></li><li><p>PostDown
<code>iptables -D FORWARD -i %i -j ACCEPT</code>: 此命令删除允许从接口<code>%i</code>（即wg0）进入的数据包通过防火墙的FORWARD链的规则
<code>iptables -D FORWARD -o %i -j ACCEPT</code>: 此命令删除允许从接口<code>%i</code>（即wg0）出去的数据包通过防火墙的FORWARD链的规则
<code>iptables -t nat -D POSTROUTING -o eth0 -j MASQUERADE</code>: 此命令删除之前添加的NAT规则，将从eth0出去的数据包的源地址修改为设备的地址的规则</p></li></ul><h4 id=添加允许访问的-ip-范围>添加允许访问的 IP 范围</h4><p>除了配置转发规则外，还需要添加允许访问的 IP 地址范围，这样对应网段的数据才会通过 WireGuard 进行转发</p><ul><li>HomeLab</li></ul><p>需要在 HomeLab 的配置文件的 <code>[Peer]</code> 的 <code>AllowedIPs</code>中，添加 Rasp 所在局域网的网段信息，即<code>192.168.31.0/24</code></p><pre tabindex=0><code>[Peer]
PublicKey = rasp_public_key的值
PresharedKey = pre_share_key的值
AllowedIPs = 10.0.1.1/32,192.168.31.0/24
</code></pre><ul><li>Rasp</li></ul><p>需要在 Rasp 的配置文件的 <code>[Peer]</code> 的 <code>AllowedIPs</code>中，添加 HomeLab 所在局域网的网段信息，即<code>192.168.2.0/24</code></p><pre tabindex=0><code>[Peer]
PublicKey = homelab_public_key的值
PresharedKey = pre_share_key的值
AllowedIPs = 10.0.1.1/32,192.168.2.0/24
Endpoint = 公网IP:12345
PersistentKeepalive = 15
</code></pre><h4 id=重启-wireguard-检测>重启 WireGuard 检测</h4><p>这样，当重启 WireGuard 后，就可以在 HomeLab 或者 Rasp 访问到对方局域网的其他设备了</p><div class=highlight><pre tabindex=0 style=color:#b0c4de;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>wg-quick down wg0
</span></span><span style=display:flex><span>wg-quick up wg0
</span></span></code></pre></div><p>在 Rasp 上可以 ping 通对方路由的 IP 地址，说明连接成功</p><div class=highlight><pre tabindex=0 style=color:#b0c4de;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>ping 192.168.2.1
</span></span><span style=display:flex><span>PING 192.168.2.1 <span style=color:#c7bf54>(</span>192.168.2.1<span style=color:#c7bf54>)</span> 56<span style=color:#c7bf54>(</span>84<span style=color:#c7bf54>)</span> bytes of data.
</span></span><span style=display:flex><span><span style=color:#d19a66>64</span> bytes from 192.168.2.1: <span style=color:#dcaeea>icmp_seq</span><span style=color:#c7bf54>=</span><span style=color:#d19a66>1</span> <span style=color:#dcaeea>ttl</span><span style=color:#c7bf54>=</span><span style=color:#d19a66>63</span> <span style=color:#dcaeea>time</span><span style=color:#c7bf54>=</span>43.5 ms
</span></span><span style=display:flex><span>^C
</span></span><span style=display:flex><span>--- 192.168.2.1 ping statistics ---
</span></span><span style=display:flex><span><span style=color:#d19a66>1</span> packets transmitted, <span style=color:#d19a66>1</span> received, 0% packet loss, <span style=color:#ef8383>time</span> 0ms
</span></span><span style=display:flex><span>rtt min/avg/max/mdev <span style=color:#c7bf54>=</span> 43.548/43.548/43.548/0.000 ms
</span></span></code></pre></div><h2 id=配置静态路由规则>配置静态路由规则</h2><p>完成以上步骤后，HomeLab 的 LXC 容器和 Rasp 都可以访问到对方的局域网的设备，但是局域网内的其他设备还无法访问到对方局域网的设备，这是因为没有路由规则，所以需要手动配置静态路由规则</p><h3 id=查看路由规则>查看路由规则</h3><p>在 HomeLab 的容器上检查路由规则，发现 Rasp 所在局域网的流量是由 wg0 接口转发的，但是在其他设备上并没有这个规则，因此其他设备需要知道路由转发规则后才可以访问</p><div class=highlight><pre tabindex=0 style=color:#b0c4de;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>ip route
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#b0c4de;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>default via 192.168.2.1 dev eth0 proto static
</span></span><span style=display:flex><span>10.0.1.0/24 dev wg0 proto kernel scope link src 10.0.1.0
</span></span><span style=display:flex><span>172.17.0.0/16 dev docker0 proto kernel scope link src 172.17.0.1 linkdown
</span></span><span style=display:flex><span>192.168.2.0/24 dev eth0 proto kernel scope link src 192.168.2.5
</span></span><span style=display:flex><span>192.168.31.0/24 dev wg0 scope link
</span></span></code></pre></div><h3 id=openwrt-配置路由规则>OpenWrt 配置路由规则</h3><p>如果主路由或者网关路由器是 OpenWrt，则可以直接配置静态路由规则</p><ul><li>添加路由规则</li></ul><p>在 <code>/etc/rc.local</code> 添加路由规则，在启动后自动执行命令添加路由规则</p><div class=highlight><pre tabindex=0 style=color:#b0c4de;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>vi /etc/rc.local
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#b0c4de;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>route -n add -net 192.168.31.0 -netmask 255.255.255.0 192.168.2.5
</span></span></code></pre></div><p>这里将 <code>192.168.31.0/24</code> 网段的数据都转发给了 LXC 容器 <code>192.168.2.5</code> 处理；<code>192.168.2.5</code> 收到数据后会通过 WireGuard 转发给 Rasp，再由 Rasp 将数据转发给对应的设备</p><ul><li>配置防火墙</li></ul><p>修改<code>/etc/config/firewall</code> 防火墙策略，允许转发：</p><div class=highlight><pre tabindex=0 style=color:#b0c4de;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>vi /etc/config/firewall
</span></span></code></pre></div><pre tabindex=0><code>config defaults
        option syn_flood &#39;0&#39;
        option input &#39;ACCEPT&#39;
        option output &#39;ACCEPT&#39;
        # REJECT 改为 ACCEPT
        option forward &#39;ACCEPT&#39;
        # 1 改为 0
        option drop_invalid &#39;0&#39;
        option disable_ipv6 &#39;0&#39;

config zone
        option name &#39;lan&#39;
        option network &#39;lan&#39;
        option input &#39;ACCEPT&#39;
        option output &#39;ACCEPT&#39;
        #REJECT 改为 ACCEPT        
        option forward &#39;ACCEPT&#39;
</code></pre><h3 id=其他设备配置规则>其他设备配置规则</h3><p>如果路由器不是 OpenWrt，或者不能添加静态路由规则，或者仅需要个别设备访问，可以在设备上直接添加路由规则：</p><ul><li>Linux 设备</li></ul><div class=highlight><pre tabindex=0 style=color:#b0c4de;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>ip route add 192.168.31.0/24 via 192.168.2.5
</span></span></code></pre></div><ul><li>MacOS 设备</li></ul><div class=highlight><pre tabindex=0 style=color:#b0c4de;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>sudo route -n add -net 192.168.31.0 -netmask 255.255.255.0 192.168.2.5
</span></span></code></pre></div><h2 id=完整-wireguard-配置>完整 WireGuard 配置</h2><ul><li>HomeLab</li></ul><pre tabindex=0><code>[Interface]
Address = 10.0.1.0/24
ListenPort = 12345
PrivateKey = homelab_private_key
PostUp = iptables -A FORWARD -i %i -j ACCEPT; iptables -A FORWARD -o %i -j ACCEPT; iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE
PostDown = iptables -D FORWARD -i %i -j ACCEPT; iptables -D FORWARD -o %i -j ACCEPT; iptables -t nat -D POSTROUTING -o eth0 -j MASQUERADE

[Peer]
PublicKey = rasp_public_key
PresharedKey = pre_share_key
AllowedIPs = 10.0.1.1/32,192.168.31.0/24
</code></pre><ul><li>Rasp</li></ul><pre tabindex=0><code>[Interface]
Address = 10.0.1.1/32
PrivateKey = rasp_private_key
DNS = 223.5.5.5,1.1.1.1
PostUp = iptables -A FORWARD -i %i -j ACCEPT; iptables -A FORWARD -o %i -j ACCEPT; iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE
PostDown = iptables -D FORWARD -i %i -j ACCEPT; iptables -D FORWARD -o %i -j ACCEPT; iptables -t nat -D POSTROUTING -o eth0 -j MASQUERADE


[Peer]
PublicKey = homelab_public_key
PresharedKey = pre_share_key
AllowedIPs = 10.0.1.0/24,192.168.2.1/24
Endpoint = 公网IP:12345
PersistentKeepalive = 15
</code></pre></div><div class=prev-next></div><svg id="btt-button" class="arrow-logo" height="1em" viewBox="0 0 384 512" onclick="scrollToTop()" title="Go to top"><path d="M177 159.7l136 136c9.4 9.4 9.4 24.6.0 33.9l-22.6 22.6c-9.4 9.4-24.6 9.4-33.9.0L160 255.9l-96.4 96.4c-9.4 9.4-24.6 9.4-33.9.0L7 329.7c-9.4-9.4-9.4-24.6.0-33.9l136-136c9.4-9.5 24.6-9.5 34-.1z"/></svg>
<script>let backToTopButton=document.getElementById("btt-button");window.onscroll=function(){scrollFunction()};function scrollFunction(){document.body.scrollTop>20||document.documentElement.scrollTop>20?backToTopButton.style.display="block":backToTopButton.style.display="none"}function scrollToTop(){window.scrollTo(0,0)}</script><div id=comments><script src=https://utteranc.es/client.js repo=helloworlde/helloworlde.github.io issue-term=title theme=github-dark crossorigin=anonymous async></script></div></div></main><footer class=footer><span>&copy; 2024 hellowood.dev</span>
<span>Made with &#10084;&#65039; using <a target=_blank href=https://github.com/526avijitgupta/gokarna>Gokarna</a></span></footer></body></html>