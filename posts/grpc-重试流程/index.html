<!doctype html><html lang=en><head><meta name=viewport content="width=device-width,initial-scale=1"><title>gRPC 重试流程</title>
<meta charset=utf-8><meta name=description content='Ladder@gRPC 重试流程
当第一次调用失败，流监听器关闭的时候，会根据请求的处理状态和方法的配置，判断是否需要重试
请求的处理状态有三种，在io.grpc.internal.ClientStreamListener.RpcProgress中定义：

PROCESSED: 请求被正常处理，按照返回的状态码决定是否要重试
REFUSED: 没有被服务端的应用逻辑层处理，直接重试，不计入重试次数
DROPPED:  请求被负载均衡丢弃了，不重试，如果是对冲则取消其他的对冲请求，直接提交

发起请求

io.grpc.stub.ClientCalls#blockingUnaryCall



io.grpc.internal.ClientCallImpl#startInternal



io.grpc.internal.ManagedChannelImpl.ChannelTransportProvider#newRetriableStream



io.grpc.internal.RetriableStream#start



io.grpc.internal.RetriableStream#createSubstream



io.grpc.internal.ManagedChannelImpl.ChannelTransportProvider#newRetriableStream#RetryStream#newSubstream



通过生成的代码中的方法，调用 io.grpc.stub.ClientCalls#blockingUnaryCall

首先通过 channel 创建ClientCall，然后通过 futureUnaryCall 提交请求，返回 Future，根据返回的 Future 循环等待，通过executor.waitAndDrain()执行请求，直到 Future 完成，返回结果
 public static <ReqT, RespT> RespT blockingUnaryCall(Channel channel,
                                                      MethodDescriptor<ReqT, RespT> method,
                                                      CallOptions callOptions,
                                                      ReqT req) {
    // 创建新的调用的 ClientCall，指定了调用类型和执行器
    ClientCall<ReqT, RespT> call = channel.newCall(method, callOptions.withOption(ClientCalls.STUB_TYPE_OPTION, StubType.BLOCKING)
                                                                      .withExecutor(executor));
    try {
      // 执行调用，发出请求
      ListenableFuture<RespT> responseFuture = futureUnaryCall(call, req);
      while (!responseFuture.isDone()) {
        try {
	      // 执行提交的 Runnable 
          executor.waitAndDrain();
        } catch (InterruptedException e) {
          interrupt = true;
          call.cancel("Thread interrupted", e);
        }
      }
      return getUnchecked(responseFuture);
    }
  }

执行 unary 调用 futureUnaryCall

这里创建了 Future，通过 asyncUnaryRequestCall 继续调用'><meta name=author content="HelloWood"><link rel=canonical href=https://blog.hellowood.dev/posts/grpc-%E9%87%8D%E8%AF%95%E6%B5%81%E7%A8%8B/><meta name=google-site-verification content="G-3MSGPYTHPZ"><link rel=alternate type=application/rss+xml href=https://blog.hellowood.dev//index.xml title=HelloWood><script async src="https://www.googletagmanager.com/gtag/js?id=G-3MSGPYTHPZ"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-3MSGPYTHPZ")}</script><script async defer data-website-id=7a9034de-0ce7-4756-942a-829e6cd22301 src=https://umami.hellowood.dev/script.js></script><script defer data-cf-beacon='{"token": "b2e481d136dc428c8c96c8673e2a04cf"}' src=https://static.cloudflareinsights.com/beacon.min.js></script><meta property="og:url" content="https://blog.hellowood.dev/posts/grpc-%E9%87%8D%E8%AF%95%E6%B5%81%E7%A8%8B/"><meta property="og:site_name" content="HelloWood"><meta property="og:title" content="gRPC 重试流程"><meta property="og:description" content='gRPC 重试流程 当第一次调用失败，流监听器关闭的时候，会根据请求的处理状态和方法的配置，判断是否需要重试
请求的处理状态有三种，在io.grpc.internal.ClientStreamListener.RpcProgress中定义：
PROCESSED: 请求被正常处理，按照返回的状态码决定是否要重试 REFUSED: 没有被服务端的应用逻辑层处理，直接重试，不计入重试次数 DROPPED: 请求被负载均衡丢弃了，不重试，如果是对冲则取消其他的对冲请求，直接提交 发起请求 io.grpc.stub.ClientCalls#blockingUnaryCall io.grpc.internal.ClientCallImpl#startInternal io.grpc.internal.ManagedChannelImpl.ChannelTransportProvider#newRetriableStream io.grpc.internal.RetriableStream#start io.grpc.internal.RetriableStream#createSubstream io.grpc.internal.ManagedChannelImpl.ChannelTransportProvider#newRetriableStream#RetryStream#newSubstream 通过生成的代码中的方法，调用 io.grpc.stub.ClientCalls#blockingUnaryCall 首先通过 channel 创建ClientCall，然后通过 futureUnaryCall 提交请求，返回 Future，根据返回的 Future 循环等待，通过executor.waitAndDrain()执行请求，直到 Future 完成，返回结果
public static <ReqT, RespT> RespT blockingUnaryCall(Channel channel, MethodDescriptor<ReqT, RespT> method, CallOptions callOptions, ReqT req) { // 创建新的调用的 ClientCall，指定了调用类型和执行器 ClientCall<ReqT, RespT> call = channel.newCall(method, callOptions.withOption(ClientCalls.STUB_TYPE_OPTION, StubType.BLOCKING) .withExecutor(executor)); try { // 执行调用，发出请求 ListenableFuture<RespT> responseFuture = futureUnaryCall(call, req); while (!responseFuture.isDone()) { try { // 执行提交的 Runnable executor.waitAndDrain(); } catch (InterruptedException e) { interrupt = true; call.cancel("Thread interrupted", e); } } return getUnchecked(responseFuture); } } 执行 unary 调用 futureUnaryCall 这里创建了 Future，通过 asyncUnaryRequestCall 继续调用'><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-09-20T22:40:07+00:00"><meta property="article:modified_time" content="2020-09-20T22:40:07+00:00"><meta property="article:tag" content="GRPC"><meta name=twitter:card content="summary"><meta name=twitter:title content="gRPC 重试流程"><meta name=twitter:description content='gRPC 重试流程 当第一次调用失败，流监听器关闭的时候，会根据请求的处理状态和方法的配置，判断是否需要重试
请求的处理状态有三种，在io.grpc.internal.ClientStreamListener.RpcProgress中定义：
PROCESSED: 请求被正常处理，按照返回的状态码决定是否要重试 REFUSED: 没有被服务端的应用逻辑层处理，直接重试，不计入重试次数 DROPPED: 请求被负载均衡丢弃了，不重试，如果是对冲则取消其他的对冲请求，直接提交 发起请求 io.grpc.stub.ClientCalls#blockingUnaryCall io.grpc.internal.ClientCallImpl#startInternal io.grpc.internal.ManagedChannelImpl.ChannelTransportProvider#newRetriableStream io.grpc.internal.RetriableStream#start io.grpc.internal.RetriableStream#createSubstream io.grpc.internal.ManagedChannelImpl.ChannelTransportProvider#newRetriableStream#RetryStream#newSubstream 通过生成的代码中的方法，调用 io.grpc.stub.ClientCalls#blockingUnaryCall 首先通过 channel 创建ClientCall，然后通过 futureUnaryCall 提交请求，返回 Future，根据返回的 Future 循环等待，通过executor.waitAndDrain()执行请求，直到 Future 完成，返回结果
public static <ReqT, RespT> RespT blockingUnaryCall(Channel channel, MethodDescriptor<ReqT, RespT> method, CallOptions callOptions, ReqT req) { // 创建新的调用的 ClientCall，指定了调用类型和执行器 ClientCall<ReqT, RespT> call = channel.newCall(method, callOptions.withOption(ClientCalls.STUB_TYPE_OPTION, StubType.BLOCKING) .withExecutor(executor)); try { // 执行调用，发出请求 ListenableFuture<RespT> responseFuture = futureUnaryCall(call, req); while (!responseFuture.isDone()) { try { // 执行提交的 Runnable executor.waitAndDrain(); } catch (InterruptedException e) { interrupt = true; call.cancel("Thread interrupted", e); } } return getUnchecked(responseFuture); } } 执行 unary 调用 futureUnaryCall 这里创建了 Future，通过 asyncUnaryRequestCall 继续调用'><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.hellowood.dev/posts/"},{"@type":"ListItem","position":2,"name":"gRPC 重试流程","item":"https://blog.hellowood.dev/posts/grpc-%E9%87%8D%E8%AF%95%E6%B5%81%E7%A8%8B/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"gRPC 重试流程","name":"gRPC 重试流程","description":"gRPC 重试流程 当第一次调用失败，流监听器关闭的时候，会根据请求的处理状态和方法的配置，判断是否需要重试\n请求的处理状态有三种，在io.grpc.internal.ClientStreamListener.RpcProgress中定义：\nPROCESSED: 请求被正常处理，按照返回的状态码决定是否要重试 REFUSED: 没有被服务端的应用逻辑层处理，直接重试，不计入重试次数 DROPPED: 请求被负载均衡丢弃了，不重试，如果是对冲则取消其他的对冲请求，直接提交 发起请求 io.grpc.stub.ClientCalls#blockingUnaryCall io.grpc.internal.ClientCallImpl#startInternal io.grpc.internal.ManagedChannelImpl.ChannelTransportProvider#newRetriableStream io.grpc.internal.RetriableStream#start io.grpc.internal.RetriableStream#createSubstream io.grpc.internal.ManagedChannelImpl.ChannelTransportProvider#newRetriableStream#RetryStream#newSubstream 通过生成的代码中的方法，调用 io.grpc.stub.ClientCalls#blockingUnaryCall 首先通过 channel 创建ClientCall，然后通过 futureUnaryCall 提交请求，返回 Future，根据返回的 Future 循环等待，通过executor.waitAndDrain()执行请求，直到 Future 完成，返回结果\npublic static \u0026lt;ReqT, RespT\u0026gt; RespT blockingUnaryCall(Channel channel, MethodDescriptor\u0026lt;ReqT, RespT\u0026gt; method, CallOptions callOptions, ReqT req) { // 创建新的调用的 ClientCall，指定了调用类型和执行器 ClientCall\u0026lt;ReqT, RespT\u0026gt; call = channel.newCall(method, callOptions.withOption(ClientCalls.STUB_TYPE_OPTION, StubType.BLOCKING) .withExecutor(executor)); try { // 执行调用，发出请求 ListenableFuture\u0026lt;RespT\u0026gt; responseFuture = futureUnaryCall(call, req); while (!responseFuture.isDone()) { try { // 执行提交的 Runnable executor.waitAndDrain(); } catch (InterruptedException e) { interrupt = true; call.cancel(\u0026#34;Thread interrupted\u0026#34;, e); } } return getUnchecked(responseFuture); } } 执行 unary 调用 futureUnaryCall 这里创建了 Future，通过 asyncUnaryRequestCall 继续调用\n","keywords":["gRPC"],"articleBody":"gRPC 重试流程 当第一次调用失败，流监听器关闭的时候，会根据请求的处理状态和方法的配置，判断是否需要重试\n请求的处理状态有三种，在io.grpc.internal.ClientStreamListener.RpcProgress中定义：\nPROCESSED: 请求被正常处理，按照返回的状态码决定是否要重试 REFUSED: 没有被服务端的应用逻辑层处理，直接重试，不计入重试次数 DROPPED: 请求被负载均衡丢弃了，不重试，如果是对冲则取消其他的对冲请求，直接提交 发起请求 io.grpc.stub.ClientCalls#blockingUnaryCall io.grpc.internal.ClientCallImpl#startInternal io.grpc.internal.ManagedChannelImpl.ChannelTransportProvider#newRetriableStream io.grpc.internal.RetriableStream#start io.grpc.internal.RetriableStream#createSubstream io.grpc.internal.ManagedChannelImpl.ChannelTransportProvider#newRetriableStream#RetryStream#newSubstream 通过生成的代码中的方法，调用 io.grpc.stub.ClientCalls#blockingUnaryCall 首先通过 channel 创建ClientCall，然后通过 futureUnaryCall 提交请求，返回 Future，根据返回的 Future 循环等待，通过executor.waitAndDrain()执行请求，直到 Future 完成，返回结果\npublic static \u003cReqT, RespT\u003e RespT blockingUnaryCall(Channel channel, MethodDescriptor\u003cReqT, RespT\u003e method, CallOptions callOptions, ReqT req) { // 创建新的调用的 ClientCall，指定了调用类型和执行器 ClientCall\u003cReqT, RespT\u003e call = channel.newCall(method, callOptions.withOption(ClientCalls.STUB_TYPE_OPTION, StubType.BLOCKING) .withExecutor(executor)); try { // 执行调用，发出请求 ListenableFuture\u003cRespT\u003e responseFuture = futureUnaryCall(call, req); while (!responseFuture.isDone()) { try { // 执行提交的 Runnable executor.waitAndDrain(); } catch (InterruptedException e) { interrupt = true; call.cancel(\"Thread interrupted\", e); } } return getUnchecked(responseFuture); } } 执行 unary 调用 futureUnaryCall 这里创建了 Future，通过 asyncUnaryRequestCall 继续调用\npublic static \u003cReqT, RespT\u003e ListenableFuture\u003cRespT\u003e futureUnaryCall(ClientCall\u003cReqT, RespT\u003e call, ReqT req) { // 初始化 GrpcFuture GrpcFuture\u003cRespT\u003e responseFuture = new GrpcFuture\u003c\u003e(call); // 将 GrpcFuture 包装为继承了 Listener 的 UnaryStreamToFuture，提交任务 asyncUnaryRequestCall(call, req, new UnaryStreamToFuture\u003c\u003e(responseFuture)); return responseFuture; } 异步调用 执行调用，发送消息\nprivate static \u003cReqT, RespT\u003e void asyncUnaryRequestCall(ClientCall\u003cReqT, RespT\u003e call, ReqT req, StartableListener\u003cRespT\u003e responseListener) { // 开始调用 startCall(call, responseListener); try { // 发送消息 call.sendMessage(req); // 半关闭连接 call.halfClose(); } } 开始一次调用，通过 responseListener 处理返回响应 开始调用，并启动响应监听器\nprivate static \u003cReqT, RespT\u003e void startCall(ClientCall\u003cReqT, RespT\u003e call, StartableListener\u003cRespT\u003e responseListener) { call.start(responseListener, new Metadata()); responseListener.onStart(); } 执行请求调用 private void startInternal(final Listener\u003cRespT\u003e observer, Metadata headers) { checkState(stream == null, \"Already started\"); checkState(!cancelCalled, \"call was cancelled\"); checkNotNull(observer, \"observer\"); checkNotNull(headers, \"headers\"); // 如果已经取消了，则不创建流，通知监听器取消回调 if (context.isCancelled()) { stream = NoopClientStream.INSTANCE; executeCloseObserverInContext(observer, statusFromCancelled(context)); return; } // 压缩器 final String compressorName = callOptions.getCompressor(); Compressor compressor; if (compressorName != null) { compressor = compressorRegistry.lookupCompressor(compressorName); // 如果设置了压缩器名称，但是没有相应的压缩器，则返回错误，关闭监听器 if (compressor == null) { stream = NoopClientStream.INSTANCE; Status status = Status.INTERNAL.withDescription(String.format(\"Unable to find compressor by name %s\", compressorName)); executeCloseObserverInContext(observer, status); return; } } else { compressor = Codec.Identity.NONE; } // 根据参数添加 Header prepareHeaders(headers, decompressorRegistry, compressor, fullStreamDecompression); // 最后期限 Deadline effectiveDeadline = effectiveDeadline(); boolean deadlineExceeded = effectiveDeadline != null \u0026\u0026 effectiveDeadline.isExpired(); // 如果没有过期 if (!deadlineExceeded) { // 如果打开了重试，则创建重试流 if (retryEnabled) { stream = clientTransportProvider.newRetriableStream(method, callOptions, headers, context); } else { // 根据获取 ClientTransport ClientTransport transport = clientTransportProvider.get(new PickSubchannelArgsImpl(method, headers, callOptions)); Context origContext = context.attach(); try { // 创建流 stream = transport.newStream(method, headers, callOptions); } finally { context.detach(origContext); } } } else { // 初始化超时失败的流 stream = new FailingClientStream(DEADLINE_EXCEEDED.withDescription(\"ClientCall started after deadline exceeded: \" + effectiveDeadline)); } // 直接执行器 if (callExecutorIsDirect) { stream.optimizeForDirectExecutor(); } // 调用地址 if (callOptions.getAuthority() != null) { stream.setAuthority(callOptions.getAuthority()); } // 最大传入字节数 if (callOptions.getMaxInboundMessageSize() != null) { stream.setMaxInboundMessageSize(callOptions.getMaxInboundMessageSize()); } // 最大传出字节数 if (callOptions.getMaxOutboundMessageSize() != null) { stream.setMaxOutboundMessageSize(callOptions.getMaxOutboundMessageSize()); } // 最后执行时间 if (effectiveDeadline != null) { stream.setDeadline(effectiveDeadline); } // 压缩器 stream.setCompressor(compressor); // 解压缩流 if (fullStreamDecompression) { stream.setFullStreamDecompression(fullStreamDecompression); } // 解压流注册器 stream.setDecompressorRegistry(decompressorRegistry); // 记录开始调用 channelCallsTracer.reportCallStarted(); // 封装支持取消的流监听器 cancellationListener = new ContextCancellationListener(observer); // 初始化支持 header 操作的 ClientStreamListener // 调用 start 方法，修改流的状态 stream.start(new ClientStreamListenerImpl(observer)); // 稍后将上下文取消传播到被调用端 context.addListener(cancellationListener, directExecutor()); if (effectiveDeadline != null // 如果上下文具有有效的截止日期，则无需安排额外的任务 \u0026\u0026 !effectiveDeadline.equals(context.getDeadline()) // 如果 channel 已终止，则无需安排额外的任务 \u0026\u0026 deadlineCancellationExecutor != null // 如果截止时间已经到期，请让失败的流处理 \u0026\u0026 !(stream instanceof FailingClientStream)) { // 提交任务，并返回回调 deadlineCancellationNotifyApplicationFuture = startDeadlineNotifyApplicationTimer(effectiveDeadline, observer); } // 移除 context 和监听器 if (cancelListenersShouldBeRemoved) { removeContextListenerAndCancelDeadlineFuture(); } } 计算下次请求时间间隔 下次重试请求的时间间隔不固定，由 initialBackoffNanos,backoffMultiplier, maxBackoffNanos 和随机数共同决定\n第一次的延时 第一次延时是 初始延时 initialBackoffNanos 乘以随机数\n在获得了第一次延时之后，会计算下一次延时；下一次延时是前一次延时 nextBackoffIntervalNanos乘以退避指数 backoffMultiplier，与最大延时 maxBackoffNanos比较，取最小的，然后再乘以随机数\nnextBackoffIntervalNanos = retryPolicy.initialBackoffNanos backoffNanos = (long) (nextBackoffIntervalNanos * random.nextDouble()) 下一次延时 在获得了第一次延时之后，会计算下一次延时；下一次延时是前一次延时 nextBackoffIntervalNanos乘以退避指数 backoffMultiplier，与最大延时 maxBackoffNanos比较，取最小的，然后再乘以随机数\n// 计算下一次延时 nextBackoffIntervalNanos = Math.min((long) (nextBackoffIntervalNanos * retryPolicy.backoffMultiplier), retryPolicy.maxBackoffNanos); backoffNanos = (long) (nextBackoffIntervalNanos * random.nextDouble()) ","wordCount":"512","inLanguage":"en","datePublished":"2020-09-20T22:40:07Z","dateModified":"2020-09-20T22:40:07Z","author":{"@type":"Person","name":"HelloWood"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.hellowood.dev/posts/grpc-%E9%87%8D%E8%AF%95%E6%B5%81%E7%A8%8B/"},"publisher":{"@type":"Organization","name":"HelloWood","logo":{"@type":"ImageObject","url":"https://blog.hellowood.dev/favicon.ico"}}}</script><link rel=icon href=/images/avatar.png sizes=16x16><link rel=apple-touch-icon href=/images/avatar.png><link rel=manifest href=/images/avatar.png><link rel=stylesheet href=https://cdn.staticfile.org/lxgw-wenkai-webfont/1.6.0/style.css><link rel=stylesheet href=/css/main.min.7f82854fa0e999ec07c4835d3029de9f484030e254b80d470b3ca48eb934720e.css integrity="sha256-f4KFT6DpmewHxINdMCnen0hAMOJUuA1HCzykjrk0cg4=" crossorigin=anonymous media=screen><link rel=stylesheet href=/scss/highlight/github-dark.min.min.66034289ee9a113219a2c4aae0a8bd2095ab255c832a42efcf5863f10814e7a1.css><script src=/js/highlight.min.min.c607d6febd16934a82eb61d3a896ed9d869f54373cc63ce95864ed5488fe3128.js></script><script>hljs.highlightAll()</script><script>(()=>{var t=window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches,e=localStorage.getItem("theme");t&&e===null&&(localStorage.setItem("theme","dark"),document.documentElement.setAttribute("data-dark-mode","")),t&&e==="dark"&&document.documentElement.setAttribute("data-dark-mode",""),e==="dark"&&document.documentElement.setAttribute("data-dark-mode","")})()</script><meta name=google-adsense-account content="ca-pub-3401351766168985"><script type=text/javascript>(function(e,t,n,s,o,i,a){e[n]=e[n]||function(){(e[n].q=e[n].q||[]).push(arguments)},i=t.createElement(s),i.async=1,i.src="https://www.clarity.ms/tag/"+o,a=t.getElementsByTagName(s)[0],a.parentNode.insertBefore(i,a)})(window,document,"clarity","script","jtbhx98g62")</script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3401351766168985" crossorigin=anonymous></script><script defer src=https://analytics.us.umami.is/script.js data-website-id=73ff1c8c-9938-43cf-81af-e77e26b0cca3></script></head><body><main class=wrapper><nav class=navigation><section class=container><a class=navigation-brand data-umami-event=navigation-brand href=/>HOME
</a><input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><span></span><span></span><span></span></label><ul class=navigation-list id=navigation-list><li class="navigation-item navigation-menu"><a class=navigation-link data-umami-event=Blog href=/posts>Blog</a></li><li class="navigation-item navigation-menu"><a class=navigation-link data-umami-event=Tags href=/tags>Tags</a></li><li class="navigation-item navigation-menu"><a class=navigation-link data-umami-event=Archive href=/archives>Archive</a></li><li class="navigation-item navigation-menu"><a class=navigation-link data-umami-event=Dashboard href=https://umami.hellowood.dev/share/lab/Blog>Dashboard</a></li><li class="navigation-item menu-separator"><span>|</span></li><li class="navigation-item navigation-social"><a class=navigation-link data-umami-event=navigation-social href=https://github.com/helloworlde><svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a></li><li class="navigation-item navigation-dark"><button id=mode type=button data-umami-event=toggle-theme aria-label="toggle user light or dark theme">
<span class=toggle-dark><svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-moon"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg></span>
<span class=toggle-light><svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-sun"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></span></button></li></ul></section></nav><div id=content><article class=blog-single><header class=blog-title><h1>gRPC 重试流程</h1></header><p><small>September 20, 2020&nbsp;· 512 words&nbsp;· 3 min</small><p><div class=blog-toc><nav id=TableOfContents><ul><li><a href=#发起请求>发起请求</a><ul><li></li></ul></li></ul></nav></div><section class=blog-content><h1 id=grpc-重试流程>gRPC 重试流程</h1><p>当第一次调用失败，流监听器关闭的时候，会根据请求的处理状态和方法的配置，判断是否需要重试</p><p>请求的处理状态有三种，在<code>io.grpc.internal.ClientStreamListener.RpcProgress</code>中定义：</p><ul><li><code>PROCESSED</code>: 请求被正常处理，按照返回的状态码决定是否要重试</li><li><code>REFUSED</code>: 没有被服务端的应用逻辑层处理，直接重试，不计入重试次数</li><li><code>DROPPED</code>: 请求被负载均衡丢弃了，不重试，如果是对冲则取消其他的对冲请求，直接提交</li></ul><h2 id=发起请求>发起请求</h2><ul><li>io.grpc.stub.ClientCalls#blockingUnaryCall</li></ul><p><img alt=grpc-java-blockingUnaryCall-diagram.png src=https://img.hellowood.dev/picture/grpc-java-blockingUnaryCall-diagram.png></p><ul><li>io.grpc.internal.ClientCallImpl#startInternal</li></ul><p><img alt=grpc-java-client-call-start.png src=https://img.hellowood.dev/picture/grpc-java-client-call-start.png></p><ul><li>io.grpc.internal.ManagedChannelImpl.ChannelTransportProvider#newRetriableStream</li></ul><p><img alt=grpc-java-transport-provider-new-retriable-stream.png src=https://img.hellowood.dev/picture/grpc-java-transport-provider-new-retriable-stream.png></p><ul><li>io.grpc.internal.RetriableStream#start</li></ul><p><img alt=grpc-java-retriable-stream-start.png src=https://img.hellowood.dev/picture/grpc-java-retriable-stream-start.png></p><ul><li>io.grpc.internal.RetriableStream#createSubstream</li></ul><p><img alt=grpc-java-retriable-stream-create-sub-stream.png src=https://img.hellowood.dev/picture/grpc-java-retriable-stream-create-sub-stream.png></p><ul><li>io.grpc.internal.ManagedChannelImpl.ChannelTransportProvider#newRetriableStream#RetryStream#newSubstream</li></ul><p><img alt=grpc-java-retriable-stream-new-sub-stream.png src=https://img.hellowood.dev/picture/grpc-java-retriable-stream-new-sub-stream.png></p><ol><li>通过生成的代码中的方法，调用 <code>io.grpc.stub.ClientCalls#blockingUnaryCall</code></li></ol><p>首先通过 channel 创建<code>ClientCall</code>，然后通过 <code>futureUnaryCall</code> 提交请求，返回 Future，根据返回的 Future 循环等待，通过<code>executor.waitAndDrain()</code>执行请求，直到 Future 完成，返回结果</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span> <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#f92672>&lt;</span>ReqT, RespT<span style=color:#f92672>&gt;</span> RespT <span style=color:#a6e22e>blockingUnaryCall</span>(Channel channel,
</span></span><span style=display:flex><span>                                                      MethodDescriptor<span style=color:#f92672>&lt;</span>ReqT, RespT<span style=color:#f92672>&gt;</span> method,
</span></span><span style=display:flex><span>                                                      CallOptions callOptions,
</span></span><span style=display:flex><span>                                                      ReqT req) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 创建新的调用的 ClientCall，指定了调用类型和执行器</span>
</span></span><span style=display:flex><span>    ClientCall<span style=color:#f92672>&lt;</span>ReqT, RespT<span style=color:#f92672>&gt;</span> call <span style=color:#f92672>=</span> channel.<span style=color:#a6e22e>newCall</span>(method, callOptions.<span style=color:#a6e22e>withOption</span>(ClientCalls.<span style=color:#a6e22e>STUB_TYPE_OPTION</span>, StubType.<span style=color:#a6e22e>BLOCKING</span>)
</span></span><span style=display:flex><span>                                                                      .<span style=color:#a6e22e>withExecutor</span>(executor));
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>      <span style=color:#75715e>// 执行调用，发出请求</span>
</span></span><span style=display:flex><span>      ListenableFuture<span style=color:#f92672>&lt;</span>RespT<span style=color:#f92672>&gt;</span> responseFuture <span style=color:#f92672>=</span> futureUnaryCall(call, req);
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>while</span> (<span style=color:#f92672>!</span>responseFuture.<span style=color:#a6e22e>isDone</span>()) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>	      <span style=color:#75715e>// 执行提交的 Runnable </span>
</span></span><span style=display:flex><span>          executor.<span style=color:#a6e22e>waitAndDrain</span>();
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>catch</span> (InterruptedException e) {
</span></span><span style=display:flex><span>          interrupt <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>          call.<span style=color:#a6e22e>cancel</span>(<span style=color:#e6db74>&#34;Thread interrupted&#34;</span>, e);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>return</span> getUnchecked(responseFuture);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span></code></pre></div><ol start=2><li>执行 unary 调用 <code>futureUnaryCall</code></li></ol><p>这里创建了 Future，通过 <code>asyncUnaryRequestCall</code> 继续调用</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>  <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#f92672>&lt;</span>ReqT, RespT<span style=color:#f92672>&gt;</span> ListenableFuture<span style=color:#f92672>&lt;</span>RespT<span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>futureUnaryCall</span>(ClientCall<span style=color:#f92672>&lt;</span>ReqT, RespT<span style=color:#f92672>&gt;</span> call, ReqT req) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 初始化 GrpcFuture</span>
</span></span><span style=display:flex><span>    GrpcFuture<span style=color:#f92672>&lt;</span>RespT<span style=color:#f92672>&gt;</span> responseFuture <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> GrpcFuture<span style=color:#f92672>&lt;&gt;</span>(call);
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 将 GrpcFuture 包装为继承了 Listener 的 UnaryStreamToFuture，提交任务</span>
</span></span><span style=display:flex><span>    asyncUnaryRequestCall(call, req, <span style=color:#66d9ef>new</span> UnaryStreamToFuture<span style=color:#f92672>&lt;&gt;</span>(responseFuture));
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> responseFuture;
</span></span><span style=display:flex><span>  }
</span></span></code></pre></div><ol start=3><li>异步调用</li></ol><p>执行调用，发送消息</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>  <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#f92672>&lt;</span>ReqT, RespT<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>asyncUnaryRequestCall</span>(ClientCall<span style=color:#f92672>&lt;</span>ReqT, RespT<span style=color:#f92672>&gt;</span> call,
</span></span><span style=display:flex><span>                                                          ReqT req,
</span></span><span style=display:flex><span>                                                          StartableListener<span style=color:#f92672>&lt;</span>RespT<span style=color:#f92672>&gt;</span> responseListener) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 开始调用</span>
</span></span><span style=display:flex><span>    startCall(call, responseListener);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>      <span style=color:#75715e>// 发送消息</span>
</span></span><span style=display:flex><span>      call.<span style=color:#a6e22e>sendMessage</span>(req);
</span></span><span style=display:flex><span>      <span style=color:#75715e>// 半关闭连接</span>
</span></span><span style=display:flex><span>      call.<span style=color:#a6e22e>halfClose</span>();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span></code></pre></div><ol start=4><li>开始一次调用，通过 responseListener 处理返回响应</li></ol><p>开始调用，并启动响应监听器</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>  <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#f92672>&lt;</span>ReqT, RespT<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>startCall</span>(ClientCall<span style=color:#f92672>&lt;</span>ReqT, RespT<span style=color:#f92672>&gt;</span> call,
</span></span><span style=display:flex><span>                                              StartableListener<span style=color:#f92672>&lt;</span>RespT<span style=color:#f92672>&gt;</span> responseListener) {
</span></span><span style=display:flex><span>    call.<span style=color:#a6e22e>start</span>(responseListener, <span style=color:#66d9ef>new</span> Metadata());
</span></span><span style=display:flex><span>    responseListener.<span style=color:#a6e22e>onStart</span>();
</span></span><span style=display:flex><span>  }
</span></span></code></pre></div><ol start=5><li>执行请求调用</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>  <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>startInternal</span>(<span style=color:#66d9ef>final</span> Listener<span style=color:#f92672>&lt;</span>RespT<span style=color:#f92672>&gt;</span> observer, Metadata headers) {
</span></span><span style=display:flex><span>    checkState(stream <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>, <span style=color:#e6db74>&#34;Already started&#34;</span>);
</span></span><span style=display:flex><span>    checkState(<span style=color:#f92672>!</span>cancelCalled, <span style=color:#e6db74>&#34;call was cancelled&#34;</span>);
</span></span><span style=display:flex><span>    checkNotNull(observer, <span style=color:#e6db74>&#34;observer&#34;</span>);
</span></span><span style=display:flex><span>    checkNotNull(headers, <span style=color:#e6db74>&#34;headers&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 如果已经取消了，则不创建流，通知监听器取消回调</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (context.<span style=color:#a6e22e>isCancelled</span>()) {
</span></span><span style=display:flex><span>      stream <span style=color:#f92672>=</span> NoopClientStream.<span style=color:#a6e22e>INSTANCE</span>;
</span></span><span style=display:flex><span>      executeCloseObserverInContext(observer, statusFromCancelled(context));
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 压缩器</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>final</span> String compressorName <span style=color:#f92672>=</span> callOptions.<span style=color:#a6e22e>getCompressor</span>();
</span></span><span style=display:flex><span>    Compressor compressor;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (compressorName <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>      compressor <span style=color:#f92672>=</span> compressorRegistry.<span style=color:#a6e22e>lookupCompressor</span>(compressorName);
</span></span><span style=display:flex><span>      <span style=color:#75715e>// 如果设置了压缩器名称，但是没有相应的压缩器，则返回错误，关闭监听器</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> (compressor <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>        stream <span style=color:#f92672>=</span> NoopClientStream.<span style=color:#a6e22e>INSTANCE</span>;
</span></span><span style=display:flex><span>        Status status <span style=color:#f92672>=</span> Status.<span style=color:#a6e22e>INTERNAL</span>.<span style=color:#a6e22e>withDescription</span>(String.<span style=color:#a6e22e>format</span>(<span style=color:#e6db74>&#34;Unable to find compressor by name %s&#34;</span>, compressorName));
</span></span><span style=display:flex><span>        executeCloseObserverInContext(observer, status);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>      compressor <span style=color:#f92672>=</span> Codec.<span style=color:#a6e22e>Identity</span>.<span style=color:#a6e22e>NONE</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 根据参数添加 Header</span>
</span></span><span style=display:flex><span>    prepareHeaders(headers, decompressorRegistry, compressor, fullStreamDecompression);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 最后期限</span>
</span></span><span style=display:flex><span>    Deadline effectiveDeadline <span style=color:#f92672>=</span> effectiveDeadline();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>boolean</span> deadlineExceeded <span style=color:#f92672>=</span> effectiveDeadline <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span> <span style=color:#f92672>&amp;&amp;</span> effectiveDeadline.<span style=color:#a6e22e>isExpired</span>();
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 如果没有过期</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>deadlineExceeded) {
</span></span><span style=display:flex><span>      <span style=color:#75715e>// 如果打开了重试，则创建重试流</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> (retryEnabled) {
</span></span><span style=display:flex><span>        stream <span style=color:#f92672>=</span> clientTransportProvider.<span style=color:#a6e22e>newRetriableStream</span>(method, callOptions, headers, context);
</span></span><span style=display:flex><span>      } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 根据获取 ClientTransport</span>
</span></span><span style=display:flex><span>        ClientTransport transport <span style=color:#f92672>=</span> clientTransportProvider.<span style=color:#a6e22e>get</span>(<span style=color:#66d9ef>new</span> PickSubchannelArgsImpl(method, headers, callOptions));
</span></span><span style=display:flex><span>        Context origContext <span style=color:#f92672>=</span> context.<span style=color:#a6e22e>attach</span>();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>          <span style=color:#75715e>// 创建流</span>
</span></span><span style=display:flex><span>          stream <span style=color:#f92672>=</span> transport.<span style=color:#a6e22e>newStream</span>(method, headers, callOptions);
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>finally</span> {
</span></span><span style=display:flex><span>          context.<span style=color:#a6e22e>detach</span>(origContext);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>      <span style=color:#75715e>// 初始化超时失败的流</span>
</span></span><span style=display:flex><span>      stream <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> FailingClientStream(DEADLINE_EXCEEDED.<span style=color:#a6e22e>withDescription</span>(<span style=color:#e6db74>&#34;ClientCall started after deadline exceeded: &#34;</span> <span style=color:#f92672>+</span> effectiveDeadline));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 直接执行器</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (callExecutorIsDirect) {
</span></span><span style=display:flex><span>      stream.<span style=color:#a6e22e>optimizeForDirectExecutor</span>();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 调用地址</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (callOptions.<span style=color:#a6e22e>getAuthority</span>() <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>      stream.<span style=color:#a6e22e>setAuthority</span>(callOptions.<span style=color:#a6e22e>getAuthority</span>());
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 最大传入字节数</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (callOptions.<span style=color:#a6e22e>getMaxInboundMessageSize</span>() <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>      stream.<span style=color:#a6e22e>setMaxInboundMessageSize</span>(callOptions.<span style=color:#a6e22e>getMaxInboundMessageSize</span>());
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 最大传出字节数</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (callOptions.<span style=color:#a6e22e>getMaxOutboundMessageSize</span>() <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>      stream.<span style=color:#a6e22e>setMaxOutboundMessageSize</span>(callOptions.<span style=color:#a6e22e>getMaxOutboundMessageSize</span>());
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 最后执行时间</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (effectiveDeadline <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>      stream.<span style=color:#a6e22e>setDeadline</span>(effectiveDeadline);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 压缩器</span>
</span></span><span style=display:flex><span>    stream.<span style=color:#a6e22e>setCompressor</span>(compressor);
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 解压缩流</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (fullStreamDecompression) {
</span></span><span style=display:flex><span>      stream.<span style=color:#a6e22e>setFullStreamDecompression</span>(fullStreamDecompression);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 解压流注册器</span>
</span></span><span style=display:flex><span>    stream.<span style=color:#a6e22e>setDecompressorRegistry</span>(decompressorRegistry);
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 记录开始调用</span>
</span></span><span style=display:flex><span>    channelCallsTracer.<span style=color:#a6e22e>reportCallStarted</span>();
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 封装支持取消的流监听器</span>
</span></span><span style=display:flex><span>    cancellationListener <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ContextCancellationListener(observer);
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 初始化支持 header 操作的 ClientStreamListener</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 调用 start 方法，修改流的状态</span>
</span></span><span style=display:flex><span>    stream.<span style=color:#a6e22e>start</span>(<span style=color:#66d9ef>new</span> ClientStreamListenerImpl(observer));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 稍后将上下文取消传播到被调用端</span>
</span></span><span style=display:flex><span>    context.<span style=color:#a6e22e>addListener</span>(cancellationListener, directExecutor());
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (effectiveDeadline <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 如果上下文具有有效的截止日期，则无需安排额外的任务</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>&amp;&amp;</span> <span style=color:#f92672>!</span>effectiveDeadline.<span style=color:#a6e22e>equals</span>(context.<span style=color:#a6e22e>getDeadline</span>())
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 如果 channel 已终止，则无需安排额外的任务</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>&amp;&amp;</span> deadlineCancellationExecutor <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 如果截止时间已经到期，请让失败的流处理</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>&amp;&amp;</span> <span style=color:#f92672>!</span>(stream <span style=color:#66d9ef>instanceof</span> FailingClientStream)) {
</span></span><span style=display:flex><span>      <span style=color:#75715e>// 提交任务，并返回回调</span>
</span></span><span style=display:flex><span>      deadlineCancellationNotifyApplicationFuture <span style=color:#f92672>=</span> startDeadlineNotifyApplicationTimer(effectiveDeadline, observer);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 移除 context 和监听器</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (cancelListenersShouldBeRemoved) {
</span></span><span style=display:flex><span>      removeContextListenerAndCancelDeadlineFuture();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span></code></pre></div><h4 id=计算下次请求时间间隔>计算下次请求时间间隔</h4><p>下次重试请求的时间间隔不固定，由 <code>initialBackoffNanos</code>,<code>backoffMultiplier</code>, <code>maxBackoffNanos</code> 和随机数共同决定</p><ul><li>第一次的延时</li></ul><p>第一次延时是 初始延时 <code>initialBackoffNanos</code> 乘以随机数</p><p>在获得了第一次延时之后，会计算下一次延时；下一次延时是前一次延时 <code>nextBackoffIntervalNanos</code>乘以退避指数 <code>backoffMultiplier</code>，与最大延时 <code>maxBackoffNanos</code>比较，取最小的，然后再乘以随机数</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>nextBackoffIntervalNanos <span style=color:#f92672>=</span> retryPolicy.<span style=color:#a6e22e>initialBackoffNanos</span>
</span></span><span style=display:flex><span>backoffNanos <span style=color:#f92672>=</span> (<span style=color:#66d9ef>long</span>) (nextBackoffIntervalNanos <span style=color:#f92672>*</span> random.<span style=color:#a6e22e>nextDouble</span>())
</span></span></code></pre></div><ul><li>下一次延时</li></ul><p>在获得了第一次延时之后，会计算下一次延时；下一次延时是前一次延时 <code>nextBackoffIntervalNanos</code>乘以退避指数 <code>backoffMultiplier</code>，与最大延时 <code>maxBackoffNanos</code>比较，取最小的，然后再乘以随机数</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// 计算下一次延时</span>
</span></span><span style=display:flex><span>nextBackoffIntervalNanos <span style=color:#f92672>=</span> Math.<span style=color:#a6e22e>min</span>((<span style=color:#66d9ef>long</span>) (nextBackoffIntervalNanos <span style=color:#f92672>*</span> retryPolicy.<span style=color:#a6e22e>backoffMultiplier</span>), retryPolicy.<span style=color:#a6e22e>maxBackoffNanos</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>backoffNanos <span style=color:#f92672>=</span> (<span style=color:#66d9ef>long</span>) (nextBackoffIntervalNanos <span style=color:#f92672>*</span> random.<span style=color:#a6e22e>nextDouble</span>())
</span></span></code></pre></div></section><div class=paginator><a class=prev href=https://blog.hellowood.dev/posts/grpc-%E4%B8%AD%E7%9A%84%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/><svg class="icon" width="24" height="24" viewBox="0 0 24 24" fill="none"><path d="M3.77086 21.1546C11.0491 22.698 21.4339 21.7773 21.4339 16.3608V4.63375c0-.69413-.075800000000001-1.3284-.2422-1.86588M3.77086 21.1546C1.9934 20.7777.973585 18.7264 1.08749 16.688c.17931-3.209.06972-7.25665-.08236-10.47293C.87809 3.52811 3.12891 1.16316 5.51029 1.25008c4.25565.15534 9.86671-.04779 13.28091-.24466 1.2952-.074686 2.0494.62843 2.4005 1.76245M3.77086 21.1546C4.56586 21.4723 5.49168 21.7879 6.5 22.0658M21.1917 2.76787c1.918 1.4143 1.9383 9.65123 1.7087 13.59293-2.0526 7.6586-10.5943 7.3054-16.4004 5.705M21.1917 2.76787C21.7612 4.51192 22.7203 9.67216 22 16.3608 21.2797 23.0494 11.3665 22.9511 6.5 22.0658M9.94496 9C9.28897 9.61644 7.63215 10.997 6.04814 11.7966 5.98257 11.8297 5.98456 11.9753 6.05061 12.0063c1.00435.4716 2.8788 1.9201 3.89435 2.9937M6.44444 11.9667C8.86549 12.0608 14 12 16 11" stroke="currentcolor" stroke-linecap="round"/></svg>
<span>gRPC 中的核心概念</span></a>
<a class=next href=https://blog.hellowood.dev/posts/grpc-%E5%AF%B9%E5%86%B2%E5%8E%9F%E7%90%86/><span>gRPC 对冲原理</span><svg class="icon" width="24" height="24" viewBox="0 0 24 24" fill="none"><path d="M3.77086 21.1546C11.0491 22.698 21.4339 21.7773 21.4339 16.3608V4.63375c0-.69413-.075800000000001-1.3284-.2422-1.86588M3.77086 21.1546C1.9934 20.7777.973585 18.7264 1.08749 16.688c.17931-3.209.06972-7.25665-.08236-10.47293C.87809 3.52811 3.12891 1.16316 5.51029 1.25008c4.25565.15534 9.86671-.04779 13.28091-.24466 1.2952-.074686 2.0494.62843 2.4005 1.76245M3.77086 21.1546C4.56586 21.4723 5.49168 21.7879 6.5 22.0658M21.1917 2.76787c1.918 1.4143 1.9383 9.65123 1.7087 13.59293-2.0526 7.6586-10.5943 7.3054-16.4004 5.705M21.1917 2.76787C21.7612 4.51192 22.7203 9.67216 22 16.3608 21.2797 23.0494 11.3665 22.9511 6.5 22.0658M12.055 9C12.711 9.61644 14.3679 10.997 15.9519 11.7966 16.0174 11.8297 16.0154 11.9753 15.9494 12.0063 14.945 12.4779 13.0706 13.9264 12.055 15m3.5006-3.0333C13.1345 12.0608 8 12 6 11" stroke="currentcolor" stroke-linecap="round"/></svg></a></div></article></div><footer class=footer><p>&copy; 2024 <a href=https://blog.hellowood.dev/>HelloWood</a>
Powered by
<a href=https://gohugo.io/ rel=noopener target=_blank data-umami-event=to-hugo>Hugo️️</a>
<a href=https://github.com/guangzhengli/hugo-theme-ladder rel=noopener target=_blank data-umami-event=to-ladder>Ladder</a>
️</p></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g data-umami-event=top-link><svg width="24" height="24" viewBox="0 0 24 24" fill="none"><path d="M10.5376 22.7916C11.0152 22.7207 22.5795 21.1781 22.0978 10.4211 22.0536 9.43274 21.9303 8.53367 21.7387 7.71865M10.5376 22.7916C16.876 22.3728 20.0969 19.8899 21.5383 16.9142M10.5376 22.7916C9.7707 22.9055 8.97982 22.8964 8.19743 22.7725M21.7387 7.71865C21.4988 6.69828 21.1518 5.80967 20.7188 5.04257m1.0199 2.67608C22.6022 10.1105 23.0542 13.7848 21.5383 16.9142M20.7188 5.04257c-3.5504-6.28886-12.88753-4.410077-16.44303.0C2.88063 6.77451-.0433281 11.1668 1.38159 16.6571c.89322 3.4417 3.7911 5.6365 6.81584 6.1154M20.7188 5.04257c1.3509 1.89783 3.3111 6.34223 1.6353 10.37273M21.5383 16.9142C21.8737 16.4251 22.1428 15.9235 22.3541 15.4153M8.19743 22.7725C12.1971 23.4683 20.6281 22.971 22.3541 15.4153M14 10.945C13.3836 10.289 12.003 8.63215 11.2034 7.04814 11.1703 6.98257 11.0247 6.98456 10.9937 7.05061 10.5221 8.05496 9.07362 9.92941 8 10.945m3.0333-3.50056C10.9392 9.86549 11 15 12 17" stroke="currentcolor" stroke-linecap="round"/></svg>
</a><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const s=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="Copy";function n(){t.innerHTML="Copied",setTimeout(()=>{t.innerHTML="Copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),n();return}const s=document.createRange();s.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(s);try{document.execCommand("copy"),n()}catch{}o.removeRange(s)}),e.parentNode.appendChild(t)})</script></main></body><script src=https://cdnjs.cloudflare.com/ajax/libs/medium-zoom/1.0.6/medium-zoom.min.js integrity="sha512-N9IJRoc3LaP3NDoiGkcPa4gG94kapGpaA5Zq9/Dr04uf5TbLFU5q0o8AbRhLKUUlp8QFS2u7S+Yti0U7QtuZvQ==" crossorigin=anonymous referrerpolicy=no-referrer></script><script>const images=Array.from(document.querySelectorAll(".blog-content img"));images.forEach(e=>{mediumZoom(e,{margin:10,scrollOffset:40,container:null,template:null,background:"rgba(0, 0, 0, 0.5)"})})</script><script src=/main.min.6bb26b69159420159c74dc9e097b06a578ed2b68c701466a91a44a9632d851bd0af167a1b30012387b4c512b48ad9ad4d3394e04d77ae38d57e1920fe4ed34fe.js integrity="sha512-a7JraRWUIBWcdNyeCXsGpXjtK2jHAUZqkaRKljLYUb0K8WehswASOHtMUStIrZrU0zlOBNd6441X4ZIP5O00/g==" crossorigin=anonymous defer></script></html>