<!doctype html><html lang=en><head><meta name=viewport content="width=device-width,initial-scale=1"><title>gRPC Server 端启动流程</title>
<meta charset=utf-8><meta name=description content="Ladder@gRPC Server 端启动流程 gRPC Server 启动流程，底层实现以 Netty 为例；
核心类 io.grpc.Server Server 的定义接口，实现类是 io.grpc.internal.ServerImpl，实现了服务、方法与方法处理器的绑定，端口监听，不同类型的 Server 实现的调用，Server 生命周期管理等
io.grpc.BindableService 由编译器生成的服务抽象类的基础接口，并将实现类绑定到服务器，提供将服务的实现的实例绑定到 Server 的方式
io.grpc.ServerInterceptor Server 端的拦截器，在方法调用之前会被调用
io.grpc.HandlerRegistry 方法处理器注册器，所有的方法注册器会注册在这里，通过服务名和方法名查找
io.grpc.ServerServiceDefinition 服务定义，包含服务描述信息，方法信息集合
io.grpc.ServerMethodDefinition 方法定义，包含方法描述信息，方法处理器
启动流程 启动大致流程 创建 ServerBuilder 指定端口 为 ServerBuilder 添加方法 构建服务定义 通过生成的代码构建方法定义，将方法与处理器绑定 将方法处理器添加到方法定义中 将服务定义添加到服务注册器中 添加拦截器等其他的配置 构建 Server 实例 构建 ServerTransport 实例 2. 遍历所有监听的地址，创建相应的 NettyServer 启动 Server 遍历所有的 NettyServer，调用 start 方法启动 创建相应的 ServerBootstrap，绑定监听的地址，可以接受连接 创建 NettyServerTransport，调用 start 方法启动 Transport 为 NettyServerTransport 创建 NettyServerHandler，用于处理请求 保持 Server 启动状态，启动完成 Server 定义 Server server = ServerBuilder."><meta name=author content="HelloWood"><link rel=canonical href=https://blog.hellowood.dev/posts/grpc-server-%E7%AB%AF%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/><meta name=google-site-verification content="G-3MSGPYTHPZ"><link rel=alternate type=application/rss+xml href=https://blog.hellowood.dev//index.xml title=HelloWood><script async src="https://www.googletagmanager.com/gtag/js?id=G-3MSGPYTHPZ"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-3MSGPYTHPZ")}</script><script async defer data-website-id=7a9034de-0ce7-4756-942a-829e6cd22301 src=https://umami.hellowood.dev/script.js></script><script defer data-cf-beacon='{"token": "b2e481d136dc428c8c96c8673e2a04cf"}' src=https://static.cloudflareinsights.com/beacon.min.js></script><meta property="og:url" content="https://blog.hellowood.dev/posts/grpc-server-%E7%AB%AF%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/"><meta property="og:site_name" content="HelloWood"><meta property="og:title" content="gRPC Server 端启动流程"><meta property="og:description" content="gRPC Server 端启动流程 gRPC Server 启动流程，底层实现以 Netty 为例；
核心类 io.grpc.Server Server 的定义接口，实现类是 io.grpc.internal.ServerImpl，实现了服务、方法与方法处理器的绑定，端口监听，不同类型的 Server 实现的调用，Server 生命周期管理等
io.grpc.BindableService 由编译器生成的服务抽象类的基础接口，并将实现类绑定到服务器，提供将服务的实现的实例绑定到 Server 的方式
io.grpc.ServerInterceptor Server 端的拦截器，在方法调用之前会被调用
io.grpc.HandlerRegistry 方法处理器注册器，所有的方法注册器会注册在这里，通过服务名和方法名查找
io.grpc.ServerServiceDefinition 服务定义，包含服务描述信息，方法信息集合
io.grpc.ServerMethodDefinition 方法定义，包含方法描述信息，方法处理器
启动流程 启动大致流程 创建 ServerBuilder 指定端口 为 ServerBuilder 添加方法 构建服务定义 通过生成的代码构建方法定义，将方法与处理器绑定 将方法处理器添加到方法定义中 将服务定义添加到服务注册器中 添加拦截器等其他的配置 构建 Server 实例 构建 ServerTransport 实例 2. 遍历所有监听的地址，创建相应的 NettyServer 启动 Server 遍历所有的 NettyServer，调用 start 方法启动 创建相应的 ServerBootstrap，绑定监听的地址，可以接受连接 创建 NettyServerTransport，调用 start 方法启动 Transport 为 NettyServerTransport 创建 NettyServerHandler，用于处理请求 保持 Server 启动状态，启动完成 Server 定义 Server server = ServerBuilder."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-12-05T22:34:46+00:00"><meta property="article:modified_time" content="2020-12-05T22:34:46+00:00"><meta property="article:tag" content="GRPC"><meta name=twitter:card content="summary"><meta name=twitter:title content="gRPC Server 端启动流程"><meta name=twitter:description content="gRPC Server 端启动流程 gRPC Server 启动流程，底层实现以 Netty 为例；
核心类 io.grpc.Server Server 的定义接口，实现类是 io.grpc.internal.ServerImpl，实现了服务、方法与方法处理器的绑定，端口监听，不同类型的 Server 实现的调用，Server 生命周期管理等
io.grpc.BindableService 由编译器生成的服务抽象类的基础接口，并将实现类绑定到服务器，提供将服务的实现的实例绑定到 Server 的方式
io.grpc.ServerInterceptor Server 端的拦截器，在方法调用之前会被调用
io.grpc.HandlerRegistry 方法处理器注册器，所有的方法注册器会注册在这里，通过服务名和方法名查找
io.grpc.ServerServiceDefinition 服务定义，包含服务描述信息，方法信息集合
io.grpc.ServerMethodDefinition 方法定义，包含方法描述信息，方法处理器
启动流程 启动大致流程 创建 ServerBuilder 指定端口 为 ServerBuilder 添加方法 构建服务定义 通过生成的代码构建方法定义，将方法与处理器绑定 将方法处理器添加到方法定义中 将服务定义添加到服务注册器中 添加拦截器等其他的配置 构建 Server 实例 构建 ServerTransport 实例 2. 遍历所有监听的地址，创建相应的 NettyServer 启动 Server 遍历所有的 NettyServer，调用 start 方法启动 创建相应的 ServerBootstrap，绑定监听的地址，可以接受连接 创建 NettyServerTransport，调用 start 方法启动 Transport 为 NettyServerTransport 创建 NettyServerHandler，用于处理请求 保持 Server 启动状态，启动完成 Server 定义 Server server = ServerBuilder."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.hellowood.dev/posts/"},{"@type":"ListItem","position":2,"name":"gRPC Server 端启动流程","item":"https://blog.hellowood.dev/posts/grpc-server-%E7%AB%AF%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"gRPC Server 端启动流程","name":"gRPC Server 端启动流程","description":"gRPC Server 端启动流程 gRPC Server 启动流程，底层实现以 Netty 为例；\n核心类 io.grpc.Server Server 的定义接口，实现类是 io.grpc.internal.ServerImpl，实现了服务、方法与方法处理器的绑定，端口监听，不同类型的 Server 实现的调用，Server 生命周期管理等\nio.grpc.BindableService 由编译器生成的服务抽象类的基础接口，并将实现类绑定到服务器，提供将服务的实现的实例绑定到 Server 的方式\nio.grpc.ServerInterceptor Server 端的拦截器，在方法调用之前会被调用\nio.grpc.HandlerRegistry 方法处理器注册器，所有的方法注册器会注册在这里，通过服务名和方法名查找\nio.grpc.ServerServiceDefinition 服务定义，包含服务描述信息，方法信息集合\nio.grpc.ServerMethodDefinition 方法定义，包含方法描述信息，方法处理器\n启动流程 启动大致流程 创建 ServerBuilder 指定端口 为 ServerBuilder 添加方法 构建服务定义 通过生成的代码构建方法定义，将方法与处理器绑定 将方法处理器添加到方法定义中 将服务定义添加到服务注册器中 添加拦截器等其他的配置 构建 Server 实例 构建 ServerTransport 实例 2. 遍历所有监听的地址，创建相应的 NettyServer 启动 Server 遍历所有的 NettyServer，调用 start 方法启动 创建相应的 ServerBootstrap，绑定监听的地址，可以接受连接 创建 NettyServerTransport，调用 start 方法启动 Transport 为 NettyServerTransport 创建 NettyServerHandler，用于处理请求 保持 Server 启动状态，启动完成 Server 定义 Server server = ServerBuilder.","keywords":["gRPC"],"articleBody":"gRPC Server 端启动流程 gRPC Server 启动流程，底层实现以 Netty 为例；\n核心类 io.grpc.Server Server 的定义接口，实现类是 io.grpc.internal.ServerImpl，实现了服务、方法与方法处理器的绑定，端口监听，不同类型的 Server 实现的调用，Server 生命周期管理等\nio.grpc.BindableService 由编译器生成的服务抽象类的基础接口，并将实现类绑定到服务器，提供将服务的实现的实例绑定到 Server 的方式\nio.grpc.ServerInterceptor Server 端的拦截器，在方法调用之前会被调用\nio.grpc.HandlerRegistry 方法处理器注册器，所有的方法注册器会注册在这里，通过服务名和方法名查找\nio.grpc.ServerServiceDefinition 服务定义，包含服务描述信息，方法信息集合\nio.grpc.ServerMethodDefinition 方法定义，包含方法描述信息，方法处理器\n启动流程 启动大致流程 创建 ServerBuilder 指定端口 为 ServerBuilder 添加方法 构建服务定义 通过生成的代码构建方法定义，将方法与处理器绑定 将方法处理器添加到方法定义中 将服务定义添加到服务注册器中 添加拦截器等其他的配置 构建 Server 实例 构建 ServerTransport 实例 2. 遍历所有监听的地址，创建相应的 NettyServer 启动 Server 遍历所有的 NettyServer，调用 start 方法启动 创建相应的 ServerBootstrap，绑定监听的地址，可以接受连接 创建 NettyServerTransport，调用 start 方法启动 Transport 为 NettyServerTransport 创建 NettyServerHandler，用于处理请求 保持 Server 启动状态，启动完成 Server 定义 Server server = ServerBuilder.forPort(1234) .addService(new HelloServiceImpl()) .intercept(new CustomServerInterceptor()) .build(); server.start(); server.awaitTermination(); 绑定端口 指定了要监听的端口，会根据不同的 Server 实现绑定端口\nio.grpc.ServerBuilder#forPort public static ServerBuilder\u003c?\u003e forPort(int port) { return ServerProvider.provider().builderForPort(port); } io.grpc.netty.NettyServerProvider#builderForPort protected NettyServerBuilder builderForPort(int port) { return NettyServerBuilder.forPort(port); } io.grpc.netty.NettyServerBuilder#NettyServerBuilder(int) 最终会使用指定的端口，创建 InetSocketAddress 并将其加入到监听的地址集合中\nprivate NettyServerBuilder(int port) { // 将本地 IP 和端口的地址添加到监听的地址集合中 this.listenAddresses.add(new InetSocketAddress(port)); } 绑定服务 将指定的服务实现类添加到方法注册器中\nio.grpc.internal.AbstractServerImplBuilder#addService(io.grpc.BindableService) 添加的服务是 BindableService 接口的实现类的实例\npublic final T addService(BindableService bindableService) { return addService(checkNotNull(bindableService, \"bindableService\").bindService()); } io.github.helloworlde.HelloServiceGrpc.HelloServiceImplBase#bindService 这个方法是生成的代码，里面创建了服务定义、并绑定了方法与处理器\npublic final io.grpc.ServerServiceDefinition bindService() { return io.grpc.ServerServiceDefinition.builder(getServiceDescriptor()) .addMethod(getHowAreYouMethod(), asyncUnaryCall(new MethodHandlers\u003cio.github.helloworlde.HelloMessage, io.github.helloworlde.HelloResponse\u003e(this, METHODID_HOW_ARE_YOU))) .build(); } 其中 addMethod 会获取方法，为方法绑定处理器，即当前的实现类，并构建方法定义；其中 getHowAreYouMethod用于获取方法定义，最终返回包含方法类型、全名、编解码等方法描述信息的实例\nio.github.helloworlde.HelloServiceGrpc.MethodHandlers#MethodHandlers 通过方法实现类实例和方法的 ID 构建 MethodHandlers实例，这个方法也是生成的，在处理请求时会根据方法的 ID 选择不同的实现类调用相应的方法处理请求\nMethodHandlers(HelloServiceImplBase serviceImpl, int methodId) { this.serviceImpl = serviceImpl; this.methodId = methodId; } @java.lang.Override public void invoke(Req request, io.grpc.stub.StreamObserver\u003cResp\u003e responseObserver) { switch (methodId) { case METHODID_HOW_ARE_YOU: serviceImpl.howAreYou((io.github.helloworlde.HelloMessage) request, (io.grpc.stub.StreamObserver\u003cio.github.helloworlde.HelloResponse\u003e) responseObserver); break; default: throw new AssertionError(); } } io.grpc.stub.ServerCalls#asyncUnaryCall 会根据构建的 MethodHandlers 创建相应类型请求的处理器，并将其加入到服务定义中\npublic static \u003cReqT, RespT\u003e ServerCallHandler\u003cReqT, RespT\u003e asyncUnaryCall(UnaryMethod\u003cReqT, RespT\u003e method) { return new UnaryServerCallHandler\u003c\u003e(method); } 创建的 UnaryServerCallHandler 会在服务端 onHalfClose 时调用构建的 UnaryMethod的invoke方法，处理请求\nio.grpc.ServerServiceDefinition.Builder#build 遍历服务中的所有的方法，构建服务定义\npublic ServerServiceDefinition build() { ServiceDescriptor serviceDescriptor = this.serviceDescriptor; // 如果服务定义为 null，则遍历方法，用服务名和方法集合构建新的服务定义 if (serviceDescriptor == null) { List","wordCount":"862","inLanguage":"en","datePublished":"2020-12-05T22:34:46Z","dateModified":"2020-12-05T22:34:46Z","author":{"@type":"Person","name":"HelloWood"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.hellowood.dev/posts/grpc-server-%E7%AB%AF%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/"},"publisher":{"@type":"Organization","name":"HelloWood","logo":{"@type":"ImageObject","url":"https://blog.hellowood.dev/favicon.ico"}}}</script><link rel=icon href=/images/avatar.png sizes=16x16><link rel=apple-touch-icon href=/images/avatar.png><link rel=manifest href=/images/avatar.png><link rel=stylesheet href=https://cdn.staticfile.org/lxgw-wenkai-webfont/1.6.0/style.css><link rel=stylesheet href=/css/main.min.ff1bc260fafbfb440e10194d7d06d57eb5e85eed11d12d06255581262664204e.css integrity="sha256-/xvCYPr7+0QOEBlNfQbVfrXoXu0R0S0GJVWBJiZkIE4=" crossorigin=anonymous media=screen><link rel=stylesheet href=/scss/highlight/github-dark.min.min.66034289ee9a113219a2c4aae0a8bd2095ab255c832a42efcf5863f10814e7a1.css><script src=/js/highlight.min.min.c607d6febd16934a82eb61d3a896ed9d869f54373cc63ce95864ed5488fe3128.js></script><script>hljs.highlightAll()</script><script>(()=>{var t=window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches,e=localStorage.getItem("theme");t&&e===null&&(localStorage.setItem("theme","dark"),document.documentElement.setAttribute("data-dark-mode","")),t&&e==="dark"&&document.documentElement.setAttribute("data-dark-mode",""),e==="dark"&&document.documentElement.setAttribute("data-dark-mode","")})()</script><meta name=google-adsense-account content="ca-pub-3401351766168985"><script type=text/javascript>(function(e,t,n,s,o,i,a){e[n]=e[n]||function(){(e[n].q=e[n].q||[]).push(arguments)},i=t.createElement(s),i.async=1,i.src="https://www.clarity.ms/tag/"+o,a=t.getElementsByTagName(s)[0],a.parentNode.insertBefore(i,a)})(window,document,"clarity","script","jtbhx98g62")</script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3401351766168985" crossorigin=anonymous></script><script defer src=https://analytics.us.umami.is/script.js data-website-id=73ff1c8c-9938-43cf-81af-e77e26b0cca3></script></head><body><main class=wrapper><nav class=navigation><section class=container><a class=navigation-brand data-umami-event=navigation-brand href=/>HOME
</a><input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><span></span><span></span><span></span></label><ul class=navigation-list id=navigation-list><li class="navigation-item navigation-menu"><a class=navigation-link data-umami-event=Blog href=/posts>Blog</a></li><li class="navigation-item navigation-menu"><a class=navigation-link data-umami-event=Tags href=/tags>Tags</a></li><li class="navigation-item navigation-menu"><a class=navigation-link data-umami-event=Archive href=/archives>Archive</a></li><li class="navigation-item navigation-menu"><a class=navigation-link data-umami-event=Dashboard href=https://umami.hellowood.dev/share/lab/Blog>Dashboard</a></li><li class="navigation-item menu-separator"><span>|</span></li><li class="navigation-item navigation-social"><a class=navigation-link data-umami-event=navigation-social href=https://github.com/helloworlde><svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a></li><li class="navigation-item navigation-dark"><button id=mode type=button data-umami-event=toggle-theme aria-label="toggle user light or dark theme">
<span class=toggle-dark><svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-moon"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg></span>
<span class=toggle-light><svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-sun"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></span></button></li></ul></section></nav><div id=content><article class=blog-single><header class=blog-title><h1>gRPC Server 端启动流程</h1></header><p><small>December 5, 2020&nbsp;· 862 words&nbsp;· 5 min</small><p><div class=blog-toc><nav id=TableOfContents><ul><li><a href=#核心类>核心类</a></li><li><a href=#启动流程>启动流程</a><ul><li><a href=#启动大致流程>启动大致流程</a></li><li><a href=#server-定义>Server 定义</a></li><li><a href=#启动-server>启动 Server</a></li></ul></li></ul></nav></div><section class=blog-content><h1 id=grpc-server-端启动流程>gRPC Server 端启动流程</h1><p>gRPC Server 启动流程，底层实现以 Netty 为例；</p><h2 id=核心类>核心类</h2><ul><li><code>io.grpc.Server</code></li></ul><p>Server 的定义接口，实现类是 <code>io.grpc.internal.ServerImpl</code>，实现了服务、方法与方法处理器的绑定，端口监听，不同类型的 Server 实现的调用，Server 生命周期管理等</p><ul><li><code>io.grpc.BindableService</code></li></ul><p>由编译器生成的服务抽象类的基础接口，并将实现类绑定到服务器，提供将服务的实现的实例绑定到 Server 的方式</p><ul><li><code>io.grpc.ServerInterceptor</code></li></ul><p>Server 端的拦截器，在方法调用之前会被调用</p><ul><li><code>io.grpc.HandlerRegistry</code></li></ul><p>方法处理器注册器，所有的方法注册器会注册在这里，通过服务名和方法名查找</p><ul><li><code>io.grpc.ServerServiceDefinition</code></li></ul><p>服务定义，包含服务描述信息，方法信息集合</p><ul><li><code>io.grpc.ServerMethodDefinition</code></li></ul><p>方法定义，包含方法描述信息，方法处理器</p><h2 id=启动流程>启动流程</h2><h3 id=启动大致流程>启动大致流程</h3><ol><li>创建 <code>ServerBuilder</code></li><li>指定端口</li><li>为 <code>ServerBuilder</code> 添加方法<ol><li>构建服务定义<ol><li>通过生成的代码构建方法定义，将方法与处理器绑定</li><li>将方法处理器添加到方法定义中</li><li>将服务定义添加到服务注册器中</li></ol></li></ol></li><li>添加拦截器等其他的配置</li><li>构建 <code>Server</code> 实例<ol><li>构建 <code>ServerTransport</code> 实例
2. 遍历所有监听的地址，创建相应的 <code>NettyServer</code></li></ol></li><li>启动 <code>Server</code><ol><li>遍历所有的 <code>NettyServer</code>，调用 <code>start</code> 方法启动<ol><li>创建相应的 <code>ServerBootstrap</code>，绑定监听的地址，可以接受连接</li><li>创建 <code>NettyServerTransport</code>，调用 <code>start</code> 方法启动 <code>Transport</code></li><li>为 <code>NettyServerTransport</code> 创建 <code>NettyServerHandler</code>，用于处理请求</li></ol></li></ol></li><li>保持 <code>Server</code> 启动状态，启动完成</li></ol><h3 id=server-定义>Server 定义</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>Server server <span style=color:#f92672>=</span> ServerBuilder.<span style=color:#a6e22e>forPort</span>(1234) 
</span></span><span style=display:flex><span>                             .<span style=color:#a6e22e>addService</span>(<span style=color:#66d9ef>new</span> HelloServiceImpl()) 
</span></span><span style=display:flex><span>                             .<span style=color:#a6e22e>intercept</span>(<span style=color:#66d9ef>new</span> CustomServerInterceptor())
</span></span><span style=display:flex><span>                             .<span style=color:#a6e22e>build</span>();
</span></span><span style=display:flex><span>server.<span style=color:#a6e22e>start</span>();
</span></span><span style=display:flex><span>server.<span style=color:#a6e22e>awaitTermination</span>();
</span></span></code></pre></div><h4 id=绑定端口>绑定端口</h4><p>指定了要监听的端口，会根据不同的 <code>Server</code> 实现绑定端口</p><ul><li>io.grpc.ServerBuilder#forPort</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> ServerBuilder<span style=color:#f92672>&lt;?&gt;</span> forPort(<span style=color:#66d9ef>int</span> port) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> ServerProvider.<span style=color:#a6e22e>provider</span>().<span style=color:#a6e22e>builderForPort</span>(port);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>io.grpc.netty.NettyServerProvider#builderForPort</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>protected</span> NettyServerBuilder <span style=color:#a6e22e>builderForPort</span>(<span style=color:#66d9ef>int</span> port) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> NettyServerBuilder.<span style=color:#a6e22e>forPort</span>(port);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>io.grpc.netty.NettyServerBuilder#NettyServerBuilder(int)</li></ul><p>最终会使用指定的端口，创建 <code>InetSocketAddress</code> 并将其加入到监听的地址集合中</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#a6e22e>NettyServerBuilder</span>(<span style=color:#66d9ef>int</span> port) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 将本地 IP 和端口的地址添加到监听的地址集合中</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>listenAddresses</span>.<span style=color:#a6e22e>add</span>(<span style=color:#66d9ef>new</span> InetSocketAddress(port));
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=绑定服务>绑定服务</h4><p>将指定的服务实现类添加到方法注册器中</p><ul><li>io.grpc.internal.AbstractServerImplBuilder#addService(io.grpc.BindableService)</li></ul><p>添加的服务是 <code>BindableService</code> 接口的实现类的实例</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>final</span> T <span style=color:#a6e22e>addService</span>(BindableService bindableService) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> addService(checkNotNull(bindableService, <span style=color:#e6db74>&#34;bindableService&#34;</span>).<span style=color:#a6e22e>bindService</span>());
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>io.github.helloworlde.HelloServiceGrpc.HelloServiceImplBase#bindService</li></ul><p>这个方法是生成的代码，里面创建了服务定义、并绑定了方法与处理器</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>final</span> io.<span style=color:#a6e22e>grpc</span>.<span style=color:#a6e22e>ServerServiceDefinition</span> <span style=color:#a6e22e>bindService</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> io.<span style=color:#a6e22e>grpc</span>.<span style=color:#a6e22e>ServerServiceDefinition</span>.<span style=color:#a6e22e>builder</span>(getServiceDescriptor())
</span></span><span style=display:flex><span>                                          .<span style=color:#a6e22e>addMethod</span>(getHowAreYouMethod(), asyncUnaryCall(<span style=color:#66d9ef>new</span> MethodHandlers<span style=color:#f92672>&lt;</span>io.<span style=color:#a6e22e>github</span>.<span style=color:#a6e22e>helloworlde</span>.<span style=color:#a6e22e>HelloMessage</span>, io.<span style=color:#a6e22e>github</span>.<span style=color:#a6e22e>helloworlde</span>.<span style=color:#a6e22e>HelloResponse</span><span style=color:#f92672>&gt;</span>(<span style=color:#66d9ef>this</span>, METHODID_HOW_ARE_YOU)))
</span></span><span style=display:flex><span>                                          .<span style=color:#a6e22e>build</span>();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>其中 <code>addMethod</code> 会获取方法，为方法绑定处理器，即当前的实现类，并构建方法定义；其中 <code>getHowAreYouMethod</code>用于获取方法定义，最终返回包含方法类型、全名、编解码等方法描述信息的实例</p><ul><li>io.github.helloworlde.HelloServiceGrpc.MethodHandlers#MethodHandlers</li></ul><p>通过方法实现类实例和方法的 ID 构建 <code>MethodHandlers</code>实例，这个方法也是生成的，在处理请求时会根据方法的 ID 选择不同的实现类调用相应的方法处理请求</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>MethodHandlers(HelloServiceImplBase serviceImpl, <span style=color:#66d9ef>int</span> methodId) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>serviceImpl</span> <span style=color:#f92672>=</span> serviceImpl;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>methodId</span> <span style=color:#f92672>=</span> methodId;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@java.lang.Override</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>invoke</span>(Req request, io.<span style=color:#a6e22e>grpc</span>.<span style=color:#a6e22e>stub</span>.<span style=color:#a6e22e>StreamObserver</span><span style=color:#f92672>&lt;</span>Resp<span style=color:#f92672>&gt;</span> responseObserver) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>switch</span> (methodId) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>case</span> METHODID_HOW_ARE_YOU:
</span></span><span style=display:flex><span>            serviceImpl.<span style=color:#a6e22e>howAreYou</span>((io.<span style=color:#a6e22e>github</span>.<span style=color:#a6e22e>helloworlde</span>.<span style=color:#a6e22e>HelloMessage</span>) request,
</span></span><span style=display:flex><span>                    (io.<span style=color:#a6e22e>grpc</span>.<span style=color:#a6e22e>stub</span>.<span style=color:#a6e22e>StreamObserver</span><span style=color:#f92672>&lt;</span>io.<span style=color:#a6e22e>github</span>.<span style=color:#a6e22e>helloworlde</span>.<span style=color:#a6e22e>HelloResponse</span><span style=color:#f92672>&gt;</span>) responseObserver);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>default</span>:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> AssertionError();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>io.grpc.stub.ServerCalls#asyncUnaryCall</li></ul><p>会根据构建的 <code>MethodHandlers</code> 创建相应类型请求的处理器，并将其加入到服务定义中</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#f92672>&lt;</span>ReqT, RespT<span style=color:#f92672>&gt;</span> ServerCallHandler<span style=color:#f92672>&lt;</span>ReqT, RespT<span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>asyncUnaryCall</span>(UnaryMethod<span style=color:#f92672>&lt;</span>ReqT, RespT<span style=color:#f92672>&gt;</span> method) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> UnaryServerCallHandler<span style=color:#f92672>&lt;&gt;</span>(method);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>创建的 <code>UnaryServerCallHandler</code> 会在服务端 <code>onHalfClose</code> 时调用构建的 <code>UnaryMethod</code>的<code>invoke</code>方法，处理请求</p><ul><li>io.grpc.ServerServiceDefinition.Builder#build</li></ul><p>遍历服务中的所有的方法，构建服务定义</p><pre tabindex=0><code>public ServerServiceDefinition build() {
    ServiceDescriptor serviceDescriptor = this.serviceDescriptor;
    // 如果服务定义为 null，则遍历方法，用服务名和方法集合构建新的服务定义
    if (serviceDescriptor == null) {
        List&lt;MethodDescriptor&lt;?, ?&gt;&gt; methodDescriptors = new ArrayList&lt;&gt;(methods.size());
        for (ServerMethodDefinition&lt;?, ?&gt; serverMethod : methods.values()) {
            methodDescriptors.add(serverMethod.getMethodDescriptor());
        }
        serviceDescriptor = new ServiceDescriptor(serviceName, methodDescriptors);
    }

    Map&lt;String, ServerMethodDefinition&lt;?, ?&gt;&gt; tmpMethods = new HashMap&lt;&gt;(methods);
    // 遍历方法定义，校验是否所有的方法都在方法定义中
    for (MethodDescriptor&lt;?, ?&gt; descriptorMethod : serviceDescriptor.getMethods()) {
        ServerMethodDefinition&lt;?, ?&gt; removed = tmpMethods.remove(descriptorMethod.getFullMethodName());
    }

    // 根据服务定义和方法定义集合构建服务定义
    return new ServerServiceDefinition(serviceDescriptor, methods);
}
</code></pre><ul><li>io.grpc.internal.AbstractServerImplBuilder#addService(io.grpc.ServerServiceDefinition)</li></ul><p>将服务定义添加到服务注册器中</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>final</span> T <span style=color:#a6e22e>addService</span>(ServerServiceDefinition service) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 将服务添加到处理器中</span>
</span></span><span style=display:flex><span>    registryBuilder.<span style=color:#a6e22e>addService</span>(checkNotNull(service, <span style=color:#e6db74>&#34;service&#34;</span>));
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> thisT();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>io.grpc.internal.InternalHandlerRegistry.Builder#addService</li></ul><p>最终将服务定义添加到注册器的 Map 中，key 是服务的全名，value 是服务定义；
这样就可以在处理请求时根据请求中的服务和方法名称，在注册器中查找对应的方法的处理器，实现调用</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>Builder <span style=color:#a6e22e>addService</span>(ServerServiceDefinition service) {
</span></span><span style=display:flex><span>    services.<span style=color:#a6e22e>put</span>(service.<span style=color:#a6e22e>getServiceDescriptor</span>().<span style=color:#a6e22e>getName</span>(), service);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>this</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=绑定拦截器>绑定拦截器</h4><ul><li>io.grpc.internal.AbstractServerImplBuilder#intercept</li></ul><p>通过 <code>intercept</code> 方法，将拦截器添加到拦截器集合中</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>final</span> T <span style=color:#a6e22e>intercept</span>(ServerInterceptor interceptor) {
</span></span><span style=display:flex><span>    interceptors.<span style=color:#a6e22e>add</span>(checkNotNull(interceptor, <span style=color:#e6db74>&#34;interceptor&#34;</span>));
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> thisT();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=构建-server-实例>构建 Server 实例</h4><ul><li>io.grpc.internal.AbstractServerImplBuilder#build</li></ul><p>在构建器中创建 <code>Server</code> 的实例</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>final</span> Server <span style=color:#a6e22e>build</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> ServerImpl(<span style=color:#66d9ef>this</span>, buildTransportServers(getTracerFactories()), Context.<span style=color:#a6e22e>ROOT</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>io.grpc.netty.NettyServerBuilder#buildTransportServers</li></ul><p>构建 <code>Server</code> 的 <code>Transport</code>，会为每个监听的地址都构建一个 <code>NettyServer</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>protected</span> List<span style=color:#f92672>&lt;</span>NettyServer<span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>buildTransportServers</span>(List<span style=color:#f92672>&lt;?</span> <span style=color:#66d9ef>extends</span> ServerStreamTracer.<span style=color:#a6e22e>Factory</span><span style=color:#f92672>&gt;</span> streamTracerFactories) {
</span></span><span style=display:flex><span>    assertEventLoopsAndChannelType();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    ProtocolNegotiator negotiator <span style=color:#f92672>=</span> protocolNegotiator;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (negotiator <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>        negotiator <span style=color:#f92672>=</span> sslContext <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span> <span style=color:#f92672>?</span> ProtocolNegotiators.<span style=color:#a6e22e>serverTls</span>(sslContext, <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>getExecutorPool</span>()) : ProtocolNegotiators.<span style=color:#a6e22e>serverPlaintext</span>();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    List<span style=color:#f92672>&lt;</span>NettyServer<span style=color:#f92672>&gt;</span> transportServers <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ArrayList<span style=color:#f92672>&lt;&gt;</span>(listenAddresses.<span style=color:#a6e22e>size</span>());
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 为每一个监听的地址构建一个 NettyServer</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (SocketAddress listenAddress : listenAddresses) {
</span></span><span style=display:flex><span>        NettyServer transportServer <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> NettyServer(listenAddress,
</span></span><span style=display:flex><span>                channelFactory,
</span></span><span style=display:flex><span>                channelOptions,
</span></span><span style=display:flex><span>                childChannelOptions,
</span></span><span style=display:flex><span>                bossEventLoopGroupPool,
</span></span><span style=display:flex><span>                workerEventLoopGroupPool,
</span></span><span style=display:flex><span>                forceHeapBuffer,
</span></span><span style=display:flex><span>                negotiator,
</span></span><span style=display:flex><span>                streamTracerFactories,
</span></span><span style=display:flex><span>                getTransportTracerFactory(),
</span></span><span style=display:flex><span>                maxConcurrentCallsPerConnection,
</span></span><span style=display:flex><span>                autoFlowControl,
</span></span><span style=display:flex><span>                flowControlWindow,
</span></span><span style=display:flex><span>                maxMessageSize,
</span></span><span style=display:flex><span>                maxHeaderListSize,
</span></span><span style=display:flex><span>                keepAliveTimeInNanos,
</span></span><span style=display:flex><span>                keepAliveTimeoutInNanos,
</span></span><span style=display:flex><span>                maxConnectionIdleInNanos,
</span></span><span style=display:flex><span>                maxConnectionAgeInNanos,
</span></span><span style=display:flex><span>                maxConnectionAgeGraceInNanos,
</span></span><span style=display:flex><span>                permitKeepAliveWithoutCalls,
</span></span><span style=display:flex><span>                permitKeepAliveTimeInNanos,
</span></span><span style=display:flex><span>                getChannelz());
</span></span><span style=display:flex><span>        transportServers.<span style=color:#a6e22e>add</span>(transportServer);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> Collections.<span style=color:#a6e22e>unmodifiableList</span>(transportServers);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>io.grpc.internal.ServerImpl#ServerImpl</li></ul><p>创建 <code>ServerImpl</code> 实例</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>ServerImpl(AbstractServerImplBuilder<span style=color:#f92672>&lt;?&gt;</span> builder,
</span></span><span style=display:flex><span>           List<span style=color:#f92672>&lt;?</span> <span style=color:#66d9ef>extends</span> InternalServer<span style=color:#f92672>&gt;</span> transportServers,
</span></span><span style=display:flex><span>           Context rootContext) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>executorPool</span> <span style=color:#f92672>=</span> Preconditions.<span style=color:#a6e22e>checkNotNull</span>(builder.<span style=color:#a6e22e>executorPool</span>, <span style=color:#e6db74>&#34;executorPool&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>registry</span> <span style=color:#f92672>=</span> Preconditions.<span style=color:#a6e22e>checkNotNull</span>(builder.<span style=color:#a6e22e>registryBuilder</span>.<span style=color:#a6e22e>build</span>(), <span style=color:#e6db74>&#34;registryBuilder&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>fallbackRegistry</span> <span style=color:#f92672>=</span> Preconditions.<span style=color:#a6e22e>checkNotNull</span>(builder.<span style=color:#a6e22e>fallbackRegistry</span>, <span style=color:#e6db74>&#34;fallbackRegistry&#34;</span>);
</span></span><span style=display:flex><span>    Preconditions.<span style=color:#a6e22e>checkNotNull</span>(transportServers, <span style=color:#e6db74>&#34;transportServers&#34;</span>);
</span></span><span style=display:flex><span>    Preconditions.<span style=color:#a6e22e>checkArgument</span>(<span style=color:#f92672>!</span>transportServers.<span style=color:#a6e22e>isEmpty</span>(), <span style=color:#e6db74>&#34;no servers provided&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>transportServers</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ArrayList<span style=color:#f92672>&lt;&gt;</span>(transportServers);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>logId</span> <span style=color:#f92672>=</span> InternalLogId.<span style=color:#a6e22e>allocate</span>(<span style=color:#e6db74>&#34;Server&#34;</span>, String.<span style=color:#a6e22e>valueOf</span>(getListenSocketsIgnoringLifecycle()));
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Fork from the passed in context so that it does not propagate cancellation, it only</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// inherits values.</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>rootContext</span> <span style=color:#f92672>=</span> Preconditions.<span style=color:#a6e22e>checkNotNull</span>(rootContext, <span style=color:#e6db74>&#34;rootContext&#34;</span>).<span style=color:#a6e22e>fork</span>();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>decompressorRegistry</span> <span style=color:#f92672>=</span> builder.<span style=color:#a6e22e>decompressorRegistry</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>compressorRegistry</span> <span style=color:#f92672>=</span> builder.<span style=color:#a6e22e>compressorRegistry</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>transportFilters</span> <span style=color:#f92672>=</span> Collections.<span style=color:#a6e22e>unmodifiableList</span>(<span style=color:#66d9ef>new</span> ArrayList<span style=color:#f92672>&lt;&gt;</span>(builder.<span style=color:#a6e22e>transportFilters</span>));
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>interceptors</span> <span style=color:#f92672>=</span> builder.<span style=color:#a6e22e>interceptors</span>.<span style=color:#a6e22e>toArray</span>(<span style=color:#66d9ef>new</span> ServerInterceptor<span style=color:#f92672>[</span>builder.<span style=color:#a6e22e>interceptors</span>.<span style=color:#a6e22e>size</span>()<span style=color:#f92672>]</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>handshakeTimeoutMillis</span> <span style=color:#f92672>=</span> builder.<span style=color:#a6e22e>handshakeTimeoutMillis</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>binlog</span> <span style=color:#f92672>=</span> builder.<span style=color:#a6e22e>binlog</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>channelz</span> <span style=color:#f92672>=</span> builder.<span style=color:#a6e22e>channelz</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>serverCallTracer</span> <span style=color:#f92672>=</span> builder.<span style=color:#a6e22e>callTracerFactory</span>.<span style=color:#a6e22e>create</span>();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>ticker</span> <span style=color:#f92672>=</span> checkNotNull(builder.<span style=color:#a6e22e>ticker</span>, <span style=color:#e6db74>&#34;ticker&#34;</span>);
</span></span><span style=display:flex><span>    channelz.<span style=color:#a6e22e>addServer</span>(<span style=color:#66d9ef>this</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=启动-server>启动 Server</h3><h4 id=启动-server-1>启动 Server</h4><ul><li>io.grpc.internal.ServerImpl#start</li></ul><p>启动 <code>Server</code>，会创建服务监听器，遍历所有的监听的地址，并启动相应的 <code>Transport</code>，修改启动状态为 true</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> ServerImpl <span style=color:#a6e22e>start</span>() <span style=color:#66d9ef>throws</span> IOException {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>synchronized</span> (lock) {
</span></span><span style=display:flex><span>        checkState(<span style=color:#f92672>!</span>started, <span style=color:#e6db74>&#34;Already started&#34;</span>);
</span></span><span style=display:flex><span>        checkState(<span style=color:#f92672>!</span>shutdown, <span style=color:#e6db74>&#34;Shutting down&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Start and wait for any ports to actually be bound.</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 创建服务监听器实例</span>
</span></span><span style=display:flex><span>        ServerListenerImpl listener <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ServerListenerImpl();
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 遍历 Server 并启动</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (InternalServer ts : transportServers) {
</span></span><span style=display:flex><span>            ts.<span style=color:#a6e22e>start</span>(listener);
</span></span><span style=display:flex><span>            activeTransportServers<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        executor <span style=color:#f92672>=</span> Preconditions.<span style=color:#a6e22e>checkNotNull</span>(executorPool.<span style=color:#a6e22e>getObject</span>(), <span style=color:#e6db74>&#34;executor&#34;</span>);
</span></span><span style=display:flex><span>        started <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>this</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>io.grpc.netty.NettyServer#start</li></ul><p>启动 Netty Server，会先创建 <code>ServerBootstrap</code>，然后在初始化 <code>Channel</code> 时会创建 <code>NettyServerTransport</code> 并调用其 start 方法启动，并将需要监听的地址绑定在 <code>ServerBootstrap</code> 上</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>start</span>(ServerListener serverListener) <span style=color:#66d9ef>throws</span> IOException {
</span></span><span style=display:flex><span>  listener <span style=color:#f92672>=</span> checkNotNull(serverListener, <span style=color:#e6db74>&#34;serverListener&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 用于启动 Netty ServerChannel</span>
</span></span><span style=display:flex><span>  ServerBootstrap b <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ServerBootstrap();
</span></span><span style=display:flex><span>  b.<span style=color:#a6e22e>group</span>(bossGroup, workerGroup);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  b.<span style=color:#a6e22e>childHandler</span>(<span style=color:#66d9ef>new</span> ChannelInitializer<span style=color:#f92672>&lt;</span>Channel<span style=color:#f92672>&gt;</span>() {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>initChannel</span>(Channel ch) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      ChannelPromise channelDone <span style=color:#f92672>=</span> ch.<span style=color:#a6e22e>newPromise</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#75715e>// 构建基于 Netty 的 ServerTransport</span>
</span></span><span style=display:flex><span>      NettyServerTransport transport <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> NettyServerTransport(ch,
</span></span><span style=display:flex><span>              channelDone,
</span></span><span style=display:flex><span>              protocolNegotiator,
</span></span><span style=display:flex><span>              streamTracerFactories,
</span></span><span style=display:flex><span>              transportTracerFactory.<span style=color:#a6e22e>create</span>(),
</span></span><span style=display:flex><span>              maxStreamsPerConnection,
</span></span><span style=display:flex><span>              autoFlowControl,
</span></span><span style=display:flex><span>              flowControlWindow,
</span></span><span style=display:flex><span>              maxMessageSize,
</span></span><span style=display:flex><span>              maxHeaderListSize,
</span></span><span style=display:flex><span>              keepAliveTimeInNanos,
</span></span><span style=display:flex><span>              keepAliveTimeoutInNanos,
</span></span><span style=display:flex><span>              maxConnectionIdleInNanos,
</span></span><span style=display:flex><span>              maxConnectionAgeInNanos,
</span></span><span style=display:flex><span>              maxConnectionAgeGraceInNanos,
</span></span><span style=display:flex><span>              permitKeepAliveWithoutCalls,
</span></span><span style=display:flex><span>              permitKeepAliveTimeInNanos);
</span></span><span style=display:flex><span>      ServerTransportListener transportListener;
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>synchronized</span> (NettyServer.<span style=color:#a6e22e>this</span>) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 调用监听器回调，Transport 创建事件</span>
</span></span><span style=display:flex><span>        transportListener <span style=color:#f92672>=</span> listener.<span style=color:#a6e22e>transportCreated</span>(transport);
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#75715e>// 启动监听器</span>
</span></span><span style=display:flex><span>      transport.<span style=color:#a6e22e>start</span>(transportListener);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  });
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 绑定地址，接受连接</span>
</span></span><span style=display:flex><span>  ChannelFuture future <span style=color:#f92672>=</span> b.<span style=color:#a6e22e>bind</span>(address);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  channel <span style=color:#f92672>=</span> future.<span style=color:#a6e22e>channel</span>();
</span></span><span style=display:flex><span>  channel.<span style=color:#a6e22e>eventLoop</span>().<span style=color:#a6e22e>execute</span>(<span style=color:#66d9ef>new</span> Runnable() {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>run</span>() {
</span></span><span style=display:flex><span>      listenSocketStats <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ListenSocket(channel);
</span></span><span style=display:flex><span>      channelz.<span style=color:#a6e22e>addListenSocket</span>(listenSocketStats);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  });
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>io.grpc.internal.ServerImpl.ServerListenerImpl#transportCreated</li></ul><p><code>ServerTransport</code> 创建事件回调</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> ServerTransportListener <span style=color:#a6e22e>transportCreated</span>(ServerTransport transport) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>synchronized</span> (lock) {
</span></span><span style=display:flex><span>        transports.<span style=color:#a6e22e>add</span>(transport);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Transport 监听器</span>
</span></span><span style=display:flex><span>    ServerTransportListenerImpl stli <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ServerTransportListenerImpl(transport);
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 初始化监听器，添加握手超时的取消任务</span>
</span></span><span style=display:flex><span>    stli.<span style=color:#a6e22e>init</span>();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> stli;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>io.grpc.netty.NettyServerTransport#start</li></ul><p>启动 <code>NettyServerTransport</code>，会创建相应的 <code>NettyServerHandler</code> 用于处理请求；同时添加监听器</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>start</span>(ServerTransportListener listener) {
</span></span><span style=display:flex><span>    Preconditions.<span style=color:#a6e22e>checkState</span>(<span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>listener</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>, <span style=color:#e6db74>&#34;Handler already registered&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>listener</span> <span style=color:#f92672>=</span> listener;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Create the Netty handler for the pipeline.</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 为 pipeline 创建 Netty Handler</span>
</span></span><span style=display:flex><span>    grpcHandler <span style=color:#f92672>=</span> createHandler(listener, channelUnused);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Notify when the channel closes.</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 当 Channel 关闭的时候发送通知</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>TerminationNotifier</span> <span style=color:#66d9ef>implements</span> ChannelFutureListener {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>boolean</span> done;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>operationComplete</span>(ChannelFuture future) <span style=color:#66d9ef>throws</span> Exception {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>done) {
</span></span><span style=display:flex><span>                done <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>                notifyTerminated(grpcHandler.<span style=color:#a6e22e>connectionError</span>());
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 创建 Handler</span>
</span></span><span style=display:flex><span>    ChannelHandler negotiationHandler <span style=color:#f92672>=</span> protocolNegotiator.<span style=color:#a6e22e>newHandler</span>(grpcHandler);
</span></span><span style=display:flex><span>    ChannelHandler bufferingHandler <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> WriteBufferingAndExceptionHandler(negotiationHandler);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 添加监听器</span>
</span></span><span style=display:flex><span>    ChannelFutureListener terminationNotifier <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> TerminationNotifier();
</span></span><span style=display:flex><span>    channelUnused.<span style=color:#a6e22e>addListener</span>(terminationNotifier);
</span></span><span style=display:flex><span>    channel.<span style=color:#a6e22e>closeFuture</span>().<span style=color:#a6e22e>addListener</span>(terminationNotifier);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    channel.<span style=color:#a6e22e>pipeline</span>().<span style=color:#a6e22e>addLast</span>(bufferingHandler);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=保持-server-运行>保持 Server 运行</h4><ul><li>io.grpc.internal.ServerImpl#awaitTermination()</li></ul><p>通过轮询关闭的状态，如果没有关闭，则使锁等待，保持 Server 线程的运行</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>awaitTermination</span>() <span style=color:#66d9ef>throws</span> InterruptedException {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>synchronized</span> (lock) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (<span style=color:#f92672>!</span>terminated) {
</span></span><span style=display:flex><span>            lock.<span style=color:#a6e22e>wait</span>();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></section><div class=paginator><a class=prev href=https://blog.hellowood.dev/posts/grpc-server-%E7%AB%AF%E5%85%B3%E9%97%AD%E6%B5%81%E7%A8%8B/><svg class="icon" width="24" height="24" viewBox="0 0 24 24" fill="none"><path d="M3.77086 21.1546C11.0491 22.698 21.4339 21.7773 21.4339 16.3608V4.63375c0-.69413-.075800000000001-1.3284-.2422-1.86588M3.77086 21.1546C1.9934 20.7777.973585 18.7264 1.08749 16.688c.17931-3.209.06972-7.25665-.08236-10.47293C.87809 3.52811 3.12891 1.16316 5.51029 1.25008c4.25565.15534 9.86671-.04779 13.28091-.24466 1.2952-.074686 2.0494.62843 2.4005 1.76245M3.77086 21.1546C4.56586 21.4723 5.49168 21.7879 6.5 22.0658M21.1917 2.76787c1.918 1.4143 1.9383 9.65123 1.7087 13.59293-2.0526 7.6586-10.5943 7.3054-16.4004 5.705M21.1917 2.76787C21.7612 4.51192 22.7203 9.67216 22 16.3608 21.2797 23.0494 11.3665 22.9511 6.5 22.0658M9.94496 9C9.28897 9.61644 7.63215 10.997 6.04814 11.7966 5.98257 11.8297 5.98456 11.9753 6.05061 12.0063c1.00435.4716 2.8788 1.9201 3.89435 2.9937M6.44444 11.9667C8.86549 12.0608 14 12 16 11" stroke="currentcolor" stroke-linecap="round"/></svg>
<span>gRPC Server 端关闭流程</span></a>
<a class=next href=https://blog.hellowood.dev/posts/grpc-channel/><span>gRPC Channel</span><svg class="icon" width="24" height="24" viewBox="0 0 24 24" fill="none"><path d="M3.77086 21.1546C11.0491 22.698 21.4339 21.7773 21.4339 16.3608V4.63375c0-.69413-.075800000000001-1.3284-.2422-1.86588M3.77086 21.1546C1.9934 20.7777.973585 18.7264 1.08749 16.688c.17931-3.209.06972-7.25665-.08236-10.47293C.87809 3.52811 3.12891 1.16316 5.51029 1.25008c4.25565.15534 9.86671-.04779 13.28091-.24466 1.2952-.074686 2.0494.62843 2.4005 1.76245M3.77086 21.1546C4.56586 21.4723 5.49168 21.7879 6.5 22.0658M21.1917 2.76787c1.918 1.4143 1.9383 9.65123 1.7087 13.59293-2.0526 7.6586-10.5943 7.3054-16.4004 5.705M21.1917 2.76787C21.7612 4.51192 22.7203 9.67216 22 16.3608 21.2797 23.0494 11.3665 22.9511 6.5 22.0658M12.055 9C12.711 9.61644 14.3679 10.997 15.9519 11.7966 16.0174 11.8297 16.0154 11.9753 15.9494 12.0063 14.945 12.4779 13.0706 13.9264 12.055 15m3.5006-3.0333C13.1345 12.0608 8 12 6 11" stroke="currentcolor" stroke-linecap="round"/></svg></a></div></article></div><footer class=footer><p>&copy; 2024 <a href=https://blog.hellowood.dev/>HelloWood</a>
Powered by
<a href=https://gohugo.io/ rel=noopener target=_blank data-umami-event=to-hugo>Hugo️️</a>
<a href=https://github.com/guangzhengli/hugo-theme-ladder rel=noopener target=_blank data-umami-event=to-ladder>Ladder</a>
️</p></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g data-umami-event=top-link><svg width="24" height="24" viewBox="0 0 24 24" fill="none"><path d="M10.5376 22.7916C11.0152 22.7207 22.5795 21.1781 22.0978 10.4211 22.0536 9.43274 21.9303 8.53367 21.7387 7.71865M10.5376 22.7916C16.876 22.3728 20.0969 19.8899 21.5383 16.9142M10.5376 22.7916C9.7707 22.9055 8.97982 22.8964 8.19743 22.7725M21.7387 7.71865C21.4988 6.69828 21.1518 5.80967 20.7188 5.04257m1.0199 2.67608C22.6022 10.1105 23.0542 13.7848 21.5383 16.9142M20.7188 5.04257c-3.5504-6.28886-12.88753-4.410077-16.44303.0C2.88063 6.77451-.0433281 11.1668 1.38159 16.6571c.89322 3.4417 3.7911 5.6365 6.81584 6.1154M20.7188 5.04257c1.3509 1.89783 3.3111 6.34223 1.6353 10.37273M21.5383 16.9142C21.8737 16.4251 22.1428 15.9235 22.3541 15.4153M8.19743 22.7725C12.1971 23.4683 20.6281 22.971 22.3541 15.4153M14 10.945C13.3836 10.289 12.003 8.63215 11.2034 7.04814 11.1703 6.98257 11.0247 6.98456 10.9937 7.05061 10.5221 8.05496 9.07362 9.92941 8 10.945m3.0333-3.50056C10.9392 9.86549 11 15 12 17" stroke="currentcolor" stroke-linecap="round"/></svg>
</a><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const s=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="Copy";function n(){t.innerHTML="Copied",setTimeout(()=>{t.innerHTML="Copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),n();return}const s=document.createRange();s.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(s);try{document.execCommand("copy"),n()}catch{}o.removeRange(s)}),e.parentNode.appendChild(t)})</script></main></body><script src=https://cdnjs.cloudflare.com/ajax/libs/medium-zoom/1.0.6/medium-zoom.min.js integrity="sha512-N9IJRoc3LaP3NDoiGkcPa4gG94kapGpaA5Zq9/Dr04uf5TbLFU5q0o8AbRhLKUUlp8QFS2u7S+Yti0U7QtuZvQ==" crossorigin=anonymous referrerpolicy=no-referrer></script><script>const images=Array.from(document.querySelectorAll(".blog-content img"));images.forEach(e=>{mediumZoom(e,{margin:10,scrollOffset:40,container:null,template:null,background:"rgba(0, 0, 0, 0.5)"})})</script><script src=/main.min.6bb26b69159420159c74dc9e097b06a578ed2b68c701466a91a44a9632d851bd0af167a1b30012387b4c512b48ad9ad4d3394e04d77ae38d57e1920fe4ed34fe.js integrity="sha512-a7JraRWUIBWcdNyeCXsGpXjtK2jHAUZqkaRKljLYUb0K8WehswASOHtMUStIrZrU0zlOBNd6441X4ZIP5O00/g==" crossorigin=anonymous defer></script></html>