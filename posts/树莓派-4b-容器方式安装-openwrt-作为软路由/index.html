<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><style>:root{--accent-color:#FF4D4D}</style><title>树莓派 4B 容器方式安装 OpenWrt 作为软路由</title>
<meta name=description content="
在树莓派 4B，基于 Ubuntu 22.04，使用 Docker 容器的方式运行 Openwrt 作为软路由，基于 SuLingGG/OpenWrt-Docker 的方案


什么是软路由

硬路由以特有的硬设备，包括处理器、电源供应、嵌入式软件，提供设定的路由器功能，如常用的路由器；软路由则是指利用台式机或服务器 …"><meta name=keywords content='blog,hugo,OpenWrt,RaspberryPi,HomeLab'><meta property="og:url" content="https://blog.hellowood.dev/posts/%E6%A0%91%E8%8E%93%E6%B4%BE-4b-%E5%AE%B9%E5%99%A8%E6%96%B9%E5%BC%8F%E5%AE%89%E8%A3%85-openwrt-%E4%BD%9C%E4%B8%BA%E8%BD%AF%E8%B7%AF%E7%94%B1/"><meta property="og:type" content="website"><meta property="og:title" content="树莓派 4B 容器方式安装 OpenWrt 作为软路由"><meta property="og:description" content="
在树莓派 4B，基于 Ubuntu 22.04，使用 Docker 容器的方式运行 Openwrt 作为软路由，基于 SuLingGG/OpenWrt-Docker 的方案


什么是软路由

硬路由以特有的硬设备，包括处理器、电源供应、嵌入式软件，提供设定的路由器功能，如常用的路由器；软路由则是指利用台式机或服务器 …"><meta property="og:image" content="https://blog.hellowood.dev/images/avatar.webp"><meta property="og:image:secure_url" content="https://blog.hellowood.dev/images/avatar.webp"><link rel=canonical href=https://blog.hellowood.dev/posts/%E6%A0%91%E8%8E%93%E6%B4%BE-4b-%E5%AE%B9%E5%99%A8%E6%96%B9%E5%BC%8F%E5%AE%89%E8%A3%85-openwrt-%E4%BD%9C%E4%B8%BA%E8%BD%AF%E8%B7%AF%E7%94%B1/><link rel=stylesheet type=text/css href=/css/normalize.min.css media=print><link rel=stylesheet type=text/css href=/css/main.min.css><link id=dark-theme rel=stylesheet href=/css/dark.min.css><script src=/js/bundle.min.9a920d7dabdbad8363b6a0a94e29a9dfebdb7ee64cfcb193a0145e512ef2bdab.js integrity="sha256-mpINfavbrYNjtqCpTimp3+vbfuZM/LGToBReUS7yvas="></script><script defer src=https://umami.hellowood.dev/script.js data-website-id=7a9034de-0ce7-4756-942a-829e6cd22301></script><script defer src=https://cloud.umami.is/script.js data-website-id=73ff1c8c-9938-43cf-81af-e77e26b0cca3></script><script defer src=https://static.cloudflareinsights.com/beacon.min.js data-cf-beacon='{"token": "b2e481d136dc428c8c96c8673e2a04cf"}'></script><meta name=google-adsense-account content="ca-pub-3401351766168985"><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3401351766168985" crossorigin=anonymous></script><script type=text/javascript>(function(e,t,n,s,o,i,a){e[n]=e[n]||function(){(e[n].q=e[n].q||[]).push(arguments)},i=t.createElement(s),i.async=1,i.src="https://www.clarity.ms/tag/"+o,a=t.getElementsByTagName(s)[0],a.parentNode.insertBefore(i,a)})(window,document,"clarity","script","jtbhx98g62")</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-3MSGPYTHPZ"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-3MSGPYTHPZ")</script></head><body><script>setThemeByUserPref()</script><header class=header><nav class=header-nav><div class=avatar><a href=https://blog.hellowood.dev/><img src=/images/avatar.webp alt=avatar></a></div><div class=nav-title><a class=nav-brand href=https://blog.hellowood.dev/>HelloWood</a></div><div class=nav-links><div class=nav-link><a href=https://blog.hellowood.dev/><span data-feather=home></span> Home</a></div><div class=nav-link><a href=https://blog.hellowood.dev/posts/><span data-feather=book></span> Posts</a></div><div class=nav-link><a href=https://blog.hellowood.dev/tags/><span data-feather=tag></span> Tags</a></div><div class=nav-link><a href=https://github.com/helloworlde><span data-feather=github></span></a></div><div class=nav-link><a href=https://umami.hellowood.dev/share/lab/Blog><span data-feather=pie-chart></span></a></div><div class=nav-link><a href=https://blog.hellowood.dev/index.xml><span data-feather=rss></span></a></div><span class=nav-icons-divider></span><div class="nav-link dark-theme-toggle"><span class="sr-only dark-theme-toggle-screen-reader-target"></span>
<a><span class=theme-toggle-icon data-feather=moon></span></a></div><div class=nav-link id=hamburger-menu-toggle><span class="sr-only hamburger-menu-toggle-screen-reader-target">menu</span>
<a><span data-feather=menu></span></a></div><ul class="nav-hamburger-list visibility-hidden"><li class=nav-item><a href=https://blog.hellowood.dev/><span data-feather=home></span> Home</a></li><li class=nav-item><a href=https://blog.hellowood.dev/posts/><span data-feather=book></span> Posts</a></li><li class=nav-item><a href=https://blog.hellowood.dev/tags/><span data-feather=tag></span> Tags</a></li><li class=nav-item><a href=https://github.com/helloworlde><span data-feather=github></span></a></li><li class=nav-item><a href=https://umami.hellowood.dev/share/lab/Blog><span data-feather=pie-chart></span></a></li><li class=nav-item><a href=https://blog.hellowood.dev/index.xml><span data-feather=rss></span></a></li><li class="nav-item dark-theme-toggle"><span class="sr-only dark-theme-toggle-screen-reader-target">theme</span>
<a><span class=theme-toggle-icon data-feather=moon></span></a></li></ul></div></nav></header><main id=content><div class="post container"><div class=post-header-section><h1>树莓派 4B 容器方式安装 OpenWrt 作为软路由</h1><small role=doc-subtitle></small><p class=post-date>2022-07-07
| Updated 2024-09-09</p><ul class=post-tags><li class=post-tag><a href=https://blog.hellowood.dev/tags/openwrt>OpenWrt</a></li><li class=post-tag><a href=https://blog.hellowood.dev/tags/raspberrypi>RaspberryPi</a></li><li class=post-tag><a href=https://blog.hellowood.dev/tags/homelab>HomeLab</a></li></ul></div><div class=post-content><blockquote><p>在树莓派 4B，基于 Ubuntu 22.04，使用 Docker 容器的方式运行 Openwrt 作为软路由，基于 <a href=https://github.com/SuLingGG/OpenWrt-Docker>SuLingGG/OpenWrt-Docker</a> 的方案</p></blockquote><ul><li>什么是软路由</li></ul><p>硬路由以特有的硬设备，包括处理器、电源供应、嵌入式软件，提供设定的路由器功能，如常用的路由器；软路由则是指利用台式机或服务器配合软件形成路由解决方案，主要靠软件的设置，达成路由器的功能；</p><p>普通路由器因为硬件性能限制，无法支持长时间处理大量流量，当家中有 NAS 等设备时，通常无法跑满带宽；通过软路由，可以让路由器只处理流量的转发，其他的功能由软路由实现</p><p>通常我们使用软路由用于多线负载、宽带叠加、为局域网内的其他设备过滤广告、自定义 DNS 等扩展功能</p><h2 id=安装依赖>安装依赖</h2><ul><li>安装 <a href=https://ubuntu.pkgs.org/21.10/ubuntu-main-arm64/linux-modules-extra-raspi_5.13.0.1008.14_arm64.deb.html>linux-modules-extra-raspi</a></li></ul><p>需要保证安装了<code>linux-modules-extra-raspi</code>，否则会导致在运行容器后出现<code>Error response from daemon: failed to create the macvlan port: operation not supported</code>错误</p><p><code>linux-modules-extra-raspi</code> 是树莓派 Ubuntu Arm 的不常用扩展，Ubuntu 最新的包管理中默认不包含扩展；因此需要单独安装</p><div class=highlight><pre tabindex=0 style=color:#b0c4de;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>sudo apt install linux-modules-extra-raspi
</span></span></code></pre></div><p>安装之后需要重启树莓派</p><div class=highlight><pre tabindex=0 style=color:#b0c4de;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>sudo reboot
</span></span></code></pre></div><h2 id=配置网络>配置网络</h2><ul><li>开启网卡混杂模式</li></ul><p>默认情况下网卡只会将发送给本机的包传递到上层服务，其他的包一律丢弃；开启混杂模式后机器的网卡能够接收所有流经过它的数据流，而无论其目的地址是否是它，一般用于网络分析和路由节点；</p><p>树莓派只有一个有线接口，地址为 <code>eth0</code>，所以在 <code>eth0</code> 接口开启混杂模式</p><div class=highlight><pre tabindex=0 style=color:#b0c4de;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>sudo ip link <span style=color:#ef8383>set</span> eth0 promisc on
</span></span></code></pre></div><p>执行以下命令检查结果</p><div class=highlight><pre tabindex=0 style=color:#b0c4de;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>ifconfig eth0
</span></span></code></pre></div><p>网卡 flag 信息有 <code>PROMISC</code> 表示开启成功</p><pre tabindex=0><code>eth0: flags=4419&lt;UP,BROADCAST,RUNNING,PROMISC,MULTICAST&gt;  mtu 1500
inet 192.168.31.2  netmask 255.255.255.0  broadcast 192.168.31.255
inet6 2408:8207:24ac:6fc0::50c  prefixlen 128  scopeid 0x0&lt;global&gt;
    inet6 fe80::dea6:32ff:fe5f:b43e  prefixlen 64  scopeid 0x20&lt;link&gt;
    inet6 2408:8207:24ac:6fc0:dea6:32ff:fe5f:b43e  prefixlen 64  scopeid 0x0&lt;global&gt;
        ether dc:a6:32:5f:b4:3e  txqueuelen 1000  (Ethernet)
        RX packets 2705601  bytes 1502740361 (1.5 GB)
        RX errors 0  dropped 55  overruns 0  frame 0
        TX packets 2314782  bytes 826118897 (826.1 MB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0
        ```


## 配置 OpenWrt 容器

1. 创建 `macvlan`

`macvlan` 是一种网卡虚拟化技术，允许在同一个物理网卡上配置多个 MAC 地址，即多个 `interface`，每个 `interface` 可以配置自己的 IP；`macvlan`直接通过以太网的 `interface` 连接到物理网络，因此性能极好

因此，软路由需要使用 `macvlan` 配合混杂模式在容器中实现路由功能

Docker 创建 `macvlan` 时要确定所在的网段，可以在路由器后台进行确认；如小米路由器常用的是 `192.168.31.0/24`网段；在创建网络时需要保证子网网段`subnet`和网关地址`gateway`参数与当前网络一致

```bash
docker network create -d macvlan --subnet=192.168.31.0/24 --gateway=192.168.31.1 -o parent=eth0 macnet
</code></pre><ol start=2><li>创建容器</li></ol><p>创建容器时需要指定网络为刚才创建的 <code>macnet</code></p><div class=highlight><pre tabindex=0 style=color:#b0c4de;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>docker run --restart always --name openwrt -d --network macnet --privileged   sulinggg/openwrt:rpi4 /sbin/init
</span></span></code></pre></div><ol start=3><li>修改容器网络配置</li></ol><p>容器成功运行后还无法直接使用，需要进入到容器中修改 OpenWrt 的网络配置</p><div class=highlight><pre tabindex=0 style=color:#b0c4de;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>docker <span style=color:#ef8383>exec</span> -it openwrt bash
</span></span></code></pre></div><p>修改网络</p><div class=highlight><pre tabindex=0 style=color:#b0c4de;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>vi /etc/config/network
</span></span></code></pre></div><ul><li><code>ipaddr</code> 为 OpenWrt 分配 IP 地址，因为 OpenWrt 使用了独立的 Mac 地址，所以这个 IP 地址不能和树莓派的相同，否则会无法访问；如树莓派的 IP 地址为 <code>192.168.31.2</code>，可以将 OpenWrt 的 IP 改为 <code>192.168.31.4</code></li><li><code>gateway</code> 为当前局域网的网关地址，即 <code>192.168.31.1</code></li><li><code>dns</code> 需要指定 DNS，否则无法将域名解析为 IP，建议使用路由器的地址，或者使用 <code>114.114.114.114</code>等常用 DNS 服务器</li></ul><p>需要注意的是，使用到的 IP 都应该是固定的，可以在路由器中配置 DHCP 进行 Mac 地址绑定</p><div class=highlight><pre tabindex=0 style=color:#b0c4de;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>config interface <span style=color:#98c379>&#39;lan&#39;</span>
</span></span><span style=display:flex><span>option <span style=color:#ef8383>type</span> <span style=color:#98c379>&#39;bridge&#39;</span>
</span></span><span style=display:flex><span>option ifname <span style=color:#98c379>&#39;eth0&#39;</span>
</span></span><span style=display:flex><span>option proto <span style=color:#98c379>&#39;static&#39;</span>
</span></span><span style=display:flex><span>option netmask <span style=color:#98c379>&#39;255.255.255.0&#39;</span>
</span></span><span style=display:flex><span>option ip6assign <span style=color:#98c379>&#39;60&#39;</span>
</span></span><span style=display:flex><span>option ipaddr <span style=color:#98c379>&#39;192.168.31.4&#39;</span>
</span></span><span style=display:flex><span>option gateway <span style=color:#98c379>&#39;192.168.31.1&#39;</span>
</span></span><span style=display:flex><span>option dns <span style=color:#98c379>&#39;114.114.114.114&#39;</span>
</span></span></code></pre></div><p>修改完成后重启容器的网络</p><div class=highlight><pre tabindex=0 style=color:#b0c4de;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>/etc/init.d/network restart
</span></span></code></pre></div><p>重启完成后访问 <a href=http://192.168.31.4>http://192.168.31.4</a>，使用账户 <code>root</code> 和密码 <code>password</code> 即可进入管理页面</p><ol start=4><li>OpenWrt 配置</li></ol><p>登录后在 <code>网络-接口</code>中修改 <code>LAN</code> 接口，在底层基本设置中选择<code>忽略此接口</code>，使用默认路由器做 DHCP 服务器
<img src=https://img.hellowood.dev/picture/openwrt-config-dhcp.png alt=openwrt-config-dhcp.png></p><h2 id=使用-openwrt>使用 OpenWrt</h2><p>有两种使用方式：</p><p>一种是将 OpenWrt 作为路由器的网关，这样所有使用路由器的设备的流量都会被 OpenWrt 处理，这种方式要求路由器支持指定网关(辣鸡小米路由器没有 root 不支持指定，且官方已不支持 root)，并且 OpenWrt 足够稳定，否则会影响使用；</p><p>另一种方式是通过在设备端指定 OpenWrt 作为网关，只有这些设备的流量会被软路由处理，这种方式需要设备端支持（大部分 IoT 设备无法配置）
<img src=https://img.hellowood.dev/picture/openwrt-usage-mac.png alt=openwrt-usage-mac.png></p><h2 id=配置重启后网卡默认使用混杂模式>配置重启后网卡默认使用混杂模式</h2><p>网卡的混杂模式会在系统重启后失效，需要在系统启动后自定配置混杂模式，参考 <a href=https://askubuntu.com/questions/1355974/how-to-enable-promiscuous-mode-permanently-on-a-nic-managed-by-networkmanager>How to enable Promiscuous Mode permanently on a NIC managed by NetworkManager?</a>，通过注册一个单独的服务启用网卡混杂模式</p><ol><li>添加 <code>oneshot</code>服务，在网络启动之后执行，配置 <code>eth0</code> 网卡为混杂模式</li></ol><div class=highlight><pre tabindex=0 style=color:#b0c4de;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>sudo bash -c <span style=color:#98c379>&#39;cat &gt; /etc/systemd/system/eth0-promisc.service&#39;</span> <span style=color:#98c379>&lt;&lt;&#39;EOS&#39;
</span></span></span><span style=display:flex><span><span style=color:#98c379>[Unit]
</span></span></span><span style=display:flex><span><span style=color:#98c379>Description=Makes interfaces run in promiscuous mode at boot
</span></span></span><span style=display:flex><span><span style=color:#98c379>After=network-online.target
</span></span></span><span style=display:flex><span><span style=color:#98c379>
</span></span></span><span style=display:flex><span><span style=color:#98c379>[Service]
</span></span></span><span style=display:flex><span><span style=color:#98c379>Type=oneshot
</span></span></span><span style=display:flex><span><span style=color:#98c379>ExecStart=/usr/sbin/ip link set dev eth0 promisc on
</span></span></span><span style=display:flex><span><span style=color:#98c379>TimeoutStartSec=0
</span></span></span><span style=display:flex><span><span style=color:#98c379>RemainAfterExit=yes
</span></span></span><span style=display:flex><span><span style=color:#98c379>
</span></span></span><span style=display:flex><span><span style=color:#98c379>[Install]
</span></span></span><span style=display:flex><span><span style=color:#98c379>WantedBy=default.target
</span></span></span><span style=display:flex><span><span style=color:#98c379>EOS</span>
</span></span></code></pre></div><ol start=2><li>启用注册的服务</li></ol><div class=highlight><pre tabindex=0 style=color:#b0c4de;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>sudo systemctl <span style=color:#ef8383>enable</span> eth0-promisc
</span></span></code></pre></div><p>这样，在系统重启后依然可以正常使用 OpenWrt</p><h2 id=修复宿主机与-openwrt-无法通信问题>修复宿主机与 OpenWrt 无法通信问题</h2><p>Docker 的 <code>macvlan</code> 为了安全禁止宿主机与容器通信，因此宿主机和 OpenWrt 无法互相访问，导致宿主机上的一些监控无法从 OpenWrt 拉取数据；可以通过在宿主机上再创建一个 <code>macvlan</code> 接口，修改路由规则解决该问题</p><h3 id=配置-macvlan-接口>配置 macvlan 接口</h3><ul><li>宿主机创建 <code>macvlan</code> 接口</li></ul><p>在宿主机上添加了一个新的 <code>macvlan</code> 桥接 <code>eth0</code> 的接口，名称为 <code>openwrt-bridge</code></p><div class=highlight><pre tabindex=0 style=color:#b0c4de;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>ip link add openwrt-bridge link eth0 <span style=color:#ef8383>type</span> macvlan mode bridge
</span></span></code></pre></div><ul><li>为 <code>openwrt-bridge</code> 接口配置 IP 并启用</li></ul><p>为 <code>openwrt-bridge</code> 接口配置不冲突的 IP地址 <code>192.168.31.6</code>，并启用该接口</p><div class=highlight><pre tabindex=0 style=color:#b0c4de;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>ip addr add 192.168.31.6 dev openwrt-bridge
</span></span><span style=display:flex><span>ip link <span style=color:#ef8383>set</span> openwrt-bridge up
</span></span></code></pre></div><ul><li>配置路由规则，添加 OpenWrt</li></ul><p>将 OpenWrt 的 IP 地址添加到 <code>openwrt-bridge</code> 接口的路由规则中，即可实现宿主机与 OpenWrt 容器的互相通信</p><div class=highlight><pre tabindex=0 style=color:#b0c4de;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>ip route add 192.168.31.4 dev openwrt-bridge
</span></span></code></pre></div><h3 id=配置重启后自动使用-macvlan-接口>配置重启后自动使用 macvlan 接口</h3><p>同样通过添加一个 <code>oneshot</code>服务的方式配置</p><ol><li>添加 <code>oneshot</code>服务，在网络启动之后执行，添加 <code>macvlan</code> 网卡</li></ol><div class=highlight><pre tabindex=0 style=color:#b0c4de;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>sudo bash -c <span style=color:#98c379>&#39;cat &gt; /etc/systemd/system/openwrt-bridge.service&#39;</span> <span style=color:#98c379>&lt;&lt;&#39;EOS&#39;
</span></span></span><span style=display:flex><span><span style=color:#98c379>[Unit]
</span></span></span><span style=display:flex><span><span style=color:#98c379>Description=Add network interface for openwrt at boot
</span></span></span><span style=display:flex><span><span style=color:#98c379>After=network-online.target
</span></span></span><span style=display:flex><span><span style=color:#98c379>
</span></span></span><span style=display:flex><span><span style=color:#98c379>[Service]
</span></span></span><span style=display:flex><span><span style=color:#98c379>Type=oneshot
</span></span></span><span style=display:flex><span><span style=color:#98c379>ExecStart=/usr/sbin/ip link add openwrt-bridge link eth0 type macvlan mode bridge
</span></span></span><span style=display:flex><span><span style=color:#98c379>ExecStart=/usr/sbin/ip addr add 192.168.31.6 dev openwrt-bridge
</span></span></span><span style=display:flex><span><span style=color:#98c379>ExecStart=/usr/sbin/ip link set openwrt-bridge up
</span></span></span><span style=display:flex><span><span style=color:#98c379>ExecStart=/usr/sbin/ip route add 192.168.31.4 dev openwrt-bridge
</span></span></span><span style=display:flex><span><span style=color:#98c379>ExecStop=/usr/sbin/ip link delete openwrt-bridge
</span></span></span><span style=display:flex><span><span style=color:#98c379>TimeoutStartSec=0
</span></span></span><span style=display:flex><span><span style=color:#98c379>RemainAfterExit=yes
</span></span></span><span style=display:flex><span><span style=color:#98c379>
</span></span></span><span style=display:flex><span><span style=color:#98c379>[Install]
</span></span></span><span style=display:flex><span><span style=color:#98c379>WantedBy=default.target
</span></span></span><span style=display:flex><span><span style=color:#98c379>EOS</span>
</span></span></code></pre></div><ol start=2><li>启用注册的服务</li></ol><div class=highlight><pre tabindex=0 style=color:#b0c4de;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>sudo systemctl <span style=color:#ef8383>enable</span> openwrt-bridge
</span></span></code></pre></div><h2 id=参考文档>参考文档</h2><ul><li><a href=%E7%90%86%E8%A7%A3%20macvlan>https://switch-router.gitee.io/blog/macvlan/</a></li><li><a href=https://mlapp.cn/376.html>在Docker 中运行 OpenWrt 旁路网关</a></li><li><a href=https://blog.oddbit.com/post/2018-03-12-using-docker-macvlan-networks/>USING DOCKER MACVLAN NETWORKS</a></li><li><a href=https://stackoverflow.com/questions/39032100/what-is-the-difference-between-systemds-oneshot-and-simple-service-types>What is the difference between systemd&rsquo;s &lsquo;oneshot&rsquo; and &lsquo;simple&rsquo; service types?</a></li><li><a href=https://trstringer.com/simple-vs-oneshot-systemd-service/>Simple vs Oneshot - Choosing a systemd Service Type</a></li></ul></div><div class=prev-next></div><svg id="btt-button" class="arrow-logo" height="1em" viewBox="0 0 384 512" onclick="scrollToTop()" title="Go to top"><path d="M177 159.7l136 136c9.4 9.4 9.4 24.6.0 33.9l-22.6 22.6c-9.4 9.4-24.6 9.4-33.9.0L160 255.9l-96.4 96.4c-9.4 9.4-24.6 9.4-33.9.0L7 329.7c-9.4-9.4-9.4-24.6.0-33.9l136-136c9.4-9.5 24.6-9.5 34-.1z"/></svg>
<script>let backToTopButton=document.getElementById("btt-button");window.onscroll=function(){scrollFunction()};function scrollFunction(){document.body.scrollTop>20||document.documentElement.scrollTop>20?backToTopButton.style.display="block":backToTopButton.style.display="none"}function scrollToTop(){window.scrollTo(0,0)}</script><div id=comments><script src=https://utteranc.es/client.js repo=helloworlde/helloworlde.github.io issue-term=title theme=github-light crossorigin=anonymous async></script></div></div></main><footer class=footer><span>&copy; 2024 hellowood.dev</span>
<span>Made with &#10084;&#65039; using <a target=_blank href=https://github.com/526avijitgupta/gokarna>Gokarna</a></span></footer></body></html>