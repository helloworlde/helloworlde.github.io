<!doctype html><html lang=en><head><meta name=viewport content="width=device-width,initial-scale=1"><title>gRPC 命名解析</title>
<meta charset=utf-8><meta name=description content="Ladder@gRPC 命名解析 命名解析根据服务的 URI，从注册中心获取并解析服务实例 IP，默认支持 schema 为 DNS，grpclb，xds 等
gRPC 的命名解析的父类接口是 NameResolver NameResolver 包含有多个子类，用于实现命名解析 每个 NameResolver 都有一个 Provider，用于创建 NameResolver 实例；所有的 Provider 都注册到 NameResolverRegistry 中，NameResolverRegistry 创建 Factory 实例，最终通过 Provider 创建 NameResolver
命名解析的整个工作流程是：
使用 NameResolverRegistry 或者 SPI 方式注册 Provider 调用 Channel 的 build 方法创建 NameResovler.Factory 根据 Factory 最终调用 Provider 创建 NameResolver， 创建 Listener 的实例 调用 NameResolver 的 start 方法，传入 Listener 实例 创建 Runnable 任务，通过调用 Listener 的 onResult 方法进行更新 创建 NameResolver 在 Channel 调用 build 方式时，会在 io."><meta name=author content="HelloWood"><link rel=canonical href=https://blog.hellowood.dev/posts/grpc-%E5%91%BD%E5%90%8D%E8%A7%A3%E6%9E%90/><meta name=google-site-verification content="G-3MSGPYTHPZ"><link rel=alternate type=application/rss+xml href=https://blog.hellowood.dev/index.xml title=HelloWood><script async src="https://www.googletagmanager.com/gtag/js?id=G-3MSGPYTHPZ"></script><script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-3MSGPYTHPZ",{anonymize_ip:!1})}</script><script async defer data-website-id=7a9034de-0ce7-4756-942a-829e6cd22301 src=https://umami.hellowood.dev/script.js></script><script defer data-cf-beacon='{"token": "b2e481d136dc428c8c96c8673e2a04cf"}' src=https://static.cloudflareinsights.com/beacon.min.js></script><meta property="og:title" content="gRPC 命名解析"><meta property="og:description" content="gRPC 命名解析 命名解析根据服务的 URI，从注册中心获取并解析服务实例 IP，默认支持 schema 为 DNS，grpclb，xds 等
gRPC 的命名解析的父类接口是 NameResolver NameResolver 包含有多个子类，用于实现命名解析 每个 NameResolver 都有一个 Provider，用于创建 NameResolver 实例；所有的 Provider 都注册到 NameResolverRegistry 中，NameResolverRegistry 创建 Factory 实例，最终通过 Provider 创建 NameResolver
命名解析的整个工作流程是：
使用 NameResolverRegistry 或者 SPI 方式注册 Provider 调用 Channel 的 build 方法创建 NameResovler.Factory 根据 Factory 最终调用 Provider 创建 NameResolver， 创建 Listener 的实例 调用 NameResolver 的 start 方法，传入 Listener 实例 创建 Runnable 任务，通过调用 Listener 的 onResult 方法进行更新 创建 NameResolver 在 Channel 调用 build 方式时，会在 io."><meta property="og:type" content="article"><meta property="og:url" content="https://blog.hellowood.dev/posts/grpc-%E5%91%BD%E5%90%8D%E8%A7%A3%E6%9E%90/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-09-20T22:35:22+00:00"><meta property="article:modified_time" content="2020-09-20T22:35:22+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="gRPC 命名解析"><meta name=twitter:description content="gRPC 命名解析 命名解析根据服务的 URI，从注册中心获取并解析服务实例 IP，默认支持 schema 为 DNS，grpclb，xds 等
gRPC 的命名解析的父类接口是 NameResolver NameResolver 包含有多个子类，用于实现命名解析 每个 NameResolver 都有一个 Provider，用于创建 NameResolver 实例；所有的 Provider 都注册到 NameResolverRegistry 中，NameResolverRegistry 创建 Factory 实例，最终通过 Provider 创建 NameResolver
命名解析的整个工作流程是：
使用 NameResolverRegistry 或者 SPI 方式注册 Provider 调用 Channel 的 build 方法创建 NameResovler.Factory 根据 Factory 最终调用 Provider 创建 NameResolver， 创建 Listener 的实例 调用 NameResolver 的 start 方法，传入 Listener 实例 创建 Runnable 任务，通过调用 Listener 的 onResult 方法进行更新 创建 NameResolver 在 Channel 调用 build 方式时，会在 io."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://blog.hellowood.dev/posts/"},{"@type":"ListItem","position":3,"name":"gRPC 命名解析","item":"https://blog.hellowood.dev/posts/grpc-%E5%91%BD%E5%90%8D%E8%A7%A3%E6%9E%90/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"gRPC 命名解析","name":"gRPC 命名解析","description":"gRPC 命名解析 命名解析根据服务的 URI，从注册中心获取并解析服务实例 IP，默认支持 schema 为 DNS，grpclb，xds 等\ngRPC 的命名解析的父类接口是 NameResolver NameResolver 包含有多个子类，用于实现命名解析 每个 NameResolver 都有一个 Provider，用于创建 NameResolver 实例；所有的 Provider 都注册到 NameResolverRegistry 中，NameResolverRegistry 创建 Factory 实例，最终通过 Provider 创建 NameResolver\n命名解析的整个工作流程是：\n使用 NameResolverRegistry 或者 SPI 方式注册 Provider 调用 Channel 的 build 方法创建 NameResovler.Factory 根据 Factory 最终调用 Provider 创建 NameResolver， 创建 Listener 的实例 调用 NameResolver 的 start 方法，传入 Listener 实例 创建 Runnable 任务，通过调用 Listener 的 onResult 方法进行更新 创建 NameResolver 在 Channel 调用 build 方式时，会在 io.","keywords":["gRPC"],"articleBody":"gRPC 命名解析 命名解析根据服务的 URI，从注册中心获取并解析服务实例 IP，默认支持 schema 为 DNS，grpclb，xds 等\ngRPC 的命名解析的父类接口是 NameResolver NameResolver 包含有多个子类，用于实现命名解析 每个 NameResolver 都有一个 Provider，用于创建 NameResolver 实例；所有的 Provider 都注册到 NameResolverRegistry 中，NameResolverRegistry 创建 Factory 实例，最终通过 Provider 创建 NameResolver\n命名解析的整个工作流程是：\n使用 NameResolverRegistry 或者 SPI 方式注册 Provider 调用 Channel 的 build 方法创建 NameResovler.Factory 根据 Factory 最终调用 Provider 创建 NameResolver， 创建 Listener 的实例 调用 NameResolver 的 start 方法，传入 Listener 实例 创建 Runnable 任务，通过调用 Listener 的 onResult 方法进行更新 创建 NameResolver 在 Channel 调用 build 方式时，会在 io.grpc.internal.ManagedChannelImpl#ManagedChannelImpl的构造方法中获取 NameResolver.Factory，这个属性的值是由调用 io.grpc.internal.AbstractManagedChannelImplBuilder#getNameResolverFactory 方法获取的，这个方法里面的属性值来自于 io.grpc.NameResolverRegistry#asFactory,NameResolverRegistry 自己通过内部类 NameResolverFactory创建了NameResovler.Factory 的实例，在io.grpc.internal.ManagedChannelImpl#getNameResolver中调用 Factory 的 newNameResolver时，从 provider 属性中获取根据优先级排序后的 Provider，通过 Provider 创建 NameResolver 实例并返回第一个有效实例\n创建 Channel 时注册 NameResovlerProvider NameResolverRegistry.getDefaultRegistry().register(new DnsNameResolverProvider()); 在 Channel 中获取 Factory // 服务发现工厂 this.nameResolverFactory = builder.getNameResolverFactory(); 在 NameResolverRegistry 中初始化 Factory，构造 NameResolverFactory 实例，在 asFactory 方法中返回 private final NameResolver.Factory factory = new NameResolverFactory(); // 返回该实例 private NameResolver.Factory nameResolverFactory = nameResolverRegistry.asFactory(); 获取 NameResovler 实例 创建 NameResolver 的 Factory 是通过 Channel 的 Builder 传入的，Args 是在 Channel 的构造方法中创建的\nio.grpc.internal.ManagedChannelImpl#ManagedChannelImpl // 命名解析器参数 this.nameResolverArgs = NameResolver.Args.newBuilder() .setDefaultPort(builder.getDefaultPort()) .setProxyDetector(proxyDetector) .setSynchronizationContext(syncContext) .setScheduledExecutorService(scheduledExecutor) .setServiceConfigParser(serviceConfigParser) .setChannelLogger(channelLogger) .setOffloadExecutor( // Avoid creating the offloadExecutor until it is first used new Executor() { @Override public void execute(Runnable command) { offloadExecutorHolder.getExecutor().execute(command); } }) .build(); // 命名解析 this.nameResolver = getNameResolver(target, nameResolverFactory, nameResolverArgs); io.grpc.internal.ManagedChannelImpl#getNameResolver 根据地址，创建 NameResolver 实例，如果 URI 缺少 Schema，则添加默认的 Schema\nstatic NameResolver getNameResolver(String target, NameResolver.Factory nameResolverFactory, NameResolver.Args nameResolverArgs) { // 解析地址 URI targetUri = new URI(target); // 创建 NameResolver if (targetUri != null) { NameResolver resolver = nameResolverFactory.newNameResolver(targetUri, nameResolverArgs); if (resolver != null) { return resolver; } } // 如果不是 URI 格式，则使用默认的 schema if (!URI_PATTERN.matcher(target).matches()) { targetUri = new URI(nameResolverFactory.getDefaultScheme(), \"\", \"/\" + target, null); NameResolver resolver = nameResolverFactory.newNameResolver(targetUri, nameResolverArgs); if (resolver != null) { return resolver; } } throw new IllegalArgumentException(String.format(\"cannot find a NameResolver for %s%s\", target, uriSyntaxErrors.length() \u003e 0 ? \" (\" + uriSyntaxErrors + \")\" : \"\")); } io.grpc.internal.DnsNameResolverProvider#newNameResolver 在 NameResolverProvider 中创建 NameResolver，调用具体实现类的构造方法，初始化相应的参数\npublic DnsNameResolver newNameResolver(URI targetUri, NameResolver.Args args) { // 如果是 DNS 开头的 Schema if (SCHEME.equals(targetUri.getScheme())) { // 检查要解析的服务不为空，且以斜线开头 String targetPath = Preconditions.checkNotNull(targetUri.getPath(), \"targetPath\"); Preconditions.checkArgument(targetPath.startsWith(\"/\"), \"the path component (%s) of the target (%s) must start with '/'\", targetPath, targetUri); // 截取斜线之后的部分作为服务名 String name = targetPath.substring(1); // 创建 DNS 服务解析器 return new DnsNameResolver( targetUri.getAuthority(), name, args, GrpcUtil.SHARED_CHANNEL_EXECUTOR, Stopwatch.createUnstarted(), InternalServiceProviders.isAndroid(getClass().getClassLoader())); } else { // 如果不是 DNS 开头的则返回 null return null; } } Listener io.grpc.internal.ManagedChannelImpl#exitIdleMode 创建负载均衡，和服务解析实例作为参数，创建 Listener\nvoid exitIdleMode() { LbHelperImpl lbHelper = new LbHelperImpl(); // 自动配置负载均衡 lbHelper.lb = loadBalancerFactory.newLoadBalancer(lbHelper); this.lbHelper = lbHelper; // 服务发现监听器 NameResolverListener listener = new NameResolverListener(lbHelper, nameResolver); nameResolver.start(listener); } io.grpc.internal.DnsNameResolver#start start 方法最终通过线程池执行 Resolve 任务\n@Override public void start(Listener2 listener) { if (usingExecutorResource) { executor = SharedResourceHolder.get(executorResource); } // 解析 resolve(); } private void resolve() { if (resolving || shutdown || !cacheRefreshRequired()) { return; } resolving = true; // 根据监听器，解析名称 executor.execute(new Resolve(listener)); } 解析地址 io.grpc.internal.DnsNameResolver.Resolve Resolve 实现了 Runnable 接口，在 run 方法中，先调用 doResolve 方法，将目标 URI 解析为地址集合，同时也会获取配置 然后根据获取的地址和配置为 ResolutionResult.Builder 赋值，调用 Listener2 的 onResult 方法处理更新的结果\nprivate final class Resolve implements Runnable { private final Listener2 savedListener; /** * 从 DNS 解析服务 */ @Override public void run() { InternalResolutionResult result = null; try { ResolutionResult.Builder resolutionResultBuilder = ResolutionResult.newBuilder(); // 代理的地址 // 根据 HOST 解析地址和配置 result = doResolve(false); if (result.error != null) { savedListener.onError(result.error); return; } // 如果有地址，则设置地址 if (result.addresses != null) { resolutionResultBuilder.setAddresses(result.addresses); } if (result.config != null) { resolutionResultBuilder.setServiceConfig(result.config); } if (result.attributes != null) { resolutionResultBuilder.setAttributes(result.attributes); } // 更新负载均衡策略，处理未处理的请求 savedListener.onResult(resolutionResultBuilder.build()); } catch (IOException e) { savedListener.onError(Status.UNAVAILABLE.withDescription(\"Unable to resolve host \" + host).withCause(e)); } } } 更新实例 io.grpc.internal.ManagedChannelImpl.NameResolverListener#onResult NameResolverListener 是 Listener2 的实现类；Listener2 是 Listener 接口的抽象实现，新增了一个 onResult 方法\n在 onResult 方法中有个 Runnable，run 方法会根据传入的结果，更新服务的配置；然后根据实例地址，更新负载均衡的实例列表\n任务由 SynchronizationContext 执行\n@Override public void onResult(final ResolutionResult resolutionResult) { final class NamesResolved implements Runnable { @Override public void run() { List\u003cEquivalentAddressGroup\u003e servers = resolutionResult.getAddresses(); // 更新传入的配置 ... ManagedChannelServiceConfig effectiveServiceConfig; handleServiceConfigUpdate(); // 获取属性 Attributes effectiveAttrs = resolutionResult.getAttributes(); // 如果服务发现没有关闭 if (NameResolverListener.this.helper == ManagedChannelImpl.this.lbHelper) { // 更新负载均衡实例 Status handleResult = helper.lb.tryHandleResolvedAddresses( ResolvedAddresses.newBuilder() .setAddresses(servers) .setAttributes(effectiveAttrs) .setLoadBalancingPolicyConfig(effectiveServiceConfig.getLoadBalancingConfig()) .build()); } } } // 执行处理 syncContext.execute(new NamesResolved()); } ","wordCount":"619","inLanguage":"en","datePublished":"2020-09-20T22:35:22Z","dateModified":"2020-09-20T22:35:22Z","author":{"@type":"Person","name":"HelloWood"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.hellowood.dev/posts/grpc-%E5%91%BD%E5%90%8D%E8%A7%A3%E6%9E%90/"},"publisher":{"@type":"Organization","name":"HelloWood","logo":{"@type":"ImageObject","url":"https://blog.hellowood.dev/favicon.ico"}}}</script><link rel=icon href=/images/avatar.png sizes=16x16><link rel=apple-touch-icon href=/images/avatar.png><link rel=manifest href=/images/avatar.png><link rel=stylesheet href=https://cdn.staticfile.org/lxgw-wenkai-webfont/1.6.0/style.css><link rel=stylesheet href=/css/main.min.ff1bc260fafbfb440e10194d7d06d57eb5e85eed11d12d06255581262664204e.css integrity="sha256-/xvCYPr7+0QOEBlNfQbVfrXoXu0R0S0GJVWBJiZkIE4=" crossorigin=anonymous media=screen><link rel=stylesheet href=/scss/highlight/github-dark.min.min.66034289ee9a113219a2c4aae0a8bd2095ab255c832a42efcf5863f10814e7a1.css><script src=/js/highlight.min.min.894ca9c68afab956438c4926a0dc7f5293e04e08595bd27abdb123e94801f684.js></script><script>hljs.highlightAll()</script><script>(()=>{var t=window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches,e=localStorage.getItem("theme");t&&e===null&&(localStorage.setItem("theme","dark"),document.documentElement.setAttribute("data-dark-mode","")),t&&e==="dark"&&document.documentElement.setAttribute("data-dark-mode",""),e==="dark"&&document.documentElement.setAttribute("data-dark-mode","")})()</script><script type=text/javascript>(function(e,t,n,s,o,i,a){e[n]=e[n]||function(){(e[n].q=e[n].q||[]).push(arguments)},i=t.createElement(s),i.async=1,i.src="https://www.clarity.ms/tag/"+o,a=t.getElementsByTagName(s)[0],a.parentNode.insertBefore(i,a)})(window,document,"clarity","script","jtbhx98g62")</script></head><body><main class=wrapper><nav class=navigation><section class=container><a class=navigation-brand data-umami-event=navigation-brand href=/>HOME
</a><input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><span></span><span></span><span></span></label><ul class=navigation-list id=navigation-list><li class="navigation-item navigation-menu"><a class=navigation-link data-umami-event=Blog href=/posts>Blog</a></li><li class="navigation-item navigation-menu"><a class=navigation-link data-umami-event=Tags href=/tags>Tags</a></li><li class="navigation-item navigation-menu"><a class=navigation-link data-umami-event=Archive href=/archives>Archive</a></li><li class="navigation-item navigation-menu"><a class=navigation-link data-umami-event=Dashboard href=https://umami.hellowood.dev/share/lab/Blog>Dashboard</a></li><li class="navigation-item menu-separator"><span>|</span></li><li class="navigation-item navigation-social"><a class=navigation-link data-umami-event=navigation-social href=https://github.com/helloworlde><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a></li><li class="navigation-item navigation-dark"><button id=mode type=button data-umami-event=toggle-theme aria-label="toggle user light or dark theme">
<span class=toggle-dark><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-moon"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg></span><span class=toggle-light><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-sun"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></span></button></li></ul></section></nav><div id=content><article class=blog-single><header class=blog-title><h1>gRPC 命名解析</h1></header><p><small>September 20, 2020&nbsp;· 619 words&nbsp;· 3 min</small><p><div class=blog-toc><nav id=TableOfContents><ul><li><a href=#创建-nameresolver>创建 NameResolver</a></li><li><a href=#listener>Listener</a></li><li><a href=#解析地址>解析地址</a></li><li><a href=#更新实例>更新实例</a></li></ul></nav></div><section class=blog-content><h1 id=grpc-命名解析>gRPC 命名解析</h1><p>命名解析根据服务的 URI，从注册中心获取并解析服务实例 IP，默认支持 schema 为 DNS，grpclb，xds 等</p><p><img src=https://hellowoodes.oss-cn-beijing.aliyuncs.com/picture/grpc-source-code-name-resolver-diagram.png alt=grpc-source-code-name-resolver-diagram.png></p><p>gRPC 的命名解析的父类接口是 <code>NameResolver</code>
<img src=https://hellowoodes.oss-cn-beijing.aliyuncs.com/picture/grpc-source-code-name-resolver-class.png alt=grpc-source-code-name-resolver-class.png></p><p><code>NameResolver</code> 包含有多个子类，用于实现命名解析
每个 <code>NameResolver</code> 都有一个 <code>Provider</code>，用于创建 <code>NameResolver</code> 实例；所有的 <code>Provider</code> 都注册到 <code>NameResolverRegistry</code> 中，<code>NameResolverRegistry</code> 创建 <code>Factory</code> 实例，最终通过 <code>Provider</code> 创建 <code>NameResolver</code></p><p><img src=https://hellowoodes.oss-cn-beijing.aliyuncs.com/picture/grpc-source-code-name-resolver-with-sub-class.png alt=grpc-source-code-name-resolver-with-sub-class.png></p><p>命名解析的整个工作流程是：</p><ol><li>使用 <code>NameResolverRegistry</code> 或者 SPI 方式注册 Provider</li><li>调用 Channel 的 <code>build</code> 方法创建 <code>NameResovler.Factory</code></li><li>根据 Factory 最终调用 Provider 创建 <code>NameResolver</code>，</li><li>创建 <code>Listener</code> 的实例</li><li>调用 <code>NameResolver</code> 的 <code>start</code> 方法，传入 <code>Listener</code> 实例</li><li>创建 <code>Runnable</code> 任务，通过调用 <code>Listener</code> 的 <code>onResult</code> 方法进行更新</li></ol><h2 id=创建-nameresolver>创建 NameResolver</h2><p>在 Channel 调用 <code>build</code> 方式时，会在 <code>io.grpc.internal.ManagedChannelImpl#ManagedChannelImpl</code>的构造方法中获取 <code>NameResolver.Factory</code>，这个属性的值是由调用 <code>io.grpc.internal.AbstractManagedChannelImplBuilder#getNameResolverFactory</code> 方法获取的，这个方法里面的属性值来自于 <code>io.grpc.NameResolverRegistry#asFactory</code>,<code>NameResolverRegistry</code> 自己通过内部类 <code>NameResolverFactory</code>创建了<code>NameResovler.Factory</code> 的实例，在<code>io.grpc.internal.ManagedChannelImpl#getNameResolver</code>中调用 Factory 的 <code>newNameResolver</code>时，从 <code>provider</code> 属性中获取根据优先级排序后的 Provider，通过 Provider 创建 <code>NameResolver</code> 实例并返回第一个有效实例</p><ol><li>创建 Channel 时注册 <code>NameResovlerProvider</code></li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>NameResolverRegistry.<span style=color:#a6e22e>getDefaultRegistry</span>().<span style=color:#a6e22e>register</span>(<span style=color:#66d9ef>new</span> DnsNameResolverProvider());
</span></span></code></pre></div><ol start=2><li>在 Channel 中获取 <code>Factory</code></li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// 服务发现工厂</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>nameResolverFactory</span> <span style=color:#f92672>=</span> builder.<span style=color:#a6e22e>getNameResolverFactory</span>();
</span></span></code></pre></div><ol start=3><li>在 <code>NameResolverRegistry</code> 中初始化 <code>Factory</code>，构造 <code>NameResolverFactory</code> 实例，在 <code>asFactory</code> 方法中返回</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>final</span> NameResolver.<span style=color:#a6e22e>Factory</span> factory <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> NameResolverFactory();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 返回该实例</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span> NameResolver.<span style=color:#a6e22e>Factory</span> nameResolverFactory <span style=color:#f92672>=</span> nameResolverRegistry.<span style=color:#a6e22e>asFactory</span>();
</span></span></code></pre></div><ol start=4><li>获取 <code>NameResovler</code> 实例</li></ol><p>创建 <code>NameResolver</code> 的 <code>Factory</code> 是通过 Channel 的 <code>Builder</code> 传入的，<code>Args</code> 是在 Channel 的构造方法中创建的</p><ul><li>io.grpc.internal.ManagedChannelImpl#ManagedChannelImpl</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>    <span style=color:#75715e>// 命名解析器参数</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>nameResolverArgs</span> <span style=color:#f92672>=</span> NameResolver.<span style=color:#a6e22e>Args</span>.<span style=color:#a6e22e>newBuilder</span>()
</span></span><span style=display:flex><span>                                             .<span style=color:#a6e22e>setDefaultPort</span>(builder.<span style=color:#a6e22e>getDefaultPort</span>())
</span></span><span style=display:flex><span>                                             .<span style=color:#a6e22e>setProxyDetector</span>(proxyDetector)
</span></span><span style=display:flex><span>                                             .<span style=color:#a6e22e>setSynchronizationContext</span>(syncContext)
</span></span><span style=display:flex><span>                                             .<span style=color:#a6e22e>setScheduledExecutorService</span>(scheduledExecutor)
</span></span><span style=display:flex><span>                                             .<span style=color:#a6e22e>setServiceConfigParser</span>(serviceConfigParser)
</span></span><span style=display:flex><span>                                             .<span style=color:#a6e22e>setChannelLogger</span>(channelLogger)
</span></span><span style=display:flex><span>                                             .<span style=color:#a6e22e>setOffloadExecutor</span>(
</span></span><span style=display:flex><span>                                                     <span style=color:#75715e>// Avoid creating the offloadExecutor until it is first used</span>
</span></span><span style=display:flex><span>                                                     <span style=color:#66d9ef>new</span> Executor() {
</span></span><span style=display:flex><span>                                                       <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>                                                       <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>execute</span>(Runnable command) {
</span></span><span style=display:flex><span>                                                         offloadExecutorHolder.<span style=color:#a6e22e>getExecutor</span>().<span style=color:#a6e22e>execute</span>(command);
</span></span><span style=display:flex><span>                                                       }
</span></span><span style=display:flex><span>                                                     })
</span></span><span style=display:flex><span>                                             .<span style=color:#a6e22e>build</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 命名解析</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>nameResolver</span> <span style=color:#f92672>=</span> getNameResolver(target, nameResolverFactory, nameResolverArgs);
</span></span></code></pre></div><ul><li>io.grpc.internal.ManagedChannelImpl#getNameResolver</li></ul><p>根据地址，创建 <code>NameResolver</code> 实例，如果 URI 缺少 <code>Schema</code>，则添加默认的 <code>Schema</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>  <span style=color:#66d9ef>static</span> NameResolver <span style=color:#a6e22e>getNameResolver</span>(String target,
</span></span><span style=display:flex><span>                                      NameResolver.<span style=color:#a6e22e>Factory</span> nameResolverFactory,
</span></span><span style=display:flex><span>                                      NameResolver.<span style=color:#a6e22e>Args</span> nameResolverArgs) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 解析地址</span>
</span></span><span style=display:flex><span>    URI targetUri <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> URI(target);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 创建 NameResolver</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (targetUri <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>      NameResolver resolver <span style=color:#f92672>=</span> nameResolverFactory.<span style=color:#a6e22e>newNameResolver</span>(targetUri, nameResolverArgs);
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> (resolver <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> resolver;
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 如果不是 URI 格式，则使用默认的 schema</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>URI_PATTERN.<span style=color:#a6e22e>matcher</span>(target).<span style=color:#a6e22e>matches</span>()) {
</span></span><span style=display:flex><span>      targetUri <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> URI(nameResolverFactory.<span style=color:#a6e22e>getDefaultScheme</span>(), <span style=color:#e6db74>&#34;&#34;</span>, <span style=color:#e6db74>&#34;/&#34;</span> <span style=color:#f92672>+</span> target, <span style=color:#66d9ef>null</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      NameResolver resolver <span style=color:#f92672>=</span> nameResolverFactory.<span style=color:#a6e22e>newNameResolver</span>(targetUri, nameResolverArgs);
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> (resolver <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> resolver;
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> IllegalArgumentException(String.<span style=color:#a6e22e>format</span>(<span style=color:#e6db74>&#34;cannot find a NameResolver for %s%s&#34;</span>, target, uriSyntaxErrors.<span style=color:#a6e22e>length</span>() <span style=color:#f92672>&gt;</span> 0 <span style=color:#f92672>?</span> <span style=color:#e6db74>&#34; (&#34;</span> <span style=color:#f92672>+</span> uriSyntaxErrors <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;)&#34;</span> : <span style=color:#e6db74>&#34;&#34;</span>));
</span></span><span style=display:flex><span>  }
</span></span></code></pre></div><ul><li>io.grpc.internal.DnsNameResolverProvider#newNameResolver</li></ul><p>在 NameResolverProvider 中创建 NameResolver，调用具体实现类的构造方法，初始化相应的参数</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>    <span style=color:#66d9ef>public</span> DnsNameResolver <span style=color:#a6e22e>newNameResolver</span>(URI targetUri, NameResolver.<span style=color:#a6e22e>Args</span> args) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 如果是 DNS 开头的 Schema</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (SCHEME.<span style=color:#a6e22e>equals</span>(targetUri.<span style=color:#a6e22e>getScheme</span>())) {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 检查要解析的服务不为空，且以斜线开头</span>
</span></span><span style=display:flex><span>            String targetPath <span style=color:#f92672>=</span> Preconditions.<span style=color:#a6e22e>checkNotNull</span>(targetUri.<span style=color:#a6e22e>getPath</span>(), <span style=color:#e6db74>&#34;targetPath&#34;</span>);
</span></span><span style=display:flex><span>            Preconditions.<span style=color:#a6e22e>checkArgument</span>(targetPath.<span style=color:#a6e22e>startsWith</span>(<span style=color:#e6db74>&#34;/&#34;</span>), <span style=color:#e6db74>&#34;the path component (%s) of the target (%s) must start with &#39;/&#39;&#34;</span>, targetPath, targetUri);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 截取斜线之后的部分作为服务名</span>
</span></span><span style=display:flex><span>            String name <span style=color:#f92672>=</span> targetPath.<span style=color:#a6e22e>substring</span>(1);
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 创建 DNS 服务解析器</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> DnsNameResolver(
</span></span><span style=display:flex><span>                    targetUri.<span style=color:#a6e22e>getAuthority</span>(),
</span></span><span style=display:flex><span>                    name,
</span></span><span style=display:flex><span>                    args,
</span></span><span style=display:flex><span>                    GrpcUtil.<span style=color:#a6e22e>SHARED_CHANNEL_EXECUTOR</span>,
</span></span><span style=display:flex><span>                    Stopwatch.<span style=color:#a6e22e>createUnstarted</span>(),
</span></span><span style=display:flex><span>                    InternalServiceProviders.<span style=color:#a6e22e>isAndroid</span>(getClass().<span style=color:#a6e22e>getClassLoader</span>()));
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 如果不是 DNS 开头的则返回 null</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><h2 id=listener>Listener</h2><ul><li>io.grpc.internal.ManagedChannelImpl#exitIdleMode</li></ul><p>创建负载均衡，和服务解析实例作为参数，创建 <code>Listener</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>  <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>exitIdleMode</span>() {
</span></span><span style=display:flex><span>    LbHelperImpl lbHelper <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> LbHelperImpl();
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 自动配置负载均衡</span>
</span></span><span style=display:flex><span>    lbHelper.<span style=color:#a6e22e>lb</span> <span style=color:#f92672>=</span> loadBalancerFactory.<span style=color:#a6e22e>newLoadBalancer</span>(lbHelper);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>lbHelper</span> <span style=color:#f92672>=</span> lbHelper;
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 服务发现监听器</span>
</span></span><span style=display:flex><span>    NameResolverListener listener <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> NameResolverListener(lbHelper, nameResolver);
</span></span><span style=display:flex><span>    nameResolver.<span style=color:#a6e22e>start</span>(listener);
</span></span><span style=display:flex><span>  }
</span></span></code></pre></div><ul><li>io.grpc.internal.DnsNameResolver#start</li></ul><p><code>start</code> 方法最终通过线程池执行 <code>Resolve</code> 任务</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>    <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>start</span>(Listener2 listener) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (usingExecutorResource) {
</span></span><span style=display:flex><span>            executor <span style=color:#f92672>=</span> SharedResourceHolder.<span style=color:#a6e22e>get</span>(executorResource);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 解析</span>
</span></span><span style=display:flex><span>        resolve();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>resolve</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (resolving <span style=color:#f92672>||</span> shutdown <span style=color:#f92672>||</span> <span style=color:#f92672>!</span>cacheRefreshRequired()) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        resolving <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 根据监听器，解析名称</span>
</span></span><span style=display:flex><span>        executor.<span style=color:#a6e22e>execute</span>(<span style=color:#66d9ef>new</span> Resolve(listener));
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><h2 id=解析地址>解析地址</h2><ul><li>io.grpc.internal.DnsNameResolver.Resolve</li></ul><p><code>Resolve</code> 实现了 <code>Runnable</code> 接口，在 <code>run</code> 方法中，先调用 <code>doResolve</code> 方法，将目标 URI 解析为地址集合，同时也会获取配置
然后根据获取的地址和配置为 <code>ResolutionResult.Builder</code> 赋值，调用 <code>Listener2</code> 的 <code>onResult</code> 方法处理更新的结果</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Resolve</span> <span style=color:#66d9ef>implements</span> Runnable {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>final</span> Listener2 savedListener;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * 从 DNS 解析服务
</span></span></span><span style=display:flex><span><span style=color:#75715e>         */</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>run</span>() {
</span></span><span style=display:flex><span>            InternalResolutionResult result <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>                ResolutionResult.<span style=color:#a6e22e>Builder</span> resolutionResultBuilder <span style=color:#f92672>=</span> ResolutionResult.<span style=color:#a6e22e>newBuilder</span>();
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 代理的地址</span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 根据 HOST 解析地址和配置</span>
</span></span><span style=display:flex><span>                result <span style=color:#f92672>=</span> doResolve(<span style=color:#66d9ef>false</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (result.<span style=color:#a6e22e>error</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>                    savedListener.<span style=color:#a6e22e>onError</span>(result.<span style=color:#a6e22e>error</span>);
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 如果有地址，则设置地址</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (result.<span style=color:#a6e22e>addresses</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>                    resolutionResultBuilder.<span style=color:#a6e22e>setAddresses</span>(result.<span style=color:#a6e22e>addresses</span>);
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (result.<span style=color:#a6e22e>config</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>                    resolutionResultBuilder.<span style=color:#a6e22e>setServiceConfig</span>(result.<span style=color:#a6e22e>config</span>);
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (result.<span style=color:#a6e22e>attributes</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>                    resolutionResultBuilder.<span style=color:#a6e22e>setAttributes</span>(result.<span style=color:#a6e22e>attributes</span>);
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 更新负载均衡策略，处理未处理的请求</span>
</span></span><span style=display:flex><span>                savedListener.<span style=color:#a6e22e>onResult</span>(resolutionResultBuilder.<span style=color:#a6e22e>build</span>());
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>catch</span> (IOException e) {
</span></span><span style=display:flex><span>                savedListener.<span style=color:#a6e22e>onError</span>(Status.<span style=color:#a6e22e>UNAVAILABLE</span>.<span style=color:#a6e22e>withDescription</span>(<span style=color:#e6db74>&#34;Unable to resolve host &#34;</span> <span style=color:#f92672>+</span> host).<span style=color:#a6e22e>withCause</span>(e));
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><h2 id=更新实例>更新实例</h2><ul><li>io.grpc.internal.ManagedChannelImpl.NameResolverListener#onResult</li></ul><p><code>NameResolverListener</code> 是 <code>Listener2</code> 的实现类；<code>Listener2</code> 是 <code>Listener</code> 接口的抽象实现，新增了一个 <code>onResult</code> 方法</p><p>在 <code>onResult</code> 方法中有个 <code>Runnable</code>，<code>run</code> 方法会根据传入的结果，更新服务的配置；然后根据实例地址，更新负载均衡的实例列表</p><p>任务由 <code>SynchronizationContext</code> 执行</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>    <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>onResult</span>(<span style=color:#66d9ef>final</span> ResolutionResult resolutionResult) {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>NamesResolved</span> <span style=color:#66d9ef>implements</span> Runnable {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>run</span>() {
</span></span><span style=display:flex><span>          List<span style=color:#f92672>&lt;</span>EquivalentAddressGroup<span style=color:#f92672>&gt;</span> servers <span style=color:#f92672>=</span> resolutionResult.<span style=color:#a6e22e>getAddresses</span>();
</span></span><span style=display:flex><span>          <span style=color:#75715e>// 更新传入的配置 ...</span>
</span></span><span style=display:flex><span>          
</span></span><span style=display:flex><span>          ManagedChannelServiceConfig effectiveServiceConfig;
</span></span><span style=display:flex><span>          handleServiceConfigUpdate();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>          <span style=color:#75715e>// 获取属性</span>
</span></span><span style=display:flex><span>          Attributes effectiveAttrs <span style=color:#f92672>=</span> resolutionResult.<span style=color:#a6e22e>getAttributes</span>();
</span></span><span style=display:flex><span>          <span style=color:#75715e>// 如果服务发现没有关闭</span>
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>if</span> (NameResolverListener.<span style=color:#a6e22e>this</span>.<span style=color:#a6e22e>helper</span> <span style=color:#f92672>==</span> ManagedChannelImpl.<span style=color:#a6e22e>this</span>.<span style=color:#a6e22e>lbHelper</span>) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 更新负载均衡实例</span>
</span></span><span style=display:flex><span>            Status handleResult <span style=color:#f92672>=</span> helper.<span style=color:#a6e22e>lb</span>.<span style=color:#a6e22e>tryHandleResolvedAddresses</span>(
</span></span><span style=display:flex><span>                    ResolvedAddresses.<span style=color:#a6e22e>newBuilder</span>()
</span></span><span style=display:flex><span>                                     .<span style=color:#a6e22e>setAddresses</span>(servers)
</span></span><span style=display:flex><span>                                     .<span style=color:#a6e22e>setAttributes</span>(effectiveAttrs)
</span></span><span style=display:flex><span>                                     .<span style=color:#a6e22e>setLoadBalancingPolicyConfig</span>(effectiveServiceConfig.<span style=color:#a6e22e>getLoadBalancingConfig</span>())
</span></span><span style=display:flex><span>                                     .<span style=color:#a6e22e>build</span>());
</span></span><span style=display:flex><span>          }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#75715e>// 执行处理</span>
</span></span><span style=display:flex><span>      syncContext.<span style=color:#a6e22e>execute</span>(<span style=color:#66d9ef>new</span> NamesResolved());
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div></section><div class=paginator><a class=prev href=https://blog.hellowood.dev/posts/hpa-%E4%BD%BF%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9A%84%E6%8C%87%E6%A0%87%E8%87%AA%E5%8A%A8%E6%89%A9%E7%BC%A9%E5%AE%B9/><svg class="icon" width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M3.77086 21.1546C11.0491 22.698 21.4339 21.7773 21.4339 16.3608V4.63375c0-.69413-.075800000000001-1.3284-.2422-1.86588M3.77086 21.1546C1.9934 20.7777.973585 18.7264 1.08749 16.688c.17931-3.209.06972-7.25665-.08236-10.47293C.87809 3.52811 3.12891 1.16316 5.51029 1.25008c4.25565.15534 9.86671-.04779 13.28091-.24466 1.2952-.074686 2.0494.62843 2.4005 1.76245M3.77086 21.1546C4.56586 21.4723 5.49168 21.7879 6.5 22.0658M21.1917 2.76787c1.918 1.4143 1.9383 9.65123 1.7087 13.59293-2.0526 7.6586-10.5943 7.3054-16.4004 5.705M21.1917 2.76787C21.7612 4.51192 22.7203 9.67216 22 16.3608 21.2797 23.0494 11.3665 22.9511 6.5 22.0658M9.94496 9C9.28897 9.61644 7.63215 10.997 6.04814 11.7966 5.98257 11.8297 5.98456 11.9753 6.05061 12.0063c1.00435.4716 2.8788 1.9201 3.89435 2.9937M6.44444 11.9667C8.86549 12.0608 14 12 16 11" stroke="currentcolor" stroke-linecap="round"/></svg><span>HPA 使用自定义的指标自动扩缩容</span></a>
<a class=next href=https://blog.hellowood.dev/posts/grpc-%E4%BD%BF%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9A%84-nameresolver/><span>gRPC 使用自定义的 NameResolver</span><svg class="icon" width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M3.77086 21.1546C11.0491 22.698 21.4339 21.7773 21.4339 16.3608V4.63375c0-.69413-.075800000000001-1.3284-.2422-1.86588M3.77086 21.1546C1.9934 20.7777.973585 18.7264 1.08749 16.688c.17931-3.209.06972-7.25665-.08236-10.47293C.87809 3.52811 3.12891 1.16316 5.51029 1.25008c4.25565.15534 9.86671-.04779 13.28091-.24466 1.2952-.074686 2.0494.62843 2.4005 1.76245M3.77086 21.1546C4.56586 21.4723 5.49168 21.7879 6.5 22.0658M21.1917 2.76787c1.918 1.4143 1.9383 9.65123 1.7087 13.59293-2.0526 7.6586-10.5943 7.3054-16.4004 5.705M21.1917 2.76787C21.7612 4.51192 22.7203 9.67216 22 16.3608 21.2797 23.0494 11.3665 22.9511 6.5 22.0658M12.055 9C12.711 9.61644 14.3679 10.997 15.9519 11.7966 16.0174 11.8297 16.0154 11.9753 15.9494 12.0063 14.945 12.4779 13.0706 13.9264 12.055 15m3.5006-3.0333C13.1345 12.0608 8 12 6 11" stroke="currentcolor" stroke-linecap="round"/></svg></a></div></article></div><footer class=footer><p>&copy; 2023 <a href=https://blog.hellowood.dev>HelloWood</a>
Powered by
<a href=https://gohugo.io/ rel=noopener target=_blank data-umami-event=to-hugo>Hugo️️</a>
<a href=https://github.com/guangzhengli/hugo-theme-ladder rel=noopener target=_blank data-umami-event=to-ladder>Ladder</a>
️</p></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g data-umami-event=top-link><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M10.5376 22.7916C11.0152 22.7207 22.5795 21.1781 22.0978 10.4211 22.0536 9.43274 21.9303 8.53367 21.7387 7.71865M10.5376 22.7916C16.876 22.3728 20.0969 19.8899 21.5383 16.9142M10.5376 22.7916C9.7707 22.9055 8.97982 22.8964 8.19743 22.7725M21.7387 7.71865C21.4988 6.69828 21.1518 5.80967 20.7188 5.04257m1.0199 2.67608C22.6022 10.1105 23.0542 13.7848 21.5383 16.9142M20.7188 5.04257c-3.5504-6.28886-12.88753-4.410077-16.44303.0C2.88063 6.77451-.0433281 11.1668 1.38159 16.6571c.89322 3.4417 3.7911 5.6365 6.81584 6.1154M20.7188 5.04257c1.3509 1.89783 3.3111 6.34223 1.6353 10.37273M21.5383 16.9142C21.8737 16.4251 22.1428 15.9235 22.3541 15.4153M8.19743 22.7725C12.1971 23.4683 20.6281 22.971 22.3541 15.4153M14 10.945C13.3836 10.289 12.003 8.63215 11.2034 7.04814 11.1703 6.98257 11.0247 6.98456 10.9937 7.05061 10.5221 8.05496 9.07362 9.92941 8 10.945m3.0333-3.50056C10.9392 9.86549 11 15 12 17" stroke="currentcolor" stroke-linecap="round"/></svg></a><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const s=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="Copy";function n(){t.innerHTML="Copied",setTimeout(()=>{t.innerHTML="Copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),n();return}const s=document.createRange();s.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(s);try{document.execCommand("copy"),n()}catch{}o.removeRange(s)}),e.parentNode.appendChild(t)})</script></main></body><script src=https://cdnjs.cloudflare.com/ajax/libs/medium-zoom/1.0.6/medium-zoom.min.js integrity="sha512-N9IJRoc3LaP3NDoiGkcPa4gG94kapGpaA5Zq9/Dr04uf5TbLFU5q0o8AbRhLKUUlp8QFS2u7S+Yti0U7QtuZvQ==" crossorigin=anonymous referrerpolicy=no-referrer></script><script>const images=Array.from(document.querySelectorAll(".blog-content img"));images.forEach(e=>{mediumZoom(e,{margin:10,scrollOffset:40,container:null,template:null,background:"rgba(0, 0, 0, 0.5)"})})</script><script src=/main.min.6bb26b69159420159c74dc9e097b06a578ed2b68c701466a91a44a9632d851bd0af167a1b30012387b4c512b48ad9ad4d3394e04d77ae38d57e1920fe4ed34fe.js integrity="sha512-a7JraRWUIBWcdNyeCXsGpXjtK2jHAUZqkaRKljLYUb0K8WehswASOHtMUStIrZrU0zlOBNd6441X4ZIP5O00/g==" crossorigin=anonymous defer></script></html>