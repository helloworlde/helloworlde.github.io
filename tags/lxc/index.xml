<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>LXC on HelloWood</title><link>https://blog.hellowood.dev/tags/lxc/</link><description>Recent content in LXC on HelloWood</description><generator>Hugo</generator><language>cn</language><lastBuildDate>Mon, 01 Jan 0001 00:00:00 +0000</lastBuildDate><atom:link href="https://blog.hellowood.dev/tags/lxc/index.xml" rel="self" type="application/rss+xml"/><item><title>Proxmox-VE 开启 CT/LXC 容器 Wireguard/Tailscale 访问 TUN 权限</title><link>https://blog.hellowood.dev/posts/proxmox-ve-%E5%BC%80%E5%90%AF-ct-lxc-%E5%AE%B9%E5%99%A8-wireguard-tailscale-%E8%AE%BF%E9%97%AE-tun-%E6%9D%83%E9%99%90/</link><pubDate>Tue, 17 Sep 2024 10:57:59 +0800</pubDate><guid>https://blog.hellowood.dev/posts/proxmox-ve-%E5%BC%80%E5%90%AF-ct-lxc-%E5%AE%B9%E5%99%A8-wireguard-tailscale-%E8%AE%BF%E9%97%AE-tun-%E6%9D%83%E9%99%90/</guid><description>&lt;p>PVE 的 LXC/CT 的容器如果想要使用 Wireguard 或者 Tailscale，需要访问 tun 设备，但是非特权容器并不提供，需要手动挂载&lt;/p>
&lt;h2 id="修改容器配置">修改容器配置&lt;/h2>
&lt;p>需要登录到 PVE 宿主机，修改 LXC/CT 容器对应的配置文件；路径是 &lt;code>/etc/pve/lxc/xxx.conf&lt;/code>，xxx 是容器的编号，以 113 这个容器为例：&lt;/p>
&lt;p>使用 nano 编辑 113.conf 配置文件&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#b0c4de;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>nano /etc/pve/lxc/113.conf
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>113.conf&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code class="language-conf" data-lang="conf">lxc.cgroup2.devices.allow: c 10:200 rwm
lxc.mount.entry: /dev/net/tun dev/net/tun none bind,create=file
&lt;/code>&lt;/pre>&lt;p>修改后的完整配置如下：&lt;/p>
&lt;pre tabindex="0">&lt;code class="language-conf" data-lang="conf">arch: amd64
cores: 2
features: nesting=1
hostname: Debian
memory: 4096
net0: name=eth0,bridge=vmbr0,firewall=1,gw=192.168.2.1,hwaddr=AA:BB:CC:E2:42:EE,ip=192.168.2.8/24,ip6=auto,type=veth
ostype: debian
rootfs: local-lvm:vm-113-disk-0,size=60G
swap: 4096
unprivileged: 1
lxc.cgroup2.devices.allow: c 10:200 rwm
lxc.mount.entry: /dev/net/tun dev/net/tun none bind,create=file
&lt;/code>&lt;/pre>&lt;p>修改后在 PVE 控制台重启容器即可&lt;/p></description></item><item><title>Proxmox VE 创建自定义的 LXC 容器 CT 模板</title><link>https://blog.hellowood.dev/posts/proxmox-ve-%E5%88%9B%E5%BB%BA%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9A%84-lxc-%E5%AE%B9%E5%99%A8-ct-%E6%A8%A1%E6%9D%BF/</link><pubDate>Sun, 07 Jan 2024 12:00:10 +0800</pubDate><guid>https://blog.hellowood.dev/posts/proxmox-ve-%E5%88%9B%E5%BB%BA%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9A%84-lxc-%E5%AE%B9%E5%99%A8-ct-%E6%A8%A1%E6%9D%BF/</guid><description>&lt;p>LXC 是一种操作系统级别的虚拟化容器技术，可以理解为比 VM 更轻量的容器虚拟机；Docker 适用于为服务提供隔离环境，LXC 容器适用于作为虚拟机进行隔离；在 PVE 上 LXC 称为 CT&lt;/p>
&lt;p>在使用 PVE 的过程中会创建多个容器，容器的基础配置基本相同，通过模板的方式创建更方便；虽然 LXC 容器提供了类似 Dockerfile 的配置文件可以创建镜像，但是使用起来比较复杂，学习成本较高；因此可以基于 LXC 容器进行初始化，然后将修改后的 LXC 容器作为基础创建模板&lt;/p>
&lt;h2 id="创建-lxc-容器">创建 LXC 容器&lt;/h2>
&lt;p>以 Ubuntu 容器为例进行模板的创建，在 PVE 控制页面创建一个 LXC 容器并启动&lt;/p>
&lt;p>

 &lt;img src="https://img.hellowood.dev/picture/homelab-pve-ct-template-create-ct-by-origin-template.png" alt="homelab-pve-ct-template-create-ct-by-origin-template.png" loading="lazy">
&lt;/p>
&lt;h2 id="初始化-lxc-容器配置">初始化 LXC 容器配置&lt;/h2>
&lt;p>登录到创建的 LXC 容器中，根据需求安装需要用到的软件和配置进行初始化，可以参考 &lt;a href="https://blog.hellowood.dev/posts/ubuntu-22-%E7%8E%AF%E5%A2%83%E5%88%9D%E5%A7%8B%E5%8C%96">ubuntu-22-环境初始化&lt;/a>&lt;/p>
&lt;h2 id="创建-ct-模板">创建 CT 模板&lt;/h2>
&lt;h3 id="清理容器">清理容器&lt;/h3>
&lt;p>清理容器的目的是删除可能变化配置和不需要的文件及配置&lt;/p>
&lt;ul>
&lt;li>清除无效软件&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#b0c4de;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>apt autoremove
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>清除 DNS 和主机名配置&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#b0c4de;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>rm /etc/resolv.conf
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>rm /etc/hostname
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>清除操作命令&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#b0c4de;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ef8383">history&lt;/span> -c
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="备份-lxc-容器">备份 LXC 容器&lt;/h3>
&lt;p>清理完成后，回到 PVE 的控制页面，选择刚才创建的 CT 容器进行备份&lt;/p>
&lt;p>

 &lt;img src="https://img.hellowood.dev/picture/homelab-pve-ct-template-backup-ct-as-template.png" alt="homelab-pve-ct-template-backup-ct-as-template.png" loading="lazy">
&lt;/p>
&lt;h3 id="将备份作为-ct-模板">将备份作为 CT 模板&lt;/h3>
&lt;p>登录到 PVE 机器，将刚才的备份从 &lt;code>/var/lib/vz/dump/&lt;/code> 目录移动到存放 CT 模板的 &lt;code>/var/lib/vz/template/cache/&lt;/code> 目录&lt;/p></description></item><item><title>在PVE的LXC容器中直通核心显卡</title><link>https://blog.hellowood.dev/posts/%E5%9C%A8pve%E7%9A%84lxc%E5%AE%B9%E5%99%A8%E4%B8%AD%E7%9B%B4%E9%80%9A%E6%A0%B8%E5%BF%83%E6%98%BE%E5%8D%A1/</link><pubDate>Sat, 09 Sep 2023 17:53:36 +0800</pubDate><guid>https://blog.hellowood.dev/posts/%E5%9C%A8pve%E7%9A%84lxc%E5%AE%B9%E5%99%A8%E4%B8%AD%E7%9B%B4%E9%80%9A%E6%A0%B8%E5%BF%83%E6%98%BE%E5%8D%A1/</guid><description>&lt;p>在 ProxmoxVE 平台中使用 LXC 容器使用 Docker 部署 &lt;a href="https://frigate.video/">frigate&lt;/a> 时(或其他需要GPU的容器如Jellyfin等)，需要使用 GPU 对 ffmpeg 进行加速，因此需要将宿主机 N5105 的核心显卡挂载到 LXC 容器到 Docker 容器中&lt;/p>
&lt;h2 id="安装核显驱动">安装核显驱动&lt;/h2>
&lt;ul>
&lt;li>查看设备&lt;/li>
&lt;/ul>
&lt;p>如果能够看到 PCI 设备中包含核心显卡，说明设备识别正常&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#b0c4de;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>lspci | grep VGA
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>00:02.0 VGA compatible controller: Intel Corporation JasperLake &lt;span style="color:#c7bf54">[&lt;/span>UHD Graphics&lt;span style="color:#c7bf54">]&lt;/span> &lt;span style="color:#c7bf54">(&lt;/span>rev 01&lt;span style="color:#c7bf54">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>查看驱动&lt;/li>
&lt;/ul>
&lt;p>可以看到 card0 和 renderD128 都存在，说明驱动正常&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#b0c4de;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>ls /dev/dri/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>by-path card0	renderD128
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>通常不需要安装驱动，如果设备没有正确识别，可以参考 &lt;a href="https://dgpu-docs.intel.com/driver/installation.html#ubuntu-install-steps">https://dgpu-docs.intel.com/driver/installation.html#ubuntu-install-steps&lt;/a> 进行安装&lt;/p>
&lt;h2 id="创建-lxc-容器">创建 LXC 容器&lt;/h2>
&lt;p>如图，在 PVE的控制界面，选择创建 CT 容器；配置中取消 &amp;ldquo;无特权容器&amp;rdquo; 的勾选，模板选择 CentOS 或 Ubuntu 等均可&lt;/p>
&lt;p>

 &lt;img src="https://img.hellowood.dev/picture/homelab-pve-lxc-intel-graphics-mount-1.png" alt="homelab-pve-lxc-intel-graphics-mount-1.png" loading="lazy">
&lt;/p>
&lt;p>

 &lt;img src="https://img.hellowood.dev/picture/homelab-pve-lxc-intel-graphics-mount-2.png" alt="homelab-pve-lxc-intel-graphics-mount-2.png" loading="lazy">
&lt;/p>
&lt;p>创建完成后，即可看到容器的 ID，即VMID，这里是 104&lt;/p>
&lt;h2 id="修改核心显卡直通">修改核心显卡直通&lt;/h2>
&lt;p>修改核心显卡直通，需要使用 PVE 宿主机的命令行修改 LXC 容器的配置文件&lt;/p></description></item></channel></rss>