<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>DNS on HelloWood</title><link>https://blog.hellowood.dev/tags/dns/</link><description>Recent content in DNS on HelloWood</description><generator>Hugo</generator><language>cn</language><lastBuildDate>Tue, 02 Sep 2025 00:00:00 +0000</lastBuildDate><atom:link href="https://blog.hellowood.dev/tags/dns/index.xml" rel="self" type="application/rss+xml"/><item><title>使用 Split DNS 打造 HomeLab 内网和公网一致的访问体验</title><link>https://blog.hellowood.dev/posts/%E4%BD%BF%E7%94%A8-split-dns-%E6%89%93%E9%80%A0-homelab-%E5%86%85%E7%BD%91%E5%92%8C%E5%85%AC%E7%BD%91%E4%B8%80%E8%87%B4%E7%9A%84%E8%AE%BF%E9%97%AE%E4%BD%93%E9%AA%8C/</link><pubDate>Tue, 02 Sep 2025 00:00:00 +0000</pubDate><guid>https://blog.hellowood.dev/posts/%E4%BD%BF%E7%94%A8-split-dns-%E6%89%93%E9%80%A0-homelab-%E5%86%85%E7%BD%91%E5%92%8C%E5%85%AC%E7%BD%91%E4%B8%80%E8%87%B4%E7%9A%84%E8%AE%BF%E9%97%AE%E4%BD%93%E9%AA%8C/</guid><description>&lt;p&gt;Split DNS（分割DNS）是一种DNS配置技术，指对同一个域名在不同网络环境下提供不同的DNS解析结果；例如在内网环境下访问 &lt;code&gt;example.com&lt;/code&gt; 解析到内网IP地址，而在公网环境下访问 &lt;code&gt;example.com&lt;/code&gt; 解析到公网IP地址；&lt;/p&gt;
&lt;p&gt;

 &lt;img src="https://img.hellowood.dev/picture/homelab-split-dns-diagram-2.svg" alt="homelab-split-dns-diagram-2.svg" loading="lazy"&gt;
&lt;/p&gt;
&lt;p&gt;在 HomeLab 场景下，服务部署在内网，可以直接访问；而外网通常需要使用 Cloudflare Tunnel 等反向代理工具进行转发；之前在内网尝试过使用 &lt;code&gt;.local&lt;/code&gt;/&lt;code&gt;.homelab&lt;/code&gt; 等域名访问服务，但是一些强依赖 HTTPS 的服务（如 PocketID）因自签名证书不信任问题无法使用(Java/Python服务、Firefox浏览器等均有自己的校验规则)；同时内网访问和外网访问的域名不一致，需要分别记住内网和外网的访问地址，影响使用体验&lt;/p&gt;
&lt;p&gt;为了解决上述问题，可以使用 Split DNS，将内网的请求转发到内网的反向代理上，使用 Let&amp;rsquo;s Encrypt 颁发的证书，保证内外网访问地址一致，并且支持 HTTPS 访问&lt;/p&gt;
&lt;p&gt;公网访问时 DNS 解析到 Cloudflare Tunnel，然后请求由 Tunnel 带着 Host Header 转发到 Caddy 再转发给具体的服务；内网访问时使用 AdGuard 覆盖了内网的 DNS 解析，将请求转发到 Caddy，再转发给具体的服务&lt;/p&gt;
&lt;h2 id="配置-caddy-路由规则"&gt;配置 Caddy 路由规则&lt;/h2&gt;
&lt;h3 id="申请证书"&gt;申请证书&lt;/h3&gt;
&lt;p&gt;证书可以使用免费的 Let&amp;rsquo;s Encrypt 证书，或者 ZeroSSL 等免费证书颁发机构申请，参考 &lt;a href="https://blog.hellowood.dev/posts/%E4%BD%BF%E7%94%A8-lets-encrypt-%E7%94%B3%E8%AF%B7-https-%E8%AF%81%E4%B9%A6/"&gt;使用 Let’s Encrypt 申请 HTTPS 证书&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;建议直接申请泛域名证书，例如 &lt;code&gt;*.example.com&lt;/code&gt;，这样可以保证后续添加新的服务时不需要重新申请证书，减少维护成本&lt;/p&gt;
&lt;h3 id="配置路由"&gt;配置路由&lt;/h3&gt;
&lt;p&gt;在 Caddy 的路由配置中添加路由规则，同时指定刚才申请的证书路径&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Caddyfile&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex="0"&gt;&lt;code class="language-conf" data-lang="conf"&gt;whoami.example.com {
 tls /certs/_.example.com.crt /certs/_.example.com.key
 reverse_proxy 100.0.0.3:8081
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;详细信息可以参考:&lt;/p&gt;</description></item><item><title>OpenWrt 使用 SmartDNS</title><link>https://blog.hellowood.dev/posts/openwrt-%E4%BD%BF%E7%94%A8-smartdns/</link><pubDate>Tue, 27 Sep 2022 11:32:08 +0800</pubDate><guid>https://blog.hellowood.dev/posts/openwrt-%E4%BD%BF%E7%94%A8-smartdns/</guid><description>&lt;p&gt;&lt;a href="https://pymumu.github.io/smartdns/"&gt;SmartDNS&lt;/a&gt; 是由国内用户开发的本地 DNS 服务器，从多个上游获取 DNS 结果，并将访问速度最快的地址返回给客户端；SmartDNS 可以运行在多个平台，如 Linux, OpenWrt 等&lt;/p&gt;
&lt;p&gt;在 OpenWrt 中运行 SmartDNS，将其作为 dnsmasq 的上游或作为唯一的 DNS 服务器，用于提升 DNS 解析速度&lt;/p&gt;
&lt;h2 id="安装"&gt;安装&lt;/h2&gt;
&lt;p&gt;SmartDNS 的安装非常简单，使用 opkg 命令即可安装&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-bash" data-lang="bash"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;opkg update
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;opkg install smartdns
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;opkg install luci-app-smartdns
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;opkg install luci-i18n-smartdns-zh-cn
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id="配置-smartdns"&gt;配置 SmartDNS&lt;/h2&gt;
&lt;p&gt;安装完成后，在服务-SmartDNS 常规配置中，选择启用 SmartDNS，然后添加上游 DNS 服务器（也可以直接在命令行修改 &lt;code&gt;/etc/config/smartdns&lt;/code&gt; 配置文件）&lt;/p&gt;
&lt;p&gt;

 &lt;img src="https://img.hellowood.dev/picture/homelab-openwrt-dns-smartdns-upstream.png" alt="homelab-openwrt-dns-smartdns-upstream.png" loading="lazy"&gt;
&lt;/p&gt;
&lt;p&gt;这样，SmartDNS 会运行在路由器的 6053 端口上&lt;/p&gt;
&lt;h2 id="配置-dnsmasq"&gt;配置 Dnsmasq&lt;/h2&gt;
&lt;p&gt;OpenWrt 默认的 DHCP 和 DNS 服务由 Dnsmasq 提供，所以需要配置 SmartDNS 作为 Dnsmasq 的上游 DNS 服务器&lt;/p&gt;
&lt;p&gt;在网络-DHCP/DNS -常规设置中，添加 DNS 转发，将 SmartDNS 作为 Dnsmasq 的上游


 &lt;img src="https://img.hellowood.dev/picture/homelab-oepnwrt-smart-dns-as-dnsmasq-upstream.png" alt="homelab-oepnwrt-smart-dns-as-dnsmasq-upstream.png" loading="lazy"&gt;
&lt;/p&gt;</description></item><item><title>使用 Pi-hole 作为 DNS 和 DHCP 服务器</title><link>https://blog.hellowood.dev/posts/%E4%BD%BF%E7%94%A8-pi-hole-%E4%BD%9C%E4%B8%BA-dns-%E5%92%8C-dhcp-%E6%9C%8D%E5%8A%A1%E5%99%A8/</link><pubDate>Mon, 05 Sep 2022 11:32:08 +0800</pubDate><guid>https://blog.hellowood.dev/posts/%E4%BD%BF%E7%94%A8-pi-hole-%E4%BD%9C%E4%B8%BA-dns-%E5%92%8C-dhcp-%E6%9C%8D%E5%8A%A1%E5%99%A8/</guid><description>&lt;p&gt;在使用 OpenWrt 的过程中，因为会经常修改 OpenWrt 的配置，导致 OpenWrt 出问题重新安装后没有来得及备份的配置丢失；其中以 IP 地址静态分配最多&lt;/p&gt;
&lt;p&gt;另外，因为需要通过 DNS 做广告拦截，所以需要使用 Pi-hole 作为 DNS 服务器，但是 Pi-hole 提供的 DNS 服务都是国外的，所以为了快速解析国内的 DNS，需要使用 Smartdns 作为 Pi-hole DNS 的上游；DNS 的解析在 Smartdns 中提供&lt;/p&gt;
&lt;h2 id="配置-docker-macvlan-网络"&gt;配置 Docker macvlan 网络&lt;/h2&gt;
&lt;p&gt;因为在同一个服务器上提供了多个服务，因此存在端口冲突问题，Pi-hole 和 Smartdns 都需要 53 端口用于提供 DNS，而且 53 端口默认被 Ubuntu Server 使用；而且局域网中的设备需要访问 DHCP 服务，因此为了避免冲突，需要使用 &lt;code&gt;macvlan&lt;/code&gt; 作为 Docker 网络的驱动&lt;/p&gt;
&lt;p&gt;&lt;code&gt;macvlan&lt;/code&gt; 是一种网卡虚拟化技术，允许在同一个物理网卡上配置多个 MAC 地址，即多个 interface，每个 interface 可以配置自己的 IP&lt;/p&gt;
&lt;p&gt;通过 &lt;code&gt;macvlan&lt;/code&gt;，可以为每个 Docker 容器提供特定的 IP 地址，用于局域网内的设置直接通过容器的 IP 地址访问&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;开启网卡混杂模式&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;默认情况下网卡只会将发送给本机的包传递到上层服务，其他的包一律丢弃；开启混杂模式后机器的网卡能够接收所有流经过它的数据流，而无论其目的地址是否是它，因此，为了能让 Docker 容器能正常收到其他设备的请求，需要开启网卡混杂模式；需要注意 &lt;code&gt;eth0&lt;/code&gt; 要和实际的网卡名称一致&lt;/p&gt;</description></item></channel></rss>